<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-25T17:29:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html"></title><link href="http://localhost:4000/2023-04-16-install-lua/" rel="alternate" type="text/html" title="" /><published>2023-04-25T17:29:12+09:00</published><updated>2023-04-25T17:29:12+09:00</updated><id>http://localhost:4000/2023-04-16-install-lua</id><content type="html" xml:base="http://localhost:4000/2023-04-16-install-lua/"><![CDATA[<h2 id="lua-설치---사전준비">lua 설치 - 사전준비</h2>
<p>사전에 compiler가 설치되어 있어야 합니다.
Compiler가 설치되어 있지 않는 경우 다음을 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo yum update -y
yum groupinstall -y 'Development Tools'
</code></pre></div></div>
<h2 id="lua-설치">lua 설치</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-R</span> <span class="nt">-O</span> http://www.lua.org/ftp/lua-5.4.4.tar.gz
<span class="nb">tar </span>zxf lua-5.4.4.tar.gz
<span class="nb">cd </span>lua-5.4.4
make all <span class="nb">test</span>
</code></pre></div></div>

<h2 id="lua-cli-실행">lua cli 실행</h2>
<p>lua를 실행하고 Hello World를 출력합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/lua
str = "Hello World"
print(str)
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author></entry><entry><title type="html">Redis 시작하기 - Usecases - Leaderboard</title><link href="http://localhost:4000/cache/usecases-leaderboard/" rel="alternate" type="text/html" title="Redis 시작하기 - Usecases - Leaderboard" /><published>2023-04-22T00:00:00+09:00</published><updated>2023-04-22T00:00:00+09:00</updated><id>http://localhost:4000/cache/usecases-leaderboard</id><content type="html" xml:base="http://localhost:4000/cache/usecases-leaderboard/"><![CDATA[<p>LUA 스크립팅의 효율적인 방법으로 수행 할 수 있는 사례에 사용될 수 사례를 살펴봅니다.
여기에는 Redis zset에 유지되는 리더 보드가 있으며, 현재 사용 사례를 위해 주어진 사용자의 경우 해당 사용자의 순위와 리더 보드에서 사용자의 주변의 rank를 얻을 수도 있습니다.</p>

<p><img src="/assets/images/cache/30-cache-leaderboard.png" alt="locked" /></p>

<p>아래의 2 개의 명령이 연속적으로 수행했을 때 정확한 결과를 가져오는가?</p>

<ul>
  <li>첫 번째는 Zrank Leaderboard Heather를 사용하여 사용자 순위를 얻습니다</li>
  <li>그런 다음 위의 순위를 사용하여 하위 및 상한을 얻으려면 아래에서 3을, 아래 3 개를 원한다고 가정 해 봅시다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6383&gt; zadd leaderboard 10 Andrew 20 Bella 30 Andy 33 Dolly 40 Cathy 42 Heather 43 Gilbert 45 Lilly 50  Dinesh 58 <span class="s2">"Jon snow"</span> 60 Ygnitte
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6383&gt; zrange leaderboard 0 <span class="nt">-1</span>
 1<span class="o">)</span> <span class="s2">"Andrew"</span>
 2<span class="o">)</span> <span class="s2">"Bella"</span>
 3<span class="o">)</span> <span class="s2">"Andy"</span>
 4<span class="o">)</span> <span class="s2">"Dolly"</span>
 5<span class="o">)</span> <span class="s2">"Cathy"</span>
 6<span class="o">)</span> <span class="s2">"Heather"</span>
 7<span class="o">)</span> <span class="s2">"Gilbert"</span>
 8<span class="o">)</span> <span class="s2">"Lilly"</span>
 9<span class="o">)</span> <span class="s2">"Dinesh"</span>
10<span class="o">)</span> <span class="s2">"Jon snow"</span>
11<span class="o">)</span> <span class="s2">"Ygnitte"</span>
127.0.0.1:6383&gt; zrank leaderboard Heather
<span class="o">(</span>integer<span class="o">)</span> 5
127.0.0.1:6383&gt; zrange leaderboard 2 8
1<span class="o">)</span> <span class="s2">"Andy"</span>
2<span class="o">)</span> <span class="s2">"Dolly"</span>
3<span class="o">)</span> <span class="s2">"Cathy"</span>
4<span class="o">)</span> <span class="s2">"Heather"</span>
5<span class="o">)</span> <span class="s2">"Gilbert"</span>
6<span class="o">)</span> <span class="s2">"Lilly"</span>
7<span class="o">)</span> <span class="s2">"Dinesh"</span>
</code></pre></div></div>

<p>그러나 리더 보드는 zrank와 zrange Redis 명령어를 실행하는 사이에 순위가 변경 될 수 있습니다.
이를 해결하기 위한 솔루션 중 하나는 사용자의 순위를 얻기 전에 일종의 lock 장치를 사용한 다음 zrange를 사용한 다음 lock을 제거하는 것입니다. 그리고 이전에, 리더 보드에 쓰고, 우리는 lock을 점검해야하며, lock 장치가 있으면 lock 장치가 제거 될 때까지 재 시도해야합니다.</p>

<p><img src="/assets/images/cache/29-cache-locked.png" alt="locked" /></p>

<p>유스 케이스를 처리하는 우아한 방법은 LUA 스크립트를 사용하는 것입니다
Redis는 서버에서 LUA 스크립트를 업로드하고 실행할 수 있으며 스크립트가 서버에서 실행되기 때문에 스크립트에서 데이터를 읽고 쓰는 것이 매우 효율적입니다.
또한 Redis는 스크립트의 원자(Atomic) 실행을 보장합니다. 스크립트를 실행하는 동안 전체 런타임 중에 모든 서버의 명령이 차단됩니다.</p>

<p>간단한 LUA 스크립트를 작성하여 어떻게 문제를 해결할 수 있는지 보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">local </span>rank <span class="o">=</span> redis.call<span class="o">(</span><span class="s1">'zrank'</span>, KEYS[1], ARGV[1]<span class="o">)</span><span class="p">;</span>
<span class="nb">local </span>min <span class="o">=</span> math.max<span class="o">(</span>rank - ARGV[2], 0<span class="o">)</span><span class="p">;</span>
<span class="nb">local </span>max <span class="o">=</span> rank + ARGV[2]<span class="p">;</span>
<span class="nb">local </span>ldb <span class="o">=</span> redis.call<span class="o">(</span><span class="s1">'zrange'</span>, KEYS[1], min, max<span class="o">)</span><span class="p">;</span>

<span class="k">return</span> <span class="o">{</span>rank+1, ldb<span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p>| member | score | rank |
— — — — — — — — — — —
| member_1 | 50 | 1 |
| member_2 | 50 | 1 |
| member_3 | 30 | 3 |
| member_4 | 30 | 3 |
| member_5 | 10 | 5 |</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; zadd test-leaderboard 9 user1
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zadd test-leaderboard 5 user2
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zadd test-leaderboard 5 user3
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zadd test-leaderboard 3 user4
<span class="o">(</span>integer<span class="o">)</span> 1

127.0.0.1:6379&gt; zrank test-leaderboard user2
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zrank test-leaderboard user3
<span class="o">(</span>integer<span class="o">)</span> 2

127.0.0.1:6379&gt; ZSCORE test-leaderboard user3
<span class="s2">"5"</span>
127.0.0.1:6379&gt; ZRANGEBYSCORE test-leaderboard 5 5 LIMIT 0 1
1<span class="o">)</span> <span class="s2">"user2"</span>
127.0.0.1:6379&gt; ZRANK test-leaderboard user2
<span class="o">(</span>integer<span class="o">)</span> 1

127.0.0.1:6379&gt; ZADD test-leaderboard 5 user2
127.0.0.1:6379&gt; ZADD test-ranks 5 5

EVAL <span class="s2">"local score = redis.call('ZSCORE', KEYS[1], ARGV[1]) </span><span class="se">\n</span><span class="s2"> return redis.call('ZRANK', KEYS[2], score)"</span> 2 test-leaderboard test-ranks user2
<span class="o">(</span>integer<span class="o">)</span> 1
</code></pre></div></div>

<p>스크립트를 한 줄로 보면</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[LUA 스크립팅의 효율적인 방법으로 수행 할 수 있는 사례에 사용될 수 사례를 살펴봅니다. 여기에는 Redis zset에 유지되는 리더 보드가 있으며, 현재 사용 사례를 위해 주어진 사용자의 경우 해당 사용자의 순위와 리더 보드에서 사용자의 주변의 rank를 얻을 수도 있습니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Redis vs Memcached</title><link href="http://localhost:4000/cache/redis-mencache/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis vs Memcached" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-21T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-mencache</id><content type="html" xml:base="http://localhost:4000/cache/redis-mencache/"><![CDATA[<p>redis와 Memcached를 비교합니다.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>Redis</th>
      <th>Memcached</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>특징</td>
      <td>메모리 DB</td>
      <td>고성능 분산 캐시 서버</td>
    </tr>
    <tr>
      <td>저장방식</td>
      <td>메모리 캐시 및 스토리지</td>
      <td>메모리</td>
    </tr>
    <tr>
      <td>지원 데이터 타입</td>
      <td>다양한 데이터 타입지원<br />String/List/Hashes/Set/Sorted Set</td>
      <td>String key/value만 지원</td>
    </tr>
    <tr>
      <td>키목록 조죄</td>
      <td>모든 키목록</td>
      <td>모든 키 목록 지원 않음</td>
    </tr>
    <tr>
      <td>복제</td>
      <td>Primary/replica</td>
      <td>복제 지원 않음</td>
    </tr>
    <tr>
      <td>클러스터</td>
      <td>클러스터 지원</td>
      <td>Not support</td>
    </tr>
    <tr>
      <td>Pub/Sub</td>
      <td>Pub/Sub model 지원</td>
      <td>Not support</td>
    </tr>
    <tr>
      <td>Script</td>
      <td>LUA Script 지원</td>
      <td>Not support</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="mencached" /><summary type="html"><![CDATA[redis와 Memcached를 비교합니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Lua 에서 return String, List, JSON 형식으로 받기.</title><link href="http://localhost:4000/cache/return-list-using-lua/" rel="alternate" type="text/html" title="Redis 시작하기 - Lua 에서 return String, List, JSON 형식으로 받기." /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-21T00:00:00+09:00</updated><id>http://localhost:4000/cache/return-list-using-lua</id><content type="html" xml:base="http://localhost:4000/cache/return-list-using-lua/"><![CDATA[<p>Springboot Lettuce기반 Lua를 호출하여 결과값을 List 받는 방법을 공유합니다.
Lua를 를 이용해서 Boolean, Long 타입은 별다른 어려움없이 응답을 받을 수 있습니다. 그러나 String이나 List같은 경우는 RedisTemplate 기본 설정으로는 결과를 받을 수 없고 다음과 같은 오류를 만나게 될 것입니다. 이것은 GenericJackson2JsonRedisSerializer에서 byte[]를 deserialization을 하지 못해서 발생하는 에러입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>com.fasterxml.jackson.core.JsonParseException: Unrecognized token <span class="s1">'test'</span>: was expecting <span class="o">(</span>JSON String, Number, Array, Object or token <span class="s1">'null'</span>, <span class="s1">'true'</span> or <span class="s1">'false'</span><span class="o">)</span>
 at <span class="o">[</span>Source: <span class="o">(</span>byte[]<span class="o">)</span><span class="s2">"test"</span><span class="p">;</span> line: 1, column: 5]
	at com.fasterxml.jackson.core.JsonParser._constructError<span class="o">(</span>JsonParser.java:2391<span class="o">)</span> ~[jackson-core-2.13.5.jar!/:2.13.5]
</code></pre></div></div>

<p>그래서 다음과 같은 방법으로 해결이 가능하며, Lua를 통해서 JSON, String, List등을 반환값으로 받을 수 있습니다.</p>

<ul>
  <li>GenericJackson2JsonRedisSerializer에서 extends</li>
  <li>deserialize를 overriding</li>
</ul>

<p>GenericJackson2JsonRedisSerializer를 extention하여 overriding하는 소스는 다음과 같습니다. GenericJackson2JsonRedisSerializer를 CustomJackson2JsonRedisSerializer로 변경하면 Lua에서 반환값을 다양하게 받을 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Objects</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.serializer.SerializationException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.lang.Nullable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.util.Assert</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.ObjectMapper</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>

<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomJackson2JsonRedisSerializer</span> <span class="kd">extends</span> <span class="nc">GenericJackson2JsonRedisSerializer</span> <span class="o">{</span>
	<span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
	<span class="cm">/**
	 * @param source can be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @return {@literal null} for empty source.
	 * @throws SerializationException
	 */</span>
	<span class="nd">@Nullable</span>
	<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">SerializationException</span> <span class="o">{</span>
		<span class="no">T</span> <span class="n">clazz</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">try</span> <span class="o">{</span>
			
			<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">type</span><span class="o">,</span>
					<span class="s">"Deserialization type must not be null! Please provide Object.class to make use of Jackson2 default typing."</span><span class="o">);</span>

			<span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="n">source</span><span class="o">))</span> <span class="o">{</span>
				<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
			<span class="o">}</span>

			<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Source:{}, class:{}"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">source</span><span class="o">),</span> <span class="n">type</span><span class="o">);</span>
			<span class="n">clazz</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">source</span><span class="o">),</span> <span class="n">type</span><span class="o">);</span>
			<span class="k">return</span> <span class="n">clazz</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">SerializationException</span><span class="o">(</span><span class="s">"Could not read JSON: "</span> <span class="o">+</span> <span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">ex</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="redis-configuration">Redis Configuration</h4>
<p>RedisTemplate Value Serializer에 CustomJackson2JsonRedisSerializer를 설정합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">redisTemplate</span><span class="o">(</span><span class="nc">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span><span class="o">){</span>
    	<span class="nc">CustomJackson2JsonRedisSerializer</span> <span class="n">customJackson2JsonRedisSerializer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CustomJackson2JsonRedisSerializer</span><span class="o">();</span>
    	
        <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisTemplate</span><span class="o">&lt;&gt;();</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setConnectionFactory</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">);</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setKeySerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringRedisSerializer</span><span class="o">());</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setValueSerializer</span><span class="o">(</span><span class="n">customJackson2JsonRedisSerializer</span><span class="o">);</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setDefaultSerializer</span><span class="o">(</span><span class="n">customJackson2JsonRedisSerializer</span><span class="o">);</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setDefaultSerializer</span><span class="o">(</span><span class="n">customJackson2JsonRedisSerializer</span><span class="o">);</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setKeySerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringRedisSerializer</span><span class="o">());</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setValueSerializer</span><span class="o">(</span><span class="n">customJackson2JsonRedisSerializer</span><span class="o">);</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setHashKeySerializer</span><span class="o">(</span><span class="n">customJackson2JsonRedisSerializer</span><span class="o">);</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setHashValueSerializer</span><span class="o">(</span><span class="n">customJackson2JsonRedisSerializer</span><span class="o">);</span>        
        <span class="k">return</span> <span class="n">redisTemplate</span><span class="o">;</span>
    <span class="o">}</span>   
</code></pre></div></div>
<h4 id="leaderboard-lua">leaderboard Lua</h4>
<p>Lua 예제는 다음과 같습니다.</p>
<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- leaderboard.lua </span>
<span class="kd">local</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'zrank'</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="kd">local</span> <span class="n">min</span> <span class="o">=</span> <span class="nb">math.max</span><span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">max</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">+</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kd">local</span> <span class="n">ldb</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s1">'zrange'</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">results</span><span class="p">[</span><span class="s1">'rank'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">results</span><span class="p">[</span><span class="s1">'item'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldb</span>

<span class="kd">local</span> <span class="n">vars</span> <span class="o">=</span> <span class="n">cjson</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

<span class="k">return</span> <span class="n">vars</span>
</code></pre></div></div>

<h4 id="redis에-적용하기">redis에 적용하기</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>leaderboard.lua | redis-cli <span class="nt">-x</span> script load
<span class="s2">"60e0429ac3aed8dbb3abfeb4fb2d13dde103d575"</span>

 127.0.0.1:6379&gt; evalsha <span class="s2">"60e0429ac3aed8dbb3abfeb4fb2d13dde103d575"</span> 2 leaderboard Heather 3
<span class="s2">"{</span><span class="se">\"</span><span class="s2">item</span><span class="se">\"</span><span class="s2">:[</span><span class="se">\"</span><span class="s2">Andy</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">Dolly</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">Cathy</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">Heather</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">Gilbert</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">Lilly</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">Dinesh</span><span class="se">\"</span><span class="s2">],</span><span class="se">\"</span><span class="s2">rank</span><span class="se">\"</span><span class="s2">:</span><span class="se">\"</span><span class="s2">6</span><span class="se">\"</span><span class="s2">}"</span>
</code></pre></div></div>
<h4 id="redistemplate--lettuce를-이용">RedisTemplate &amp; Lettuce를 이용</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">retrieveLeaderBoard</span><span class="o">(</span><span class="nc">LeaderBoardReqVO</span> <span class="n">leaderBoardReqVO</span><span class="o">)</span> <span class="o">{</span>
    	<span class="nc">DefaultRedisScript</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisScript</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultRedisScript</span><span class="o">&lt;&gt;();</span>
    	<span class="nc">Resource</span> <span class="n">resource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathResource</span><span class="o">(</span><span class="n">leaderBoard</span><span class="o">);</span>
    	<span class="n">redisScript</span><span class="o">.</span><span class="na">setScriptSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">ResourceScriptSource</span><span class="o">(</span><span class="n">resource</span><span class="o">));</span>
    	<span class="n">redisScript</span><span class="o">.</span><span class="na">setResultType</span><span class="o">(</span><span class="nc">Object</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    	<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"retrieveLeaderBoard:{}"</span><span class="o">,</span> <span class="n">leaderBoardReqVO</span><span class="o">);</span>
    	<span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]</span> <span class="o">{</span><span class="n">leaderBoardReqVO</span><span class="o">.</span><span class="na">getUser</span><span class="o">()};</span>
    	<span class="nc">Object</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">redisScript</span><span class="o">,</span>  <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">leaderBoardReqVO</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">leaderBoardReqVO</span><span class="o">.</span><span class="na">getUser</span><span class="o">()),</span> <span class="n">leaderBoardReqVO</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>
    	
    	<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"retrieveLeaderBoard ret:{}"</span><span class="o">,</span> <span class="n">ret</span><span class="o">);</span>
    	
    	<span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h2 id="swagger-ui에서-호출">Swagger UI에서 호출</h2>

<p><img src="/assets/images/cache/31-cache-leaderboard-swagger.png" alt="m1s1-r1s2-r3s3" /></p>

<p>[수행결과과]<br />
<img src="/assets/images/cache/32-cache-result-leaderboard.png" alt="m1s1-r1s2-r3s3" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="Lua" /><summary type="html"><![CDATA[Springboot Lettuce기반 Lua를 호출하여 결과값을 List 받는 방법을 공유합니다. Lua를 를 이용해서 Boolean, Long 타입은 별다른 어려움없이 응답을 받을 수 있습니다. 그러나 String이나 List같은 경우는 RedisTemplate 기본 설정으로는 결과를 받을 수 없고 다음과 같은 오류를 만나게 될 것입니다. 이것은 GenericJackson2JsonRedisSerializer에서 byte[]를 deserialization을 하지 못해서 발생하는 에러입니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Lua 스크립트 등록 및 실행</title><link href="http://localhost:4000/cache/run-lua-on-redis-cli/" rel="alternate" type="text/html" title="Redis 시작하기 - Lua 스크립트 등록 및 실행" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-21T00:00:00+09:00</updated><id>http://localhost:4000/cache/run-lua-on-redis-cli</id><content type="html" xml:base="http://localhost:4000/cache/run-lua-on-redis-cli/"><![CDATA[<p>스크립팅을 사용하면 Redis 내에서 복잡한 작업을 실행할 수 있습니다.<br />
Redis 스크립트를 사용하면 제어 구조와 같은 프로그래밍 도구를 사용할 수 있으며 거의 ​​모든 Redis 명령에 액세스 할 수 있습니다.</p>

<p>그렇다면 왜 명령을 직접 실행하여 또는 응용 프로그램 자체에서 Redis 스크립트를 사용합니까?</p>
<ul>
  <li>작업이 Redis Cache 서버에서 직접 실행되 성능이 크게 증가합니다.</li>
  <li>Logic은  Redis 서버에서 직접 적재되고, 분산되어 있는 여러 응용프로그램에서 사용가능.</li>
  <li>atomic하게 실행되므로 스크립트가 실행중인 동안 동시에 다른 서버가 해당 스크립트를 실행 하는 것을 방지 함.</li>
</ul>

<p>Lua는 Redis 스크립팅의 언어입니다. LUA 언어는 단순성과 간결함을 제공하므로 스크립팅 작업에 효과적인 언어입니다.</p>

<p>그러나 스크립트가 모든 경우에 적합하지는 않습니다. Redis 서버는 스크긴트가 실행되는 동안 다른 작업을 차단하기 때문에 로직이 긴 스크립트는 실제로 성능에 영향을 미칠 수 있습니다.</p>

<p>Lua 스크립트를 작성하고, 스크립트를 등록하고 Caching하여 실행하거나, EVAL 명령어로 script를 직접 실행하는 방법들이 있습니다.</p>
<h2 id="lua-script-등록-방법">Lua Script 등록 방법</h2>

<ul>
  <li>CLI로 등록
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>script.lua | redis-cli <span class="nt">-x</span> script load
</code></pre></div>    </div>
  </li>
  <li>script load  명령어
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; script load <span class="s2">"redis.call('SET', KEYS[1], ARGV[1])"</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="lua-script-실행방법">Lua Script 실행방법</h2>
<h4 id="redis-cli">redis-cli</h4>

<p>Sample 데이터</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; hmset hkeys key:1 value:1 key:2 value:2 key:3 value:3 key:4 value:4 key:5 value:5 key:6 value:6
127.0.0.1:6379&gt; zadd order 1 key:3 2 key:1 3 key:2
</code></pre></div></div>

<p>redis-cli -p 6383 eval “$(cat scriptfile)” keynum keys argv</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">--</span> example01.lua
redis.call<span class="o">(</span><span class="s1">'SET'</span>, KEYS[1], ARGV[1]<span class="o">)</span>
</code></pre></div></div>
<p>예시 1</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nb">eval</span> <span class="s2">"</span><span class="si">$(</span>example01.lua<span class="si">)</span><span class="s2">"</span> 1 key1 value
</code></pre></div></div>

<p>예시 2</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">--</span> example02.lua
<span class="nb">local </span>order <span class="o">=</span> redis.call<span class="o">(</span><span class="s1">'zrange'</span>, KEYS[1], 0, <span class="nt">-1</span><span class="o">)</span><span class="p">;</span> <span class="k">return </span>redis.call<span class="o">(</span><span class="s1">'hmget'</span>,KEYS[2], unpack<span class="o">(</span>order<span class="o">))</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SHA</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat </span>example02.lua |redis-cli <span class="nt">-p</span> 6383 <span class="nt">-x</span> script load<span class="si">)</span>
redis-cli <span class="nt">-p</span> 6383 evalsha <span class="s2">"</span><span class="nv">$SHA</span><span class="s2">"</span> 2 order hkeys
</code></pre></div></div>

<h4 id="redis-서버">redis 서버</h4>
<p>기본 Redis 스크립트는 EVAL 명령을 사용하여 실행할 수 있습니다. 명령은 Redis에서 직접 스크립트를 실행합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; EVAL <span class="s2">"return 'Hello, world!'"</span>
127.0.0.1:6379&gt; EVAL <span class="s2">"redis.call('SET', KEYS[1], ARGV[1])"</span> 1 key1 <span class="s2">"Example Value"</span>

127.0.0.1:6379&gt; hmset hkeys key:1 value:1 key:2 value:2 key:3 value:3 key:4 value:4 key:5 value:5 key:6 value:6
127.0.0.1:6379&gt; zadd order 1 key:3 2 key:1 3 key:2
127.0.0.1:6379&gt; <span class="nb">eval</span> <span class="s2">"local order = redis.call(‘zrange’, KEYS[1], 0, -1); return redis.call(‘hmget’,KEYS[2],unpack(order));"</span> 2 order hkeys
</code></pre></div></div>

<p>EVALSHA <your_script_sha> 1 key argv</your_script_sha></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; script load <span class="s2">"redis.call('SET', KEYS[1], ARGV[1])"</span> 
fcd2612e1ca113b83fdfbc2a88493d3b231a32ad

127.0.0.1:6379&gt; EVALSHA fcd2612e1ca113b83fdfbc2a88493d3b231a32ad 1 key1 test1
127.0.0.1:6379&gt; get key1
</code></pre></div></div>

<h2 id="참조">참조</h2>
<p><a href="https://hsg2510.tistory.com/category/Lua%20Script">Hong’s Programing World</a><br />
<a href="https://www.lua.org/manual/5.4/">Lua manual</a><br />
<a href="https://www.freecodecamp.org/news/a-quick-guide-to-redis-lua-scripting/">freeCodeCamp</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="lua" /><summary type="html"><![CDATA[스크립팅을 사용하면 Redis 내에서 복잡한 작업을 실행할 수 있습니다. Redis 스크립트를 사용하면 제어 구조와 같은 프로그래밍 도구를 사용할 수 있으며 거의 ​​모든 Redis 명령에 액세스 할 수 있습니다.]]></summary></entry><entry><title type="html">Springboot기반 Redis @Transactional 어노테이션 사용</title><link href="http://localhost:4000/springboot/springboot-redis-transactional/" rel="alternate" type="text/html" title="Springboot기반 Redis @Transactional 어노테이션 사용" /><published>2023-04-18T00:00:00+09:00</published><updated>2023-04-18T00:00:00+09:00</updated><id>http://localhost:4000/springboot/springboot-redis-transactional</id><content type="html" xml:base="http://localhost:4000/springboot/springboot-redis-transactional/"><![CDATA[<h2 id="transactional">@Transactional</h2>
<p>Springboot 기반 Redis를 사용할 때 @Tranactional 사용하여 commit 과 rollback 을 처리할 수 있습니다.
rollback 은 exception을 throw하면 redis cache에 데이터가 저장되지 않습니다.<br />
PlatformTransactionManager를 Bean으로 등록되어 있고, 메소드에 @tranactional 어노테이션이 있고,메소드 로직에 @redisTemplate을 사용하고 있다면 이는 트랜잭션으로 처리되어, 예외(Exception)가 발생하면 데이터베이스에 처리했던 작업이 rollback 되고, 또한 로직에서 Redis에 저장했던 데이터 또한 저장되지 않고 rollback 됩니다.</p>

<p><strong>@Transactional</strong> 어노테이션이 있을때, Redis는 메서드 시작시 transaction 시작으로 <strong>MULTI</strong>, 메서드 종료시 transaction 커밋으로 <strong>EXEC</strong> 명령어를 실행하는 것으로 구현하고 있습니다. 만약 Exception이 발생하면 <strong>DISCARD</strong> 가 실행됩니다.</p>

<h2 id="redis-환경설정">Redis 환경설정</h2>
<p>Redis를 @Transaction 어노테이션과 함께 사용하고 싶을 때는 3가지 방법이 있습니다.</p>
<ul>
  <li>자바의 database configuration에 PlatformTransactionManager를 Bean으로 등록 사용</li>
  <li>자바의 Redis Configuration에 PlatformTransactionManager를 Bean으로 등록</li>
  <li>RedisTemplate 단독으로 사용하고 있다면 @EnableTransactionManagement 어노테이션 추가</li>
</ul>

<h4 id="java-database-configuration-사용---예시">java database configuration 사용 - 예시</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@PropertySource</span><span class="o">(</span><span class="s">"classpath:/application.properties"</span><span class="o">)</span>
<span class="nd">@EnableTransactionManagement</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DatabaseConfiguration</span> <span class="o">{</span>
<span class="o">...</span>
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="nc">PlatformTransactionManager</span> <span class="nf">transactionManager</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">DataSourceTransactionManager</span><span class="o">(</span><span class="n">dataSource</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="redis-configuration-사용---예제">Redis Configuration 사용 - 예제</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="o">{</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">RedisTemplate</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">redisTemplate</span><span class="o">(</span><span class="nc">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[],</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">redisTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisTemplate</span><span class="o">&lt;&gt;();</span>
    <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setConnectionFactory</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">);</span>
    <span class="n">redisTemplate</span><span class="o">.</span><span class="na">setEnableTransactionSupport</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// redis Transaction On !</span>
    <span class="k">return</span> <span class="n">redisTemplate</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span> <span class="c1">// 만약 PlatformTransactionManager 등록이 안되어 있다면 해야함, 되어있다면 할 필요 없음</span>
  <span class="kd">public</span> <span class="nc">PlatformTransactionManager</span> <span class="nf">transactionManager</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
      <span class="c1">// 사용하고 있는 datasource 관련 내용, 아래는 JDBC</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">DataSourceTransactionManager</span><span class="o">(</span><span class="n">datasource</span><span class="o">());</span> 

    <span class="c1">// JPA 사용하고 있다면 아래처럼 사용하고 있음</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">JpaTransactionManager</span><span class="o">(</span><span class="n">entityManagerFactory</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="redistemplate-단독으로-사용---예제">RedisTemplate 단독으로 사용 - 예제</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableTransactionManagement</span>                                 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisTxContextConfiguration</span> <span class="o">{</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">StringRedisTemplate</span> <span class="nf">redisTemplate</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">StringRedisTemplate</span> <span class="n">template</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringRedisTemplate</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">());</span>
    <span class="c1">// explicitly enable transaction support</span>
    <span class="n">template</span><span class="o">.</span><span class="na">setEnableTransactionSupport</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>              
    <span class="k">return</span> <span class="n">template</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">PlatformTransactionManager</span> <span class="nf">transactionManager</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">DataSourceTransactionManager</span><span class="o">();</span>   
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="참조">참조</h2>
<p><a href="https://sabarada.tistory.com/178">사바라다는 차곡차곡</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="springboot" /><summary type="html"><![CDATA[@Transactional Springboot 기반 Redis를 사용할 때 @Tranactional 사용하여 commit 과 rollback 을 처리할 수 있습니다. rollback 은 exception을 throw하면 redis cache에 데이터가 저장되지 않습니다. PlatformTransactionManager를 Bean으로 등록되어 있고, 메소드에 @tranactional 어노테이션이 있고,메소드 로직에 @redisTemplate을 사용하고 있다면 이는 트랜잭션으로 처리되어, 예외(Exception)가 발생하면 데이터베이스에 처리했던 작업이 rollback 되고, 또한 로직에서 Redis에 저장했던 데이터 또한 저장되지 않고 rollback 됩니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Redis with Lua</title><link href="http://localhost:4000/cache/redis-with-lua/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis with Lua" /><published>2023-04-18T00:00:00+09:00</published><updated>2023-04-18T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-with-lua</id><content type="html" xml:base="http://localhost:4000/cache/redis-with-lua/"><![CDATA[<h2 id="lua">lua</h2>
<p>Lua는 달을 뜻하는 포르투갈어이며 1993년 브라질에서 처음 개발되었으며, light-weight하며 이식성이 좋은 스크립트 언어입니다.</p>

<p><strong>Lua 스크립트는 다음과 같은 특징</strong> 이 있습니다.</p>
<ul>
  <li>대소 문자를 구분</li>
  <li>다른 스크립트 언어처럼 변수 형을 선언하지 않음</li>
  <li>변수 명의 첫글자는 영문 또는 _(언더스코어)로 시작</li>
  <li>예약어는 다음과 같습니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>and / <span class="nb">break</span> / <span class="k">do</span> / <span class="k">else</span> / elseif / end / <span class="nb">false</span> / <span class="k">for</span> /function / <span class="k">if</span> / <span class="k">in</span> / <span class="nb">local</span> / nil / not / or / repeat / <span class="k">then</span> / <span class="nb">true</span> /until / <span class="k">while</span> 
</code></pre></div>    </div>
  </li>
  <li>local 키워드를 사용하여 전역변수와 지역변수를 구분하고, 지역변수 사용을 권고</li>
  <li>배열의 인덱스는 1부터 시작</li>
</ul>

<p><strong>Lua 스크립트는 다음과 같은 장점</strong> 을 가집니다.</p>

<ul>
  <li>Pipelining처럼, 여러 명령을 한 번의 request/response만으로 수행할 수 있습니다.</li>
  <li>원하는 함수를 redis에서 지원하고 있지 않더라도 lua 스크립트로 대체 가능합니다.(반환되는 값 count, 반환되는 value 모두 더하기 등)</li>
  <li>스크립트를 재활용할 수도 있습니다</li>
  <li>그래픽 시뮬레이션을 위한 스크립트언어로 개발되었기 때문에 타 스크립트언어보다 빠른 성능을 제공합니다.</li>
  <li>자바처럼 가비지 컬렉션을 제공하기 때문에 사용하지 않는 변수를 제거하기 위해 별도의 처리가 필요없습니다. 가비스 컬렉션 대상으로 만들려면 변수에 nil을 할당하면 됩니다.</li>
</ul>

<h4 id="redis-and-lua">Redis and Lua</h4>
<ul>
  <li>Redis에서는 2.6부터 Lua 5.1 버전을 지원하기 시작</li>
  <li>eval 명령어로 Redis에 전송하여 실행</li>
  <li>Lua 스크립트를 script load 명령을 이용하여 Redis 서버에 등록하여 Cache하여 사용가능</li>
  <li>Redis 에서 Lua 스크립트를 실행할 때 파라메터를 입력받을 수 있다.</li>
  <li>Lua 스크립트에서 Redis 명령을 사용가능</li>
  <li>Redis에서 실행되는 Lua 스크립트는 Atomic으로 처리된다. 즉 스크립트가 실행되는 동안 다른 Redis 명령이 실행되지 못한다.</li>
  <li>lua-time-limit : Lua 스크립트가 수행될 때 최대 시간을 밀리초 단위로 설정한다. 해당 시간이 지나면 SCRIPT KILL 명령을 이용해서 Lua 스크립트를 중지 할 수 있게 된다. 기본값은  50000(0.0005 초)
    <ul>
      <li>0 이나 음수를 입력하면 스크립트 제한 시간이 없음.</li>
      <li>Lua 스크립트가 수행되고 lua-time-limit 설정값이 되기 전에 SCRIPT KILL 명령을 수행해도 중지되지 않음.</li>
      <li>무한 loop Lua 스크립트가 수행되고 있을 때 다른 세션에서는 다음과 같은 메시지가 출력됨 <br />
<strong>BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE</strong></li>
    </ul>
  </li>
</ul>

<h2 id="lua-script-사용-명령어">Lua Script 사용 명령어</h2>
<p>Redis에서 lua script를 실행하기 위해 <a href="https://redis.io/commands/eval/">eval</a> 명령어는 다음과 같습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s2">"script"</span> 키개수 <span class="o">[</span>KEY1,KEY2,...] <span class="o">[</span>ARGV1,ARGV2,...]

<span class="c"># 예시</span>
<span class="nb">eval</span> “redis.call<span class="o">(</span>‘set’, KEYS[1], ARGV[1]<span class="o">)</span>” 1 key:name value
</code></pre></div></div>
<p><strong>eval</strong> : lua script를 실행하기 위한 예약어. Required.<br />
<strong>script</strong> : Redis에서 실행하기 위한 lua script 입니다. Required<br />
<strong>키개수</strong> : 파라메터로 입력 받을 키(KEYS)의 개수 입니다. 이는 뒤에 추가적으로 붙을 선택 인자들 중 몇 개가 key인지를 lua가 알 수 있도록 하기 위함입니다. 키가 없는 경우 키의 개수는 0으로 입력합니다. Required<br />
<strong>KEYS</strong> : 키개수 다음으로 오는 파라메터로 키개수 만큼 파라메터를 입력합니다. 그러면 lua는 KEYS 배열에 바인딩됩니다</p>

<ul>
  <li>0 이면  KEYS 파라메터가 없는 script입니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s1">'return "Hello World"'</span> 0
</code></pre></div>    </div>
  </li>
  <li>1 이면  =&gt; 1 KEY1</li>
  <li>2 이면  =&gt; 2 KEY1 KEY2</li>
  <li>3 이면  =&gt; 3 KEY1 KEY2 KEY3
LUA에서 ARGV 테이블로 사용할 수있는 키 다음에 여러개의 인수를 제공 할 수 있습니다.
Lua Script에서는 index가 1부터 시작하며, ARGV table은 KEYS[1], KEYS[2], KEYS[3] 이렇게 참조합니다.<br />
의
<strong>ARGV</strong> : ARGV는 lua에서 가변적으로 입력받을 수 있는 파라메터입니다. 인자 [ARGV …]는 각각 lua에서 사용할 수 있도록 ARGV 배열에 바인팅 됩니다.<br />
ARGV table도 lua에서는 1부터 시작하며, ARGV table은 ARGV[1], ARGV[2], ARGV[3] 이렇게 참조합니다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s2">"return { KEYS[1], KEYS[2], KEYS[3], ARGV[1], ARGV[2]}"</span> 3 k1 k2 k3 arg1 arg2

<span class="c"># 결과</span>
1<span class="o">)</span> <span class="s2">"k1"</span> 
2<span class="o">)</span> <span class="s2">"k2"</span>
3<span class="o">)</span> <span class="s2">"k3"</span>
4<span class="o">)</span> <span class="s2">"arg1"</span>
5<span class="o">)</span> <span class="s2">"arg2"</span>
</code></pre></div></div>
<h2 id="eval">eval</h2>
<p>Redis에서 Lua를 사용하여 eval로 Hello World를 출력할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s1">'return "Hello World"'</span> 0
</code></pre></div></div>

<p>예제 2</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s1">'return string.format("Hi %s", KEYS[1])'</span> 1 jaeguk
</code></pre></div></div>

<p>예제 3</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s1">'return string.format("key1 is %s, key2 is %s", KEYS[1],KEYS[2])'</span> 2 age score
</code></pre></div></div>
<h2 id="lua-script-load">lua script load</h2>
<p>아래와 같은 lua script를 redis-cli로 load시 반환값으로 출력되는 sha값으로 lua를 실행할 수 도 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">local </span>current <span class="o">=</span> redis.call<span class="o">(</span><span class="s1">'zrangebyscore'</span>, KEYS[1], ARGV[1], ARGV[2], <span class="s1">'LIMIT'</span>, ARGV[3], ARGV[4]<span class="o">)</span>
<span class="k">if</span> <span class="o">(</span>current <span class="o">==</span> nil or current <span class="o">==</span> <span class="s1">''</span><span class="o">)</span> <span class="k">then
    return</span> <span class="s2">"failed"</span>
<span class="k">else
    for </span>i, mem <span class="k">in </span>pairs<span class="o">(</span>current<span class="o">)</span> <span class="k">do
        </span>redis.call<span class="o">(</span><span class="s1">'zincrby'</span>, KEYS[1], 1, mem<span class="o">)</span>
        <span class="k">return </span>current
    end
end
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>ex01.lua | redis-cli <span class="nt">-x</span> script load

<span class="c"># 출력결과</span>
<span class="s2">"d57be6feffc53b0a7096b8a5d1c802c04ebc139e"</span>

</code></pre></div></div>
<p>redis-cli를 redis에 접속하여 다음과 같이 실행할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; zadd <span class="nb">users</span>:point 0 jason
127.0.0.1:6379&gt; zadd <span class="nb">users</span>:point 10 mason 20 jane

127.0.0.1:6379&gt; evalsha d57be6feffc53b0a7096b8a5d1c802c04ebc139e 1 <span class="nb">users</span>:point <span class="nt">-inf</span> inf 0
</code></pre></div></div>

<h2 id="redis-명령어-호출방법">redis 명령어 호출방법</h2>
<p>아래 두 개의 lua 함수를 사용하여, lua script에서 redis 명령을 호출할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis.call<span class="o">()</span>
redis.pcall<span class="o">()</span>
</code></pre></div></div>

<h2 id="lua-예제">Lua 예제</h2>
<p>Key 등록</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; sadd kstar:info:age 25
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; sadd kstar:info:joinday <span class="s2">"2022.11.17"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; sadd kstar:info:siteid job academy campstudy
<span class="o">(</span>integer<span class="o">)</span> 3
127.0.0.1:6379&gt; sadd kstar:info:lastloginday <span class="s2">"2023.01.02"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; sadd kstar:info:sex M
<span class="o">(</span>integer<span class="o">)</span> 1
sadd kstar:info:totallogincount 54
</code></pre></div></div>
<p>Key 목록 조회하기</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; <span class="nb">eval</span> <span class="s1">'local members = redis.call("keys", "kstar:info:*") local results = {} for index,key in ipairs(members) do results[index] = key end return results'</span>  0
1<span class="o">)</span> <span class="s2">"kstar:info:lastloginday"</span>
2<span class="o">)</span> <span class="s2">"kstar:info:sex"</span>
3<span class="o">)</span> <span class="s2">"kstar:info:totallogincount"</span>
4<span class="o">)</span> <span class="s2">"kstar:info:age"</span>
5<span class="o">)</span> <span class="s2">"kstar:info:siteid"</span>
6<span class="o">)</span> <span class="s2">"kstar:info:joinday"</span>
</code></pre></div></div>

<p>Key 값에 대한 Value 를 조회</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s1">'local members = redis.call("keys", "kstar:info:*") local results = {} for index,key in ipairs(members) do results[index] = redis.call("smembers", key) end return results '</span> 0
1<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"2023.01.02"</span>
2<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"M"</span>
3<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"54"</span>
4<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"25"</span>
5<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"job"</span>
   2<span class="o">)</span> <span class="s2">"campstudy"</span>
   3<span class="o">)</span> <span class="s2">"academy"</span>
6<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"2022.11.17"</span>
</code></pre></div></div>
<p>Key 값에 대한 Value 를 조회하여 key =&gt; value 형으로 출력</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s2">"local members = redis.call('keys', 'kstar:info:*') local results = {} for index, key in ipairs(members) do results[index] = key ..'=&gt;'.. unpack(redis.call('smembers', key)) end return results "</span> 0
1<span class="o">)</span> <span class="s2">"kstar:info:lastloginday=&gt;2023.01.02"</span>
2<span class="o">)</span> <span class="s2">"kstar:info:sex=&gt;M"</span>
3<span class="o">)</span> <span class="s2">"kstar:info:totallogincount=&gt;54"</span>
4<span class="o">)</span> <span class="s2">"kstar:info:age=&gt;25"</span>
5<span class="o">)</span> <span class="s2">"kstar:info:siteid=&gt;job"</span>
6<span class="o">)</span> <span class="s2">"kstar:info:joinday=&gt;2022.11.17"</span>
</code></pre></div></div>
<h2 id="참고">참고</h2>
<p><a href="https://code-factory.tistory.com/13">코드공장</a><br />
<a href="https://luran.me/381">everydayminder</a><br />
<a href="http://www.w3big.com/ko/redis/sorted-sets-zrangebyscore.html#gsc.tab=0">Redis 코스</a><br />
<a href="https://planbs.tistory.com/entry/Redis-Eval">PlanB의 백엔드 엔지니어링</a><br />
<a href="https://bstar36.tistory.com/category/%EA%B8%B0%ED%83%80%20DBMS/Redis?page=5">멋지게 놀아라라</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="lua" /><summary type="html"><![CDATA[lua Lua는 달을 뜻하는 포르투갈어이며 1993년 브라질에서 처음 개발되었으며, light-weight하며 이식성이 좋은 스크립트 언어입니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - RediSearch</title><link href="http://localhost:4000/cache/installl-redisearch-on-docker/" rel="alternate" type="text/html" title="Redis 시작하기 - RediSearch" /><published>2023-04-17T00:00:00+09:00</published><updated>2023-04-17T00:00:00+09:00</updated><id>http://localhost:4000/cache/installl-redisearch-on-docker</id><content type="html" xml:base="http://localhost:4000/cache/installl-redisearch-on-docker/"><![CDATA[<h2 id="redisearch-소개">RediSearch 소개</h2>
<p>Redis는 다음과 같이 key/value 형식으로 조회가 가능합니다.</p>
<ul>
  <li>set user1 value1 GET user1</li>
  <li>HSET user1 name jaeguk HGETALL user1 name</li>
</ul>

<p>그러나 아래와 같이 SQL의 WHERE 절의 Parameters 처럼 조회는 지원하지 않습니다.</p>
<ul>
  <li>GET users WHERE name=”jaeguk”</li>
  <li>GET users WHERE name like “jae%”</li>
</ul>

<p>위한 같이 <strong>SQL과 유사한 기능</strong>  사용할 슈 있게 지원하는 것이 RediSearch 솔루션입니다.<br />
RediSearch 는 다믐의 기능을 지원합니다.</p>
<ul>
  <li>Secondary index over</li>
  <li>Full-text engine</li>
  <li>Incremental indexing</li>
  <li>Multi-field queries</li>
  <li>AND OR NOT complex Boolean queries</li>
  <li>Numeric filters and ranges</li>
  <li>Data Aggregation</li>
  <li>Auto-complete suggestions</li>
  <li>Geo Indexing and filtering</li>
</ul>

<h2 id="redisearch-실습환경-구성">RediSearch 실습환경 구성</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="nt">--name</span> redis-stack-server <span class="nt">-p</span> 6379:6379 redis/redis-stack-server
</code></pre></div></div>

<h2 id="인덱스-생성">인덱스 생성</h2>
<p>FT.CREATE 명령을 사용하여 필드와 인덱스를 생성합니다(기본 가중치는 1.0).</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; FT.CREATE myIdx ON HASH PREFIX 1 doc: SCHEMA title TEXT WEIGHT 5.0 body TEXT url TEXT
OK
</code></pre></div></div>

<p>doc:xx 접두사가 있는 키가 있는 기존 해시 문서는 이때 자동으로 인덱스에 추가됩니다.</p>

<h2 id="documents-추가">documents 추가</h2>

<p>색인을 만든 후 doc: 접두사가 있는 새 해시 문서는 생성 시 자동으로 색인이 생성됩니다.</p>

<p>HSET 명령을 사용하여 새 해시 문서를 만들고 인덱스에 추가합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; HSET doc:1 title <span class="s2">"hello world"</span> body <span class="s2">"lorem ipsum"</span> url <span class="s2">"http://redis.io"</span>
<span class="o">(</span>integer<span class="o">)</span> 3
</code></pre></div></div>

<h2 id="색인index-검색">색인(index) 검색</h2>
<p>특정 단어가 포함된 문서의 색인을 검색하려면 FT.SEARCH 명령을 사용하십시오.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; FT.SEARCH myIdx <span class="s2">"hello world"</span> LIMIT 0 10
1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 1
2<span class="o">)</span> <span class="s2">"doc:1"</span>
3<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"title"</span>
   2<span class="o">)</span> <span class="s2">"hello world"</span>
   3<span class="o">)</span> <span class="s2">"body"</span>
   4<span class="o">)</span> <span class="s2">"lorem ipsum"</span>
   5<span class="o">)</span> <span class="s2">"url"</span>
   6<span class="o">)</span> <span class="s2">"http://redis.io"</span>
</code></pre></div></div>

<h2 id="색인index-삭제">색인(index) 삭제</h2>
<p>연관된 해시 문서를 삭제하지 않고 색인을 제거하려면 DD 옵션 없이 FT.DROPINDEX를 실행하십시오.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; FT.DROPINDEX myIdx
OK
</code></pre></div></div>

<p>인덱스 및 모든 인덱스 해시 문서를 삭제하려면 명령에 DD 옵션을 추가합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; FT.SUGGET autocomplete <span class="s2">"he"</span>
1<span class="o">)</span> <span class="s2">"hello world"</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="redisearch" /><summary type="html"><![CDATA[RediSearch 소개 Redis는 다음과 같이 key/value 형식으로 조회가 가능합니다. set user1 value1 GET user1 HSET user1 name jaeguk HGETALL user1 name]]></summary></entry><entry><title type="html">Redis 시작하기 - Use Cases</title><link href="http://localhost:4000/cache/usecase/" rel="alternate" type="text/html" title="Redis 시작하기 - Use Cases" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/cache/usecase</id><content type="html" xml:base="http://localhost:4000/cache/usecase/"><![CDATA[<h2 id="redis-use-cases">Redis Use Cases</h2>

<p><img src="/assets/images/cache/25-cache-usecase.png" alt="m1s1-r1s2-r3s3" /></p>

<h2 id="top-redis-use-cases">Top Redis Use Cases</h2>
<p><img src="/assets/images/cache/26-cache-top-usecase.png" alt="m1s1-r1s2-r3s3" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="redis-stat" /><summary type="html"><![CDATA[Redis Use Cases]]></summary></entry><entry><title type="html">Redis 시작하기 - Redis 복제</title><link href="http://localhost:4000/cache/replication/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis 복제" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/cache/replication</id><content type="html" xml:base="http://localhost:4000/cache/replication/"><![CDATA[<h2 id="redis-replication">Redis replication</h2>
<p>Redis가 복제를 통해 고가용성 및 장애 조치를 지원하는 방법<br />
Redis 복제의 기반(Redis Cluster 또는 Redis Sentinel에서 추가 계층으로 제공하는 고가용성 기능 제외)에는  사용 및 구성이 간편한 리더 팔로워(마스터-복제본) 복제가 있습니다. 이를 통해 복제본 Redis 인스턴스는 마스터 인스턴스의 정확한 복사본이 될 수 있습니다. 복제본은 링크가 끊어질 때마다 자동으로 마스터에 다시 연결되며 마스터에  어떤 일이 발생하든 관계없이 복제본의 정확한 복사본이 되려고 시도합니다.</p>

<p>이 시스템은 세 가지 주요 메커니즘을 사용하여 작동합니다:</p>
<ol>
  <li>마스터와 복제본 인스턴스가 잘 연결되어 있는 경우 마스터는 클라이언트 쓰기, 키 만료 또는 제거, 마스터 데이터 세트를 변경하는 기타 작업으로 인해 마스터 측에서 발생하는 데이터 세트에 미치는 영향을 복제하기 위해 복제본에 명령 스트림을 전송하여 복제본을 업데이트된 상태로 유지합니다.</li>
  <li>마스터와 복제본 간의 연결이 끊어지거나, 네트워크 문제가 있거나, 마스터 또는 복제본에서 시간 초과가 감지되어 복제본이 다시 연결되고 부분 다시 동기화를 진행하려고 시도하며, 이는 연결이 끊기는 동안 누락된 명령 스트림의 일부만 가져오려고 시도한다는 의미입니다.</li>
  <li>부분 다시 동기화가 불가능한 경우 복제본은 전체 다시 동기화를 요청합니다. 여기에는 마스터가 모든 데이터의 스냅샷을 만들어 복제본으로 보낸 다음 데이터 세트가 변경됨에 따라 명령 스트림을 계속 보내야 하는 더 복잡한 프로세스가 포함됩니다.</li>
</ol>

<p>Redis는 기본적으로 대기 시간이 짧고 성능이 뛰어난 비동기식 복제를 사용하며, 대부분의 Redis 사용 사례에서 자연스러운 복제 모드입니다. 그러나 Redis 복제본은 마스터와 주기적으로 수신한 데이터의 양을 비동기식으로 인식합니다. 따라서 마스터는 복제본에서 명령을 처리할 때마다 기다리지 않지만 필요한 경우 어떤 복제본이 어떤 명령을 이미 처리했는지 알 수 있습니다. 이렇게 하면 선택적 동기 복제를 사용할 수 있습니다.
특정 데이터의 동기 복제는 WAIT 명령을 사용하여 클라이언트에서 요청할 수 있습니다  .</p>

<p>그러나  WAIT는 다른 Redis 인스턴스에 지정된 수의 승인된 복사본이 있는지 확인할 수만 있으며, Redis 인스턴스 집합을 강력한 일관성을 가진 CP 시스템으로 전환하지 않습니다. 그러나 WAIT를 사용하면 실패  이벤트 후 쓰기가 손실될 확률이 트리거하기 어려운 특정 실패 모드로 크게 줄어듭니다.</p>

<p>고가용성 및 장애 조치에 대한 자세한 내용은 Redis Sentinel 또는 Redis 클러스터 설명서를 확인할 수 있습니다. 이 문서의 나머지 부분에서는 주로 Redis 기본 복제의 기본 특성에 대해 설명합니다.</p>

<p>Important facts about Redis replication</p>
<ul>
  <li>Redis는 비동기식 복제를 사용하며, 비동기식 복제본-마스터는 처리된 데이터의 양을 승인합니다.</li>
  <li>마스터에는 여러 복제본이 있을 수 있습니다.</li>
  <li>복제본은 다른 복제본의 연결을 수락할 수 있습니다. 여러 복제본을 동일한 마스터에 연결하는 것 외에도 계단식 구조의 다른 복제본에 연결할 수도 있습니다. Redis 4.0부터 모든 하위 복제본은 마스터에서 정확히 동일한 복제 스트림을 받습니다.</li>
  <li>Redis 복제는 마스터 측에서 비차단됩니다. 즉, 마스터는 하나 이상의 복제본이 초기 동기화 또는 부분 다시 동기화를 수행할 때 쿼리를 계속 처리합니다.</li>
  <li>또한 복제는 복제본 쪽에서 대부분 비차단입니다. 복제본이 초기 동기화를 수행하는 동안 redis.conf에서 Redis를 구성했다고 가정하고 이전 버전의 데이터 세트를 사용하여 쿼리를 처리할 수 있습니다. 그렇지 않으면 복제 스트림이 다운된 경우 클라이언트에 오류를 반환하도록 Redis 복제본을 구성할 수 있습니다. 그러나 초기 동기화 후에는 이전 데이터 세트를 삭제하고 새 데이터 세트를 로드해야 합니다. 복제본은 이 짧은 기간 동안 들어오는 연결을 차단합니다(매우 큰 데이터 세트의 경우 몇 초까지 걸릴 수 있음). Redis 4.0부터 이전 데이터 세트의 삭제가 다른 스레드에서 발생하도록 Redis를 구성할 수 있지만 새 초기 데이터 세트 로드는 여전히 기본 스레드에서 발생하고 복제본을 차단합니다.</li>
  <li>복제는 확장성을 위해 사용할 수 있으며, 읽기 전용 쿼리를 위한 여러 복제본을 보유하거나(예: 느린 O(N) 작업을 복제본으로 오프로드할 수 있음) 단순히 데이터 안전 및 고가용성을 향상시키는 데 사용할 수 있습니다.</li>
  <li>복제를 사용하여 마스터가 전체 데이터 세트를 디스크에 쓰는 비용을 피할 수 있습니다: 일반적인 기술은 디스크에 전혀 지속되지 않도록 마스터 redis.conf를 구성한  다음, 수시로 저장하도록 구성된 복제본을 연결하거나 AOF를 활성화하여 연결하는 것입니다. 그러나 마스터를 다시 시작하면 빈 데이터 세트로 시작하므로 이 설정은 주의해서 처리해야 합니다: 복제본이 동기화하려고 하면 복제본도 비워집니다.</li>
</ul>

<h2 id="마스터가-지속성을-해제한-경우-복제의-안전성">마스터가 지속성을 해제한 경우 복제의 안전성</h2>
<p>Redis 복제가 사용되는 설정에서는 마스터 및 복제본에서 지속성을 설정하는 것이 좋습니다. 예를 들어 매우 느린 디스크로 인한 지연 시간 문제로 인해 이것이 가능하지 않은 경우  재부팅 후 자동으로 다시 시작되지 않도록 인스턴스를 구성해야 합니다.
자동 다시 시작으로 구성된 지속성이 해제된 마스터가 위험한 이유를 더 잘 이해하려면 마스터 및 모든 복제본에서 데이터가 지워지는 다음 오류 모드를 확인합니다:</p>
<ol>
  <li>노드 A가 마스터 역할을 하고 지속성이 꺼지고 노드 B와 C가 노드 A에서 복제되는 설정이 있습니다.</li>
  <li>노드 A는 충돌하지만 프로세스를 다시 시작하는 자동 재시작 시스템이 있습니다. 그러나 지속성이 꺼져 있으므로 노드는 비어 있는 데이터 세트로 다시 시작됩니다.</li>
  <li>노드 B와 C는 비어 있는 노드 A에서 복제되므로 데이터 복사본을 효과적으로 삭제합니다.<br />
고가용성을 위해 Redis Sentinel을 사용하는 경우 프로세스의 자동 재시작과 함께 마스터의 지속성을 해제하는 것도 위험합니다. 예를 들어 마스터는 Sentinel이 장애를 감지하지 못할 만큼 빠르게 다시 시작하여 위에서 설명한 장애 모드가 발생하도록 할 수 있습니다.</li>
</ol>

<p>데이터 안전이 중요하고 지속성 없이 구성된 마스터와 함께 복제를 사용할 때마다 인스턴스의 자동 재시작을 비활성화해야 합니다.</p>

<h2 id="how-redis-replication-works">How Redis replication works</h2>
<p>모든 Redis 마스터에는 복제 ID가 있으며, 이는 데이터 세트의 지정된 스토리를 표시하는 큰 난수 문자열입니다. 또한 각 마스터는 복제본으로 전송하기 위해 생성되는 복제 스트림의 모든 바이트에 대해 증가하는 오프셋을 사용하여 데이터 세트를 수정하는 새로운 변경 사항으로 복제본의 상태를 업데이트합니다. 복제 오프셋은 실제로 연결된 복제본이 없더라도 증가하므로 기본적으로 모든 주어진 쌍:</p>
<h4 id="replication-id-offset">Replication ID, offset</h4>
<p>마스터 데이터 세트의 정확한 버전을 식별합니다.<br />
복제본이 마스터에 연결되면 PSYNC 명령을 사용하여 이전 마스터 복제 ID와 지금까지 처리한 오프셋을 보냅니다. 이렇게 하면 마스터가 필요한 증분 부분만 보낼 수 있습니다. 그러나  마스터 버퍼에 백로그가 충분하지 않거나 복제본이  더 이상 알 수 없는 기록(복제 ID)을 참조하는 경우 전체 재동기화가 발생합니다.이 경우 복제본은 처음부터 데이터 세트의 전체 복사본을 가져옵니다.<br />
전체 동기화가 작동하는 방식입니다.:<br />
마스터는 백그라운드 저장 프로세스를 시작하여 RDB 파일을 생성합니다. 동시에 클라이언트로부터 받은 모든 새 쓰기 명령을 버퍼링하기 시작합니다. 백그라운드 저장이 완료되면 마스터는 데이터베이스 파일을 복제본으로 전송하여 디스크에 저장한 다음 메모리에 로드합니다. 그런 다음 마스터는 버퍼링된 모든 명령을 복제본으로 보냅니다. 이 작업은 명령 스트림으로 수행되며 Redis 프로토콜 자체와 동일한 형식입니다.<br />
텔넷을 통해 직접 시도해 볼 수 있습니다. 서버가 일부 작업을 수행하는 동안 Redis 포트에 연결하고 SYNC 명령을 실행합니다. 대량 전송이 표시되고 마스터가 수신한 모든 명령이 텔넷 세션에서 다시 실행됩니다. 실제로  SYNC는 최신 Redis 인스턴스에서 더 이상 사용되지 않는 이전 프로토콜이지만 이전 버전과의 호환성을 위해 여전히 존재합니다 : 부분 재 동기화를 허용하지 않으므로 이제 PSYNC가 대신 사용됩니다.<br />
이미 언급했듯이 복제본은 어떤 이유로 마스터-복제본 링크가 다운되면 자동으로 다시 연결할 수 있습니다. 마스터가 여러 개의 동시 복제본 동기화 요청을 수신하는 경우 단일 백그라운드 저장을 수행하여 모든 요청을 처리합니다.</p>

<h2 id="replication-id-explained">Replication ID explained</h2>
<p>이전 섹션에서는 두 인스턴스가 동일한 복제 ID와 복제 오프셋을 갖는 경우 정확히 동일한 데이터를 갖는다고 설명했습니다. 그러나 복제 ID가 정확히 무엇인지, 그리고 인스턴스에 실제로 두 개의 복제 ID(기본 ID와 보조 ID)가 있는 이유를 이해하는 것이 유용합니다.<br />
복제 ID는 기본적으로 데이터 세트의 지정된 기록을 표시합니다  . 인스턴스가 마스터로 처음부터 다시 시작되거나 복제본이 마스터로 승격될 때마다 이 인스턴스에 대한 새 복제 ID가 생성됩니다. 마스터에 연결된 복제본은 핸드셰이크 후 복제 ID를 상속합니다. 따라서 동일한 ID를 가진 두 인스턴스는 동일한 데이터를 보유하지만 잠재적으로 다른 시간에 있다는 사실과 관련이 있습니다. 지정된 기록(복제 ID)에 대해 가장 업데이트된 데이터 세트를 보유하는 사용자를 이해하는 논리적 시간으로 작동하는 오프셋입니다.<br />
예를 들어, 두 인스턴스 A와 B의 복제 ID가 동일하지만 오프셋이 1000인 인스턴스와 오프셋이 1023인 인스턴스 B의 경우 첫 번째 인스턴스에는 데이터 세트에 적용된 특정 명령이 없음을 의미합니다. 또한 A가 몇 가지 명령만 적용하면 정확히 동일한 B 상태에 도달할 수 있음을 의미합니다.<br />
Redis 인스턴스에 두 개의 복제 ID가 있는 이유는 마스터로 승격된 복제본 때문입니다. 장애 조치(failover) 후 승격된 복제본은 이전 복제 ID가 이전 마스터 중 하나였기 때문에 이전 복제 ID를 계속 기억해야 합니다. 이러한 방식으로 다른 복제본이 새 마스터와 동기화될 때 이전 마스터 복제 ID를 사용하여 부분 다시 동기화를 수행하려고 합니다. 복제본이 마스터로 승격될 때 보조 ID를 기본 ID로 설정하고 이 ID 전환이 발생했을 때 오프셋이 무엇인지 기억하기 때문에 예상대로 작동합니다. 나중에 새 기록이 시작되므로 새 임의 복제 ID를 선택합니다. 새 복제본 연결을 처리할 때 마스터는 해당 ID 및 오프셋을 현재 ID 및 보조 ID와 일치시킵니다(안전을 위해 지정된 오프셋까지). 즉, 장애 조치(failover) 후 새로 승격된 마스터에 연결하는 복제본은 전체 동기화를 수행할 필요가 없습니다.<br />
마스터로 승격된 복제본이 장애 조치 후 복제 ID를 변경해야 하는 이유가 궁금한 경우: 일부 네트워크 파티션으로 인해 이전 마스터가 여전히 마스터로 작동할 수 있습니다. 동일한 복제 ID를 유지하는 것은 두 임의 인스턴스의 동일한 ID와 동일한 오프셋이 동일한 데이터 세트를 갖는다는 것을 의미한다는 사실을 위반합니다.</p>

<h2 id="diskless-replication">Diskless replication</h2>
<p>일반적으로 전체 다시 동기화하려면 디스크에 RDB 파일을 만든 다음 디스크에서 동일한 RDB를 다시 로드하여 복제본에 데이터를 공급해야 합니다.
느린 디스크를 사용하면 마스터에게 매우 스트레스가 되는 작업이 될 수 있습니다. Redis 버전 2.8.18은 디스크 없는 복제를 지원하는 첫 번째 버전입니다. 이 설정에서 자식 프로세스는 디스크를 중간 스토리지로 사용하지 않고 유선으로 RDB를 복제본으로 직접 보냅니다.</p>

<h2 id="configuration">Configuration</h2>
<p>기본 Redis 복제를 구성하는 것은 간단합니다 : 복제본 구성 파일에 다음 줄을 추가하기 만하면됩니다:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>replicaof 192.168.1.1 6379
</code></pre></div></div>
<p>물론 192.168.1.1 6379를 마스터 IP 주소(또는 호스트 이름) 및 포트로 바꿔야 합니다. 또는 REPLICAOF 명령을 호출할 수  있으며 마스터 호스트는 복제본과의 동기화를 시작합니다.
또한 부분 재동기화를 수행하기 위해 마스터가 메모리에서 가져온 복제 백로그를 조정하기 위한 몇 가지 매개 변수가 있습니다.  자세한 내용은 Redis 배포와 함께 제공되는 redis.conf 예제를 참조하십시오.
디스크 없는 복제는 repl-diskless-sync 구성 매개변수를 사용하여 사용할 수 있습니다  . 첫 번째 복제본 이후에 더 많은 복제본이 도착할 때까지 기다리는 전송 시작 지연은 repl-diskless-sync-delay 매개 변수에 의해 제어됩니다  .  자세한 내용은 Redis 배포의 예제 redis.conf 파일을 참조하십시오.</p>

<h2 id="read-only-replica">Read-only replica</h2>
<p>Redis 2.6부터 복제본은 기본적으로 활성화되는 읽기 전용 모드를 지원합니다. 이 동작은 redis.conf 파일의 replica-read-only 옵션에 의해 제어되며 CONFIG SET를  사용하여 런타임에 활성화 및 비활성화할 수  있습니다.<br />
읽기 전용 복제본은 모든 쓰기 명령을 거부하므로 실수로 인해 복제본입니다. 그렇다고 해서 DEBUG 또는 CONFIG와 같은 관리 명령이 여전히 활성화되어 있기 때문에 이 기능이 복제본 인스턴스를 인터넷이나 더 일반적으로 신뢰할 수 없는 클라이언트가 있는 네트워크에 노출하기 위한 것은 아닙니다  . 보안 페이지에서는 Redis 인스턴스를 보호하는 방법을 설명합니다.</p>

<p>읽기 전용 설정을 되돌리고 쓰기 작업의 대상이 될 수 있는 복제본 인스턴스를 가질 수 있는 이유가 궁금할 수 있습니다. 대답은 쓰기 가능한 복제본이 역사적인 이유로만 존재한다는 것입니다. 쓰기 가능한 복제본을 사용하면 마스터와 복제본 간에 불일치가 발생할 수 있으므로 쓰기 가능한 복제본을 사용하지 않는 것이 좋습니다. 이것이 어떤 상황에서 문제가 될 수 있는지 이해하려면 복제가 작동하는 방식을 이해해야 합니다. 마스터의 변경 사항은 일반 Redis 명령을 복제본에 전파하여 복제됩니다. 마스터에서 키가 만료되면 DEL 명령으로 전파됩니다. 마스터에 있지만 삭제되거나 만료되었거나 복제본에서 마스터와 다른 유형을 가진 키가 마스터에서 전파된 DEL, INCR 또는 RPOP와 같은 명령에 의도한 것과 다르게 반응합니다. 전파된 명령이 복제본에서 실패하거나 다른 결과가 발생할 수 있습니다. 위험을 최소화하려면(쓰기 가능한 복제본을 계속 사용해야 하는 경우) 다음 권장 사항을 따르는 것이 좋습니다.</p>
<ul>
  <li>마스터에서도 사용되는 쓰기 가능한 복제본의 키에 쓰지 마세요. (마스터에 쓰는 모든 클라이언트를 제어할 수 없는 경우 이를 보장하기 어려울 수 있습니다.)</li>
  <li>실행 중인 시스템에서 인스턴스 집합을 업그레이드할 때 중간 단계로 인스턴스를 쓰기 가능한 복제본으로 구성하지 마세요. 일반적으로 데이터 일관성을 보장하려는 경우 인스턴스를 마스터로 승격할 수 있는 경우 쓰기 가능한 복제본으로 구성하지 마세요.
역사적으로 쓰기 가능한 복제본에 대해 합법적인 것으로 간주되는 몇 가지 사용 사례가 있었습니다. 버전 7.0부터 이러한 사용 사례는 이제 모두 사용되지 않으며 다른 방법으로도 동일한 작업을 수행할 수 있습니다. 예를 들어:</li>
  <li>느린 집합 또는 정렬된 집합 연산을 계산하고 SUNIONSTORE 및 ZINTERSTORE와 같은 명령을 사용하여 결과를 임시 로컬 키에 저장합니다. 대신 SUNION 및 ZINTER와 같이 결과를 저장하지 않고 반환하는 명령을 사용합니다.</li>
  <li>SORT 명령  (선택적 STORE 옵션으로 인해 읽기 전용 명령으로 간주되지 않으므로 읽기 전용 복제본에서 사용할 수 없음) 사용. 대신 읽기 전용 명령인 SORT_RO를 사용합니다.</li>
  <li>EVAL 및 EVALSHA를 사용하는 것도 Lua 스크립트가 쓰기 명령을 호출할 수 있기 때문에 읽기 전용 명령으로 간주되지 않습니다. 대신  Lua 스크립트가 읽기 전용 명령만 호출할 수 있는 EVAL_RO 및 EVALSHA_RO 사용합니다.</li>
</ul>

<p>복제본과 마스터가 다시 동기화되거나 복제본이 다시 시작되면 복제본에 대한 쓰기가 삭제되지만 자동으로 동기화된다는 보장은 없습니다.
버전 4.0 이전에는 쓰기 가능한 복제본이 TTL(Time to Live)이 설정된 키를 만료할 수 없었습니다. 즉  , EXPIRE 또는 키에 대한 최대 TTL을 설정하는 다른 명령을 사용하면 키가 누수되고 읽기 명령으로 액세스하는 동안 더 이상 키가 표시되지 않을 수 있지만 키 수에는 키가 표시되고 여전히 메모리를 사용합니다. Redis 4.0 RC3 이상 버전에서는 63보다 큰 DB 번호로 작성된 키를 제외하고 마스터와 마찬가지로 TTL이 있는 키를 제거할 수 있습니다(그러나 기본적으로 Redis 인스턴스에는 16개의 데이터베이스만 있음). 4.0 이상의 버전에서도  마스터에 존재할 수 있는 키에 EXPIRE를 사용하면  복제본과 마스터 간에 불일치가 발생할 수 있습니다.
또한 Redis 4.0 복제본 쓰기는 로컬에서만 수행되며 인스턴스에 연결된 하위 복제본으로 전파되지 않습니다. 대신 하위 복제본은 항상 최상위 마스터가 중간 복제본으로 보낸 것과 동일한 복제 스트림을 받습니다. 예를 들어 다음 설정에서:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A <span class="nt">---</span><span class="o">&gt;</span> B <span class="nt">---</span><span class="o">&gt;</span> C
</code></pre></div></div>
<p>B가 쓰기 가능하더라도 C는 B 쓰기를 볼 수 없으며  대신 마스터 인스턴스 A와 동일한 데이터 세트를 갖게 됩니다 .
Setting a replica to authenticate to a master
마스터에 requirepass를 통한 암호가 있는 경우 모든 동기화 작업에서 해당 암호를 사용하도록 복제본을 구성하는 것은 간단합니다.
실행 중인 인스턴스에서 이 작업을 수행하려면 redis-cli를 사용하고:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>config <span class="nb">set </span>masterauth &lt;password&gt;
</code></pre></div></div>
<p>영구적으로 설정하려면 구성 파일에 추가하십시오.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>masterauth &lt;password&gt;
</code></pre></div></div>
<h2 id="allow-writes-only-with-n-attached-replicas">Allow writes only with N attached replicas</h2>
<p>Redis 2.8부터는 현재 N개 이상의 복제본이 마스터에 연결되어 있는 경우에만 쓰기 쿼리를 허용하도록 Redis 마스터를 구성할 수 있습니다.
그러나 Redis는 비동기 복제를 사용하기 때문에 복제본이 실제로 지정된 쓰기를 수신했는지 확인할 수 없으므로 항상 데이터 손실 기간이 있습니다.</p>

<p>기능이 작동하는 방식은 다음과 같습니다.:</p>
<ul>
  <li>Redis 복제본은 매초마다 마스터를 ping하여 처리된 복제 스트림의 양을 확인합니다.</li>
  <li>Redis 마스터는 모든 복제본에서 마지막으로 ping을 수신한 시간을 기억합니다.</li>
  <li>사용자는 최대 시간(초)보다 지연이 없는 최소 복제본 수를 구성할 수 있습니다.
지연이 M초 미만인 복제본이 N개 이상 있는 경우 쓰기가 허용됩니다.
지정된 쓰기에 대해 일관성이 보장되지 않지만 적어도 데이터 손실에 대한 시간이 지정된 시간(초)으로 제한되는 최선의 데이터 안전 메커니즘으로 생각할 수 있습니다. 일반적으로 바운드 데이터 손실은 바인딩되지 않은 데이터 손실보다 낫습니다..
조건이 충족되지 않으면 마스터는 대신 오류로 응답하고 쓰기가 허용되지 않습니다.
이 기능에는 두 가지 구성 매개 변수가 있습니다:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>min-replicas-to-write &lt;number of replicas&gt;
min-replicas-max-lag &lt;number of seconds&gt;
</code></pre></div>    </div>
  </li>
</ul>

<p>자세한 내용은  Redis 소스 배포와 함께 제공되는 예제 redis.conf 파일을 확인하십시오.</p>
<h2 id="how-redis-replication-deals-with-expires-on-keys">How Redis replication deals with expires on keys</h2>
<p>Redis 만료를 통해 키의 TTL(Time to Live)을 제한할 수 있습니다. 이러한 기능은 인스턴스를 계산하는 기능에 따라 달라지지만, Redis 복제본은 Lua 스크립트를 사용하여 이러한 키를 변경하더라도 만료된 키를 올바르게 복제합니다.
이러한 기능을 구현하기 위해 Redis는 마스터와 복제본의 클럭 동기화 기능에 의존할 수 없으며, 이는 해결할 수 없는 문제이며 경합 상태와 데이터 세트의 분기를 초래할 수 있으므로 Redis는 세 가지 주요 기술을 사용하여 만료된 키의 복제가 작동할 수 있도록 합니다:</p>
<ol>
  <li>복제본은 키를 만료하지 않고 마스터가 키를 만료할 때까지 기다립니다. 마스터가 키를 만료시키면(또는 LRU로 인해 키를 제거하면)  모든 복제본에 전송되는 DEL 명령을 합성합니다.</li>
  <li>그러나 마스터 구동 만료로 인해 마스터가 제 시간에 DEL 명령을 제공할 수 없었기 때문에 복제본에 이미 논리적으로 만료된 메모리 키가 남아 있을 수 있습니다  . 이를 처리하기 위해 복제본은 논리 시계를 사용하여  데이터 세트의 일관성을 위반하지 않는 읽기 작업에만 키가 존재하지 않는다고 보고합니다  (마스터의 새 명령이 도착할 때). 이러한 방식으로 복제본은 여전히 존재하는 논리적으로 만료된 키를 보고하지 않습니다. 실제로 복제본을 사용하여 크기를 조정하는 HTML 조각 캐시는 원하는 TTL(Time to Live)보다 이미 오래된 항목을 반환하지 않도록 합니다.</li>
  <li>Lua 스크립트 실행 중에는 키 만료가 수행되지 않습니다. Lua 스크립트가 실행되면 개념적으로 마스터의 시간이 고정되므로 스크립트가 실행되는 모든 시간 동안 지정된 키가 존재하거나 존재하지 않습니다. 이렇게 하면 스크립트 중간에 키가 만료되는 것을 방지할 수 있으며, 데이터 세트에서 동일한 효과를 보장하는 방식으로 동일한 스크립트를 복제본에 보내는 데 필요합니다.</li>
</ol>

<p>복제본이 마스터로 승격되면 키가 독립적으로 만료되기 시작하며 이전 마스터의 도움이 필요하지 않습니다.</p>

<h2 id="configuring-replication-in-docker-and-nat">Configuring replication in Docker and NAT</h2>
<p>Docker 또는 포트 전달 또는 네트워크 주소 변환을 사용하는 다른 유형의 컨테이너를 사용하는 경우, 특히 Redis Sentinel 또는 마스터 INFO 또는 ROLE 명령 출력을 스캔하여 복제본의 주소를 검색하는 다른 시스템을 사용할 때 Redis 복제에 각별한 주의가 필요합니다.
문제는 마스터 인스턴스로 실행될 때 ROLE 명령과 INFO 출력의 복제 섹션  이 마스터에 연결하는 데 사용하는  IP 주소를 갖는 것으로 복제본을 표시한다는 것인데, NAT를 사용하는 환경에서는 복제본 인스턴스의 논리 주소(클라이언트가 복제본에 연결하는 데 사용해야 하는 주소)와 다를 수 있습니다.<br />
마찬가지로 복제본은 redis.conf에 구성된 수신 포트와 함께 나열되며, 포트가 다시 매핑되는 경우 전달된 포트와 다를 수 있습니다.
두 문제를 모두 해결하기 위해 Redis 3.2.2부터 복제본이 임의의 IP 및 포트 쌍을 마스터에 알리도록 강제할 수 있습니다. 사용할 두 가지 구성 지시문은 다음과 같습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>replica-announce-ip 5.5.5.5
replica-announce-port 1234
</code></pre></div></div>
<p>그리고  최근 Redis 배포판의 redis.conf 예제에 설명되어 있습니다.</p>

<h2 id="the-info-and-role-command">The INFO and ROLE command</h2>
<p>마스터 및 복제본 인스턴스의 현재 복제 파라미터에 대한 많은 정보를 제공하는 두 가지 Redis 명령이 있습니다. 하나는 INFO입니다. replication 인수를 INFO 복제로 사용하여 명령을 호출하면  복제와 관련된 정보만 표시됩니다. 컴퓨터 친화적인 또 다른 명령은 마스터 및 복제본의 복제 상태와 복제 오프셋, 연결된 복제본 목록 등을 제공하는 ROLE입니다.</p>

<h2 id="partial-sync-after-restarts-and-failovers">Partial sync after restarts and failovers</h2>
<p>Redis 4.0부터는 장애 조치 후 인스턴스가 마스터로 승격되면 이전 마스터의 복제본과 부분 재동기화를 계속 수행할 수 있습니다. 이를 위해 복제본은 이전 복제 ID와 이전 마스터의 오프셋을 기억하므로 이전 복제 ID를 요청하더라도 연결 복제본에 백로그의 일부를 제공할 수 있습니다.
그러나 승격된 복제본의 새 복제 ID는 데이터 집합의 다른 기록을 구성하기 때문에 다릅니다. 예를 들어 마스터는 사용 가능을 반환할 수 있고 일정 시간 동안 쓰기를 계속 수락할 수 있으므로 승격된 복제본에서 동일한 복제 ID를 사용하면 복제 ID와 오프셋 쌍이 단일 데이터 세트만 식별한다는 규칙을 위반하게 됩니다.
또한 복제본은 전원을 부드럽게 껐다가 다시 시작하면  마스터와 다시 동기화하는 데 필요한 정보를 RDB 파일에 저장할 수 있습니다. 이는 업그레이드의 경우에 유용합니다. 이것이 필요한 경우,  복제본에 대한 저장 및 종료 작업을  수행하기 위해 SHUTDOWN 명령을 사용하는 것이 좋습니다.
AOF 파일을 통해 다시 시작된 복제본을 부분적으로 동기화할 수 없습니다. 그러나 인스턴스를 종료하기 전에 RDB 지속성으로 전환하여 다시 시작할 수 있으며 마지막으로 AOF를 다시 활성화 할 수 있습니다.</p>

<h2 id="maxmemory-on-replicas">Maxmemory on replicas</h2>
<p>기본적으로 복제본은 maxmemory를 무시합니다  (장애 조치 후 또는 수동으로 마스터로 승격되지 않는 한). 즉, 키 제거는 마스터에서 처리되며, DEL 명령을 마스터 측에서 키가 제거될 때 복제본에 보냅니다.
이 동작은 마스터와 복제본이 일관성을 유지하도록 하며, 이는 일반적으로 원하는 것입니다. 그러나 복제본에 쓰기 가능하거나 복제본에 다른 메모리 설정을 적용하려는 경우 복제본에 수행된 모든 쓰기가 idempotent라고 확신하는 경우 이 기본값을 변경할 수 있습니다(그러나 수행 중인 작업을 이해해야 함).
복제본은 기본적으로 제거되지 않으므로 maxmemory를 통해 설정된 것보다 더 많은 메모리를 사용하게 될 수 있습니다  (복제본에서 더 클 수 있는 특정 버퍼가 있거나 데이터 구조가 때때로 더 많은 메모리를 차지할 수 있기 때문에). 복제본을 모니터링하고, 마스터가 구성된 maxmemory 설정에 도달하기 전에 실제 메모리 부족 상태에 도달하지 않도록 충분한 메모리가 있는지 확인합니다  .
이 동작을 변경하려면 복제본이 maxmemory를 무시하지 않도록 허용할 수 있습니다. 사용할 구성 지시문은 다음과 같습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>replica-ignore-maxmemory no
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis replication Redis가 복제를 통해 고가용성 및 장애 조치를 지원하는 방법 Redis 복제의 기반(Redis Cluster 또는 Redis Sentinel에서 추가 계층으로 제공하는 고가용성 기능 제외)에는 사용 및 구성이 간편한 리더 팔로워(마스터-복제본) 복제가 있습니다. 이를 통해 복제본 Redis 인스턴스는 마스터 인스턴스의 정확한 복사본이 될 수 있습니다. 복제본은 링크가 끊어질 때마다 자동으로 마스터에 다시 연결되며 마스터에 어떤 일이 발생하든 관계없이 복제본의 정확한 복사본이 되려고 시도합니다.]]></summary></entry></feed>