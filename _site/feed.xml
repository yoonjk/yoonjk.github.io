<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-16T15:15:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Redis 시작하기 - Redis 관리</title><link href="http://localhost:4000/cache/redis-management/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis 관리" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-management</id><content type="html" xml:base="http://localhost:4000/cache/redis-management/"><![CDATA[<h2 id="redis-관리-tips">Redis 관리 Tips</h2>
<p>프로덕션에서 Redis를 구성하고 관리할때 아래의 사항들을 고려하십시요.</p>

<h2 id="redis-setup-tips">Redis setup tips</h2>
<h4 id="linux">Linux</h4>
<ul>
  <li>Linux 운영 체제를 사용하여 Redis를 배포합니다. Redis는 OS X에서도 테스트되며 FreeBSD 및 OpenBSD 시스템에서도 수시로 테스트됩니다. 그러나 Linux는 대부분의 스트레스 테스트가 수행되고 대부분의 프로덕션 배포가 실행되는 곳입니다.</li>
  <li>Linux 커널 오버 커밋 메모리 설정을 1로 설정합니다.. vm.overcommit_memory = 1을 /etc/sysctl.conf에  추가합니다.
 그런 다음 재부팅하거나 <br />
sysctl vm.overcommit_memory=1 명령을 실행하여  설정을 활성화합니다.</li>
  <li>Linux 커널 기능인 Transparent Huge Pages가 Redis 메모리 사용량 및 대기 시간에 영향을 주지 않도록 하려면 다음 명령을 사용합니다:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>never <span class="o">&gt;</span> /sys/kernel/mm/transparent_hugepage/enabled 
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="memory">Memory</h4>
<ul>
  <li>스왑이 활성화되어 있고 스왑 파일 크기가 시스템의 메모리 양과 같은지 확인했습니다. Linux에 스왑이 설정되어 있지 않고 Redis 인스턴스가 실수로 너무 많은 메모리를 사용하는 경우 메모리가 부족할 때 Redis가 충돌하거나 Linux 커널 OOM 킬러가 Redis 프로세스를 종료할 수 있습니다. 스와핑이 활성화되면 지연 시간 급증을 감지하고 이에 대한 조치를 취할 수 있습니다.</li>
  <li>인스턴스에서 명시적 maxmemory 옵션 제한을 설정하여 시스템 메모리 제한에 거의 도달했을 때 실패하는 대신 오류를 보고하도록 합니다. maxmemory는  데이터 이외의 Redis에 대한 오버헤드와 조각화 오버헤드를 계산하여 설정해야 합니다. 따라서 사용 가능한 메모리가 10GB라고 생각되면 8 또는 9로 설정하십시오.</li>
  <li>쓰기 중심의 애플리케이션에서 Redis를 사용하는 경우 RDB 파일을 디스크에 저장하거나 AOF 로그를 다시 쓰는 동안 Redis는 일반적으로 사용되는 메모리의 최대 2배를 사용할 수 있습니다. 사용되는 추가 메모리는 저장 프로세스 중에 쓰기에 의해 수정된 메모리 페이지 수에 비례하므로 이 시간 동안 터치된 키(또는 집계 유형 항목)의 수에 비례하는 경우가 많습니다. 그에 따라 메모리 크기를 조정해야 합니다.</li>
  <li>문제 해결에 도움이 되는 LATENCY DOCTOR  및 MEMORY DOCTOR 명령을 참조하십시오.</li>
</ul>

<h2 id="imaging">Imaging</h2>
<ul>
  <li>daemontools에서 실행하는 경우, use daemonize no.</li>
</ul>

<h2 id="replication">Replication</h2>
<ul>
  <li>Redis가 사용하는 메모리 양에 비례하여 중요한 복제 백로그를 설정합니다. 백로그를 사용하면 복제본을 기본(마스터) 인스턴스와 훨씬 더 쉽게 동기화할 수 있습니다.</li>
  <li>복제를 사용하는 경우 Redis는 지속성이 비활성화된 경우에도 RDB 저장을 수행합니다. (디스크 없는 복제에는 적용되지 않습니다.) 마스터에 디스크 사용량이 없는 경우 디스크 없는 복제를 사용하도록 설정합니다.</li>
  <li>복제를 사용하는 경우 마스터가 지속성을 사용하도록 설정되어 있는지 또는 충돌 시 자동으로 다시 시작되지 않는지 확인합니다. 복제본은 마스터의 정확한 복사본을 유지하려고 하므로 마스터가 빈 데이터 세트로 다시 시작되면 복제본도 지워집니다.</li>
</ul>

<h2 id="security">Security</h2>
<ul>
  <li>기본적으로 Redis는 인증이 필요하지 않으며 모든 네트워크 인터페이스를 수신 대기합니다. Redis를 인터넷이나 공격자가 접근할 수 있는 다른 장소에 노출된 상태로 두면 큰 보안 문제가 됩니다. 예를 들어 이 공격이 얼마나 위험한지 확인하십시오.  Redis를 보호하는 방법에 대한 자세한 내용은 보안 페이지 및 빠른 시작을 확인하세요.</li>
</ul>

<h2 id="running-redis-on-ec2">Running Redis on EC2</h2>
<ul>
  <li>PV 기반 인스턴스가 아닌 HVM 기반 인스턴스 사용.</li>
  <li>이전 인스턴스 패밀리를 사용하지 마십시오. 
예를 들어 PV와 함께 m1.medium 대신 HVM과 함께 m3.medium을 사용합니다.</li>
  <li>EC2 EBS 볼륨에서 Redis 지속성을 사용하는 것은 EBS 볼륨의 지연 시간이 긴 특성을 갖는 경우가 있으므로 주의해서 처리해야 합니다.</li>
  <li>복제본이 마스터와 동기화될 때 문제가 있는 경우 새 디스크 없는 복제를 시도할 수 있습니다.<br />
가동 중지 시간 없이 Redis 인스턴스 업그레이드 또는 다시 시작
Redis는 서버에서 장기 실행 프로세스로 설계되었습니다. CONFIG SET 명령을 사용하여 다시 시작하지 않고도 많은 구성 옵션을 수정할 수 있습니다. Redis를 다시 시작하지 않고도 AOF에서 RDB 스냅샷 지속성으로 전환하거나 그 반대로 전환할 수도 있습니다.  자세한 내용은 CONFIG GET * 명령의 출력을 확인하십시오.
예를 들어 Redis 프로세스를 최신 버전으로 업그레이드하거나 현재 CONFIG 명령에서 지원하지 않는 구성 매개 변수를 수정해야 하는 경우 다시 시작해야 합니다.</li>
</ul>

<h2 id="가동-중지-시간을-방지하려면-다음-단계를-따르십시오">가동 중지 시간을 방지하려면 다음 단계를 따르십시오</h2>
<ul>
  <li>새 Redis 인스턴스를 현재 Redis 인스턴스의 복제본으로 설정합니다. 이렇게 하려면 다른 서버 또는 두 개의 Redis 인스턴스를 동시에 실행할 수 있는 충분한 RAM이 있는 서버가 필요합니다.</li>
  <li>단일 서버를 사용하는 경우 복제본이 마스터 인스턴스와 다른 포트에서 시작되었는지 확인하고, 그렇지 않으면 복제본을 시작할 수 없습니다.</li>
  <li>복제 초기 동기화가 완료될 때까지 기다립니다. 복제본의 로그 파일 확인.</li>
  <li>INFO를 사용하여 마스터와 복제본의 키 수가 동일한지 확인합니다. redis-cli를 사용하여 복제본이 예상대로 작동하고 명령에 응답하는지 확인합니다.</li>
  <li>CONFIG SET slave-read-only no를 사용하여 복제본에 쓰기 허용.</li>
  <li>새 인스턴스(복제본)를 사용하도록 모든 클라이언트를 구성합니다. CLIENT PAUSE 명령을 사용하여 전환 중에 클라이언트가 이전 마스터에 쓸 수 없도록 할 수 있습니다.</li>
  <li>마스터가 더 이상 쿼리를 수신하지 않는 것을 확인하면(MONITOR 명령을 사용하여 이를 확인할 수 있음) REPLICAOF NO ONE 명령을 사용하여 마스터할 복제본을 선택한  다음 마스터를 종료합니다.</li>
</ul>

<p>Redis Sentinel 또는 Redis Cluster를 사용하는 경우 최신 버전으로 업그레이드하는 가장 간단한 방법은 복제본을 하나씩 업그레이드하는 것입니다. 그런 다음 수동 장애 조치(failover)를 수행하여 업그레이드된 복제본 중 하나를 마스터로 승격하고 마지막으로 마지막 복제본을 승격할 수 있습니다</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis 관리 Tips 프로덕션에서 Redis를 구성하고 관리할때 아래의 사항들을 고려하십시요.]]></summary></entry><entry><title type="html">Redis 시작하기 - Redis Sentinel 고가용성</title><link href="http://localhost:4000/cache/ha-sentinel/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis Sentinel 고가용성" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/cache/ha-sentinel</id><content type="html" xml:base="http://localhost:4000/cache/ha-sentinel/"><![CDATA[<h2 id="redis-sentinel을-통한-고가용성">Redis Sentinel을 통한 고가용성</h2>
<p>클러스터되지 않은 Redis의 고가용성<br />
Redis Sentinel은 Redis Cluster를 사용하지 않을 때 Redis에 대한 고가용성을 제공합니다. Redis Sentinel은 모니터링, 알림과 같은 기타 부수적인 작업도 제공하고 클라이언트에 대한 구성 공급자 역할을 합니다.</p>

<p>다음은 거시적 수준(즉, big picture)에서 Sentinel 기능의 전체 목록입니다.</p>
<ul>
  <li>Monitoring. Sentinel은 마스터 및 복제본 인스턴스가 예상대로 작동하는지 지속적으로 확인합니다.</li>
  <li>Notification. Sentinel은 API를 통해 시스템 관리자 또는 기타 컴퓨터 프로그램에 모니터링되는 Redis 인스턴스 중 하나에 문제가 있음을 알릴 수 있습니다.</li>
  <li>Automatic failover. 마스터가 예상대로 작동하지 않는 경우 Sentinel은 복제본이 마스터로 승격되고, 다른 추가 복제본이 새 마스터를 사용하도록 다시 구성되며, Redis 서버를 사용하는 애플리케이션에 연결할 때 사용할 새 주소에 대한 알림을 받는 장애 조치 프로세스를 시작할 수 있습니다.</li>
  <li>Configuration provider. Sentinel은 클라이언트 서비스 검색을 위한 권한 소스 역할을 하며, 클라이언트는 지정된 서비스를 담당하는 현재 Redis 마스터의 주소를 요청하기 위해 Sentinels에 연결합니다. 장애 조치(failover)가 발생하면 Sentinels는 새 주소를 보고합니다.</li>
</ul>

<h2 id="분산-시스템으로서의-sentinel">분산 시스템으로서의 Sentinel</h2>
<p>Redis Sentinel은 분산 시스템입니다:<br />
Sentinel 자체는 여러 Sentinel 프로세스가 함께 협력하는 구성에서 실행되도록 설계되었습니다. 여러 Sentinel 프로세스가 협력할 경우 다음과 같은 이점이 있습니다:</p>
<ol>
  <li>오류 감지는 여러 Sentinel이 지정된 마스터를 더 이상 사용할 수 없다는 사실에 동의할 때 수행됩니다. 이렇게 하면 장애발생 확률이 낮아집니다.</li>
  <li>Sentinel은 모든 Sentinel 프로세스가 작동하지 않더라도 작동하므로 시스템이 오류에 대해 견고합니다. 그 자체로 단일 실패 지점인 장애 조치 시스템을 갖는 것은 장애에 대응이 취약합니다.</li>
</ol>

<p>Sentinel, Redis 인스턴스(마스터 및 복제본) 및 Sentinel 및 Redis에 연결하는 클라이언트의 합계도 특정 속성을 가진 더 큰 분산 시스템입니다. 이 문서에서는 Sentinel의 기본 속성을 이해하는 데 필요한 기본 정보부터 Sentinel의 작동 방식을 이해하기 위해 보다 복잡한 정보(선택 사항)에 이르기까지 개념을 점진적으로 소개합니다.</p>

<h2 id="sentinel-quick-start">Sentinel quick start</h2>
<h4 id="obtaining-sentinel">Obtaining Sentinel</h4>
<p>현재 버전의 Sentinel을 Sentinel 2라고 합니다. 더 강력하고 예측하기 쉬운 알고리즘(이 설명서에 설명되어 있음)을 사용하여 초기 Sentinel 구현을 다시 작성한 것입니다.<br />
Redis 2.8부터 Redis Sentinel의 안정적인 릴리스가 제공됩니다.<br />
새로운 개발은 불안정한 분기에서 수행  되며, 새로운 기능은 안정적인 것으로 간주되는 즉시 최신 안정 분기로 다시 이식되는 경우가 있습니다.
Redis 2.6과 함께 제공되는 Redis Sentinel 버전 1은 더 이상 사용되지 않으며 사용해서는 안 됩니다.</p>
<h4 id="running-sentinel">Running Sentinel</h4>
<p>redis-sentinel 실행 파일을 사용하는 경우  (또는 해당 이름의 redis-server 실행 파일에 대한 심볼릭 링크가 있는 경우  ) 다음 명령줄을 사용하여 Sentinel을 실행할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-sentinel /path/to/sentinel.conf
</code></pre></div></div>
<p>그렇지 않으면 redis-server 실행 파일을 직접 사용하여 Sentinel 모드에서 시작할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-server /path/to/sentinel.conf <span class="nt">--sentinel</span>
</code></pre></div></div>
<p>두 가지 방법 모두 동일하게 작동합니다.<br />
그러나  Sentinel을 실행할 때는 이 파일이 다시 시작될 경우 다시 로드될 현재 상태를 저장하기 위해 시스템에서 사용되므로 구성 파일을 사용해야 합니다. Sentinel은 구성 파일이 제공되지 않거나 구성 파일 경로를 쓸 수 없는 경우 시작을 거부합니다.<br />
Sentinel은 기본적으로 TCP 포트 26379에 대한 연결을 수신하므로 Sentinels가 작동하려면 서버의 포트 26379  가 열려 있어야 다른 Sentinel 인스턴스의 IP 주소에서 연결을 수신할 수 있습니다  . 그렇지 않으면 Sentinels가 대화할 수 없고 수행할 작업에 대해 동의할 수 없으므로 장애 조치(failover)가 수행되지 않습니다.</p>

<h4 id="배포하기-전에-sentinel에-대해-알아야-할-기본-사항">배포하기 전에 Sentinel에 대해 알아야 할 기본 사항</h4>
<ol>
  <li>강력한 배포를 위해 최소 3개의 Sentinel 인스턴스가 필요합니다.</li>
  <li>세 개의 Sentinel 인스턴스는 독립적인 방식으로 오류가 발생하는 것으로 여겨지는 컴퓨터 또는 가상 머신에 배치해야 합니다. 예를 들어 서로 다른 물리적 서버 또는 서로 다른 가용성 영역에서 실행되는 Virtual Machines는 다음과 같습니다..</li>
  <li>Sentinel + Redis 분산 시스템은 Redis가 비동기 복제를 사용하므로 오류 중에 승인된 쓰기가 유지되도록 보장하지 않습니다. 그러나 쓰기 손실 창을 특정 순간으로 제한하는 Sentinel을 배포하는 방법이 있지만 덜 안전한 다른 방법이 있습니다.</li>
  <li>클라이언트에서 Sentinel 지원이 필요합니다. 인기 있는 클라이언트 라이브러리는 Sentinel을 지원하지만 전부는 아닙니다.</li>
  <li>개발 환경에서 수시로 테스트하지 않는 경우 안전한 HA 설정이 없으며, 프로덕션 환경에서 작동하는 경우 가능한 경우 더 좋습니다. 너무 늦었을 때(마스터가 작동을 멈추는 새벽 3시)에만 분명해지는 잘못된 구성이 있을 수 있습니다.</li>
  <li>Sentinel, Docker 또는 다른 형태의 네트워크 주소 변환 또는 포트 매핑은 주의해서 혼합해야 합니다. Docker는 포트 다시 매핑을 수행하여 다른 Sentinel 프로세스의 Sentinel 자동 검색 및 마스터에 대한 복제본 목록을 중단합니다.  자세한 내용은 이 문서의 뒷부분에 있는 Sentinel 및 Docker에 대한 섹션을  확인하세요.</li>
</ol>

<h2 id="sentinel-구성하기">Sentinel 구성하기</h2>
<p>Redis 소스 배포에는  Sentinel을 구성하는 데 사용할 수 있는 자체 문서화된 예제 구성 파일인 sentinel.conf라는 파일이 포함되어 있지만 일반적인 최소 구성 파일은 다음과 같습니다 :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1

sentinel monitor resque 192.168.1.3 6380 4
sentinel down-after-milliseconds resque 10000
sentinel failover-timeout resque 180000
sentinel parallel-syncs resque 5
</code></pre></div></div>
<p>모니터링할 마스터를 지정하기만 하면 되며, 분리된 각 마스터(복제본 수에 제한이 없을 수 있음)에 다른 이름을 부여하면 됩니다. 자동 검색되는 복제본을 지정할 필요가 없습니다. Sentinel은 복제본에 대한 추가 정보로 구성을 자동으로 업데이트합니다(다시 시작할 경우 정보를 유지하기 위해). 또한 페일오버 중에 복제본이 마스터로 승격될 때마다, 그리고 새 Sentinel이 검색될 때마다 구성이 다시 작성됩니다.<br />
위의 예제 구성은 기본적으로 각각 마스터와 정의되지 않은 수의 복제본으로 구성된 두 개의 Redis 인스턴스 집합을 모니터링합니다. 한 인스턴스 집합을 mymaster라고 하고 다른  인스턴스 집합을 resque라고 합니다.</p>

<p>sentinel monitor 문의 인수의 의미  는 다음과 같습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
</code></pre></div></div>
<p>명확성을 위해 구성 옵션이 의미하는 바를 한 줄씩 확인해 보겠습니다:<br />
첫 번째 줄은 주소 127.0.0.1 및 포트 6379(쿼럼 2)에 있는 mymaster라는 마스터를 모니터링하도록 Redis에 지시하는 데 사용됩니다.마지막 인수는 쿼럼 인수 입니다.:</p>
<ul>
  <li>쿼럼은 마스터를  실제로 실패로 표시하고 가능한 경우 장애 조치(failover) 절차를 시작하기 위해 마스터에 연결할 수 없다는 사실에 동의해야 하는 Sentinel의 수입니다.</li>
  <li>그러나 쿼럼은 오류를 감지하는 데만 사용됩니다. 실제로 장애 조치(failover)를 수행하려면 센티넬 중 하나가 장애 조치(failover)의 리더로 선출되고 계속 진행할 수 있는 권한을 부여받아야 합니다. 이것은 Sentinel 프로세스의 대다수의 투표에서만 발생합니다.
예를 들어 5개의 Sentinel 프로세스가 있고 지정된 마스터의 쿼럼이 값 2로 설정된 경우 다음과 같은 일이 발생합니다:</li>
  <li>두 센티넬이 동시에 마스터에 연결할 수 없다는 데 동의하면 둘 중 하나가 장애 조치를 시작하려고 시도합니다.</li>
  <li>총 3개 이상의 Sentinel에 연결할 수 있는 경우 장애 조치(failover)가 승인되고 실제로 시작됩니다.</li>
</ul>

<p>실제로 이는 대부분의 Sentinel 프로세스가 통신할 수 없는 경우  (즉, 소수 파티션에서 장애 조치 없음) 장애 발생 시 Sentinel이 장애 조치를 시작하지 않음을 의미합니다.</p>
<h2 id="sentinel-추가옵션">Sentinel 추가옵션</h2>
<p>다른 옵션은 거의 항상 다음과 같은 형식입니다.:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;
</code></pre></div></div>
<p>그리고 다음과 같은 목적으로 사용됩니다:</p>
<ul>
  <li>down-after-milliseconds는 Sentinel이 다운되었다고 생각하기 시작하는 인스턴스에 연결할 수 없어야 하는 시간(밀리초 단위)입니다(PING에 응답하지 않거나 오류로 응답함).</li>
  <li>parallel-syncs는 장애 조치 후 동시에 새 마스터를 사용하도록 재구성할 수 있는 복제본 수를 설정합니다. 숫자가 낮을수록 장애 조치(failover) 프로세스가 완료되는 데 더 많은 시간이 걸리지만 복제본이 이전 데이터를 제공하도록 구성된 경우 모든 복제본이 동시에 마스터와 다시 동기화되는 것을 원하지 않을 수 있습니다. 복제 프로세스는 대부분 복제본에 대해 차단되지 않지만 마스터에서 대량 데이터를 로드하기 위해 중지되는 순간이 있습니다. 이 옵션을 값 1로 설정하여 한 번에 하나의 복제본에만 연결할 수 없도록 할 수 있습니다.<br />
추가 옵션은 이 문서의 나머지 부분에 설명되어 있으며  Redis 배포와 함께 제공되는 예제 sentinel.conf 파일에 설명되어 있습니다.
구성 매개변수는 런타임에 수정할 수 있습니다:</li>
  <li>마스터별 구성 매개변수는 SENTINEL SET를 사용하여 수정됩니다.</li>
  <li>글로벌 구성 매개변수는 SENTINEL CONFIG SET를 사용하여 수정됩니다..</li>
</ul>

<p>자세한 내용은 <a href="https://redis.io/docs/management/sentinel/#reconfiguring-sentinel-at-runtime">Reconfiguring Sentinel at runtime</a> 섹션을 참조하십시오.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis Sentinel을 통한 고가용성 클러스터되지 않은 Redis의 고가용성 Redis Sentinel은 Redis Cluster를 사용하지 않을 때 Redis에 대한 고가용성을 제공합니다. Redis Sentinel은 모니터링, 알림과 같은 기타 부수적인 작업도 제공하고 클라이언트에 대한 구성 공급자 역할을 합니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Docker를 이용하여 모니터링</title><link href="http://localhost:4000/cache/redis-stat-docker/" rel="alternate" type="text/html" title="Redis 시작하기 - Docker를 이용하여 모니터링" /><published>2023-04-15T00:00:00+09:00</published><updated>2023-04-15T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-stat-docker</id><content type="html" xml:base="http://localhost:4000/cache/redis-stat-docker/"><![CDATA[<h2 id="redis-sentinel-을-docker-를-사용하여-구성---사전준비">Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비</h2>
<p>Redis Sentinel과 Cluster를 redis-stat로 모니터링하는 것을 docker 기반으로 구성합니다.
myIP는 자신의 환경에 맞는 VM Server의 IP를 설정합니다.</p>

<h2 id="redis-모니터링---docker-compose">Redis 모니터링 - docker-compose</h2>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis-stat</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis-stat</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">insready/redis-stat</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span>
        <span class="s1">'</span><span class="s">--verbose'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">--server'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">redis-master:6379'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">redis-replica1:6383'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">redis-replica2:6384'</span>
        <span class="pi">]</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIP"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIP</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-replica2:myIP"</span>
  
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">9999:63790"</span>
</code></pre></div></div>
<h2 id="참조-">참조 :</h2>
<p><a href="https://hyos-dev-log.tistory.com/m/22">Hyo’s Dev Log</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비 Redis Sentinel과 Cluster를 redis-stat로 모니터링하는 것을 docker 기반으로 구성합니다. myIP는 자신의 환경에 맞는 VM Server의 IP를 설정합니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Docker를 이용하여 Redis Sentinel 구성</title><link href="http://localhost:4000/cache/setup-sentinel-docker/" rel="alternate" type="text/html" title="Redis 시작하기 - Docker를 이용하여 Redis Sentinel 구성" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-14T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-sentinel-docker</id><content type="html" xml:base="http://localhost:4000/cache/setup-sentinel-docker/"><![CDATA[<h2 id="redis-sentinel-을-docker-를-사용하여-구성---사전준비">Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비</h2>
<p>Redis Sentinel 을 docker기반으로 구성하기 위해서는 docker, docker-compose를 설치하여야 합니다.</p>

<p>docker engine 설치방법은 아래의 <a href="https://yoonjk.github.io/docker/docker/">링크</a>를 참조하세요.</p>

<h2 id="redis-sentinel---docker-compose">Redis Sentinel - docker-compose</h2>
<ul>
  <li>port 설정</li>
  <li>extra_hosts설정</li>
  <li>redis master/replica1/2는 netowrk_mode를 host로 설정</li>
  <li>sentinel은 client에서 접근하기 위해 port를 expose (5000,5001,5002)</li>
  <li>sentinel 구성은 QUORUM으로 구성합니다.</li>
</ul>

<p>redis master 의 port 는 default port 6379로 설정합니다.
replica의 port는 6383, 6384로 설정합니다.</p>

<p>extra_hosts에  myIP대신 VM 서버의 IP로 변경합니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>

<span class="na">services</span><span class="pi">:</span>

  <span class="na">redis-master</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">master</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --port </span><span class="m">6379</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">./master:/data"</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="na">redis-replica1</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">replica1</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --slaveof redis-master 6379  --replicaof redis-master 6379 --port </span><span class="m">6383</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">./replica1:/data"</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="na">redis-replica2</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">replica2</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --slaveof redis-master 6379  --replicaof redis-master 6379 --port </span><span class="m">6384</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">./replica2:/data"</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="c1"># Instance 1</span>
  <span class="na">redis-sentinel1</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">sentinel1</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./sentinel</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000:26379"</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="c1"># Instance 2</span>
  <span class="na">redis-sentinel2</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">sentinel2</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./sentinel</span>
    <span class="na">links</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis-master</span>
      <span class="pi">-</span> <span class="s">redis-replica1</span>
      <span class="pi">-</span> <span class="s">redis-replica2</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5001:26379"</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="c1"># Instance 3</span>
  <span class="na">redis-sentinel3</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">sentinel3</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./sentinel</span>
    <span class="na">links</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis-master</span>
      <span class="pi">-</span> <span class="s">redis-replica1</span>
      <span class="pi">-</span> <span class="s">redis-replica2</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5002:26379"</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>
</code></pre></div></div>

<p>sentinel.conf 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port 26379

<span class="nb">dir</span> /tmp

sentinel resolve-hostnames <span class="nb">yes
</span>sentinel monitor redismaster redis-master 6379 <span class="nv">$SENTINEL_QUORUM</span>
sentinel down-after-milliseconds redismaster <span class="nv">$SENTINEL_DOWN_AFTER</span>
sentinel parallel-syncs redismaster 1
sentinel failover-timeout redismaster <span class="nv">$SENTINEL_FAILOVER</span>
</code></pre></div></div>
<p>entrypoint.sh 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/</span><span class="se">\$</span><span class="s2">SENTINEL_QUORUM/</span><span class="nv">$SENTINEL_QUORUM</span><span class="s2">/g"</span> /redis/sentinel.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/</span><span class="se">\$</span><span class="s2">SENTINEL_DOWN_AFTER/</span><span class="nv">$SENTINEL_DOWN_AFTER</span><span class="s2">/g"</span> /redis/sentinel.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/</span><span class="se">\$</span><span class="s2">SENTINEL_FAILOVER/</span><span class="nv">$SENTINEL_FAILOVER</span><span class="s2">/g"</span> /redis/sentinel.conf

redis-server /redis/sentinel.conf <span class="nt">--sentinel</span>
</code></pre></div></div>

<p>Dockerfile</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> redis</span>

<span class="k">ENV</span><span class="s"> SENTINEL_QUORUM 2</span>
<span class="k">ENV</span><span class="s"> SENTINEL_DOWN_AFTER 1000</span>
<span class="k">ENV</span><span class="s"> SENTINEL_FAILOVER 1000</span>

<span class="k">RUN </span><span class="nb">mkdir</span> <span class="nt">-p</span> /redis

<span class="k">WORKDIR</span><span class="s"> /redis</span>

<span class="k">COPY</span><span class="s"> sentinel.conf .</span>
<span class="k">COPY</span><span class="s"> sentinel-entrypoint.sh /usr/local/bin/</span>

<span class="k">RUN </span><span class="nb">chown </span>redis:redis /redis/<span class="k">*</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">chmod</span> +x /usr/local/bin/sentinel-entrypoint.sh

<span class="k">EXPOSE</span><span class="s"> 26379</span>

<span class="k">ENTRYPOINT</span><span class="s"> ["sentinel-entrypoint.sh"]</span>
</code></pre></div></div>

<h2 id="참조-">참조 :</h2>
<p><a href="https://github.com/Developers-Notebook/Redis-Sentinel-Docker-Compose">Redis-Sentinel-Docker-Compose</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비 Redis Sentinel 을 docker기반으로 구성하기 위해서는 docker, docker-compose를 설치하여야 합니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Springboot Redis Cluster Failover 설정</title><link href="http://localhost:4000/cache/failover-redis-cluster/" rel="alternate" type="text/html" title="Redis 시작하기 - Springboot Redis Cluster Failover 설정" /><published>2023-04-12T00:00:00+09:00</published><updated>2023-04-12T00:00:00+09:00</updated><id>http://localhost:4000/cache/failover-redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/failover-redis-cluster/"><![CDATA[<h2 id="redis-cluster-configuration-설정">Redis Cluster Configuration 설정</h2>
<p>Redis Cluster를 구성하고 failover 하기 위해서는 application config 이외에 추가적으로  Redis cluster Confugration이 필요합니다.
Redis Cluster를 구성하고 Master를 강제로 종료시키면 Replica중 1개가 Master로 승격되어 지속적인 서비스를 이어갈 수 있습니다.<br />
그리고 Lettuce를 사용하면 이를 자동으로 감지하여 서비스를 지속할 수 있습니다. 
그러나 쓰기작업이 필요한 서비스는 약간의 delay를 요구하며, Redis Cluster 상태가 refresh되면 정상적인 쓰기 작업이 가능해집니다.
물론 일기작업은 다음의 설정으로 변함없이 지속적으로 서비스가 가능합니다.</p>
<h4 id="지속적인-읽기-작업">지속적인 읽기 작업</h4>
<p>Replica중 1개 또는 모두 종료되더라도 지속적으로 일기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.</p>

<p><strong>REPLICA_PREFERRED</strong></p>

<h4 id="지속적인-쓰기-작업">지속적인 쓰기 작업</h4>
<p>Redis Cluster Master중 1개가 종료되더라도 지속적으로 쓰기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.
아래의 설정값이 default 값이 false로 되어 있기 때문에 true로 설정을 변경해야 master가 종료되고 replica중 1개가 master로 승격되어 서비스를 계속할 수 있게되고, 이를 Lettuce가 감지하여 애플리케이션에서도 서비스를 지속하기 위해 아래의 설정을 하여야 합니다.</p>

<p><strong>enablePeriodicRefresh</strong></p>

<p>그리고 Refresh time을 설정하여 Lettuce가 이를 빠르게 감지하도록 설정합니다.
<strong>refreshPeriod</strong></p>

<p>다음의 코드는 Redis Cluster를 구성하고 replica가 종료되거나 cluster의 master가 종료되더라도 읽기 작업과 쓰기 작업을 지속할 수 있도록 하기 위한 설정정보입니다.</p>

<p>전체 소스는 아래의 <a href="https://github.com/yoonjk/redis-cluster.git">github 링크</a>에 있습니다.
<a href="https://github.com/yoonjk/redis-cluster.git">https://github.com/yoonjk/redis-cluster.git</a></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.time.Duration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.RedisClusterConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.RedisConnectionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">io.lettuce.core.ReadFrom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.lettuce.core.cluster.ClusterClientOptions</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.lettuce.core.cluster.ClusterTopologyRefreshOptions</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="o">{</span>
	<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.cluster.nodes}"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clusterNodes</span><span class="o">;</span>
    <span class="c1">// lettuce 사용시</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisConnectionFactory</span> <span class="nf">redisConnectionFactory</span><span class="o">(){</span>
        <span class="nc">LettuceClientConfiguration</span> <span class="n">clientConfiguration</span> <span class="o">=</span> <span class="nc">LettuceClientConfiguration</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        		<span class="o">.</span><span class="na">clientOptions</span><span class="o">(</span><span class="nc">ClusterClientOptions</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        				<span class="o">.</span><span class="na">topologyRefreshOptions</span><span class="o">(</span><span class="nc">ClusterTopologyRefreshOptions</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        						<span class="o">.</span><span class="na">refreshPeriod</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
        						<span class="o">.</span><span class="na">enableAdaptiveRefreshTrigger</span><span class="o">()</span>
        						<span class="o">.</span><span class="na">enablePeriodicRefresh</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>    <span class="c1">// Default 가 False</span>
        						<span class="o">.</span><span class="na">build</span><span class="o">())</span>
        				<span class="o">.</span><span class="na">build</span><span class="o">())</span>
        		
                <span class="o">.</span><span class="na">readFrom</span><span class="o">(</span><span class="nc">ReadFrom</span><span class="o">.</span><span class="na">REPLICA_PREFERRED</span><span class="o">)</span> <span class="c1">// 복제본 노드에서 읽지 만 사용할 수없는 경우 마스터에서 읽습니다.</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
        

        <span class="c1">// 모든 클러스터(master, slave) 정보를 적는다. (해당 서버중 접속되는 서버에서 cluster nodes 명령어를 통해 모든 클러스터 정보를 읽어오기에 다운 됐을 경우를 대비하여 모든 노드 정보를 적어두는편이 좋다.)</span>
        <span class="nc">RedisClusterConfiguration</span> <span class="n">redisClusterConfiguration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisClusterConfiguration</span><span class="o">(</span><span class="n">clusterNodes</span><span class="o">);</span>
        
        <span class="nc">LettuceConnectionFactory</span> <span class="n">lettuceConnectionFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LettuceConnectionFactory</span><span class="o">(</span><span class="n">redisClusterConfiguration</span><span class="o">,</span> <span class="n">clientConfiguration</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">lettuceConnectionFactory</span><span class="o">;</span>
    <span class="o">}</span>
        
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis Cluster Configuration 설정 Redis Cluster를 구성하고 failover 하기 위해서는 application config 이외에 추가적으로 Redis cluster Confugration이 필요합니다. Redis Cluster를 구성하고 Master를 강제로 종료시키면 Replica중 1개가 Master로 승격되어 지속적인 서비스를 이어갈 수 있습니다. 그리고 Lettuce를 사용하면 이를 자동으로 감지하여 서비스를 지속할 수 있습니다. 그러나 쓰기작업이 필요한 서비스는 약간의 delay를 요구하며, Redis Cluster 상태가 refresh되면 정상적인 쓰기 작업이 가능해집니다. 물론 일기작업은 다음의 설정으로 변함없이 지속적으로 서비스가 가능합니다. 지속적인 읽기 작업 Replica중 1개 또는 모두 종료되더라도 지속적으로 일기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Docker를 이용한 클러스터링 구성</title><link href="http://localhost:4000/cache/redis-cluster-using-docker/" rel="alternate" type="text/html" title="Redis 시작하기 - Docker를 이용한 클러스터링 구성" /><published>2023-04-12T00:00:00+09:00</published><updated>2023-04-12T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster-using-docker</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster-using-docker/"><![CDATA[<h2 id="redisconf-편집">redis.conf 편집</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> 6300 6301 6302 6400 6401 6402
</code></pre></div></div>
<p>redis config 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## redis.conf 편집</span>
vi redis.conf
port 6379
cluster-enabled <span class="nb">yes
</span>cluster-config-file nodes.conf
cluster-node-timeout 3000
appendonly <span class="nb">yes</span>
</code></pre></div></div>
<p>redis.conf를 각 폴더에 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf 6300/
<span class="nb">cp </span>redis.conf 6301/
<span class="nb">cp </span>redis.conf 6302/
<span class="nb">cp </span>redis.conf 6400/
<span class="nb">cp </span>redis.conf 6401/
<span class="nb">cp </span>redis.conf 6402/
</code></pre></div></div>

<p>redis.conf를 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6300/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6301/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6302/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6400/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6401/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6402/g'</span> 6300/redis.conf
</code></pre></div></div>

<h2 id="master-redis-작성">Master Redis 작성</h2>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis1</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis1</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis1</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./6300/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">6300:6300</span>
    <span class="pi">-</span> <span class="s">16300:16300</span>

  <span class="na">redis2</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis2</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis2</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6301/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6301:6301</span>
      <span class="pi">-</span> <span class="s">16301:16301</span>

  <span class="na">redis3</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis3</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis3</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6302/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6302:6302</span>
      <span class="pi">-</span> <span class="s">16302:16302</span>

  <span class="na">redis4</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis4</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis4</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6400/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6400:6400</span>
      <span class="pi">-</span> <span class="s">16400:16400</span>

  <span class="na">redis5</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis5</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis5</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6401/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6401:6401</span>
      <span class="pi">-</span> <span class="s">16401:16401</span>

  <span class="na">redis6</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis6</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis6</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6402/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6402:6402</span>
      <span class="pi">-</span> <span class="s">16402:16402</span>
</code></pre></div></div>
<h2 id="redis-cluster-시작">Redis cluster 시작</h2>
<p>docker-compose 이용하여 Redis Cluster를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
docker ps
</code></pre></div></div>

<h4 id="클러스터-구성">클러스터 구성</h4>
<p>6개의 docker container redis가 실행중인 것을 확인하고 redis1에 접속하여 다음과 같이 클러스터를 구성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> redis1 bash
redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
<span class="nb">exit</span>
</code></pre></div></div>
<p>redis1 container의 로그를 다음과 같이 확인합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs -f redis1
</code></pre></div></div>
<h4 id="replicas-구성">Replicas 구성</h4>
<p>Redis Master에 각각 1개의 Replica를 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># master1에 replica 1 추가</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> redis1 bash
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>

<span class="c"># master2에 replica 2 추가</span>
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>

<span class="c"># master3에 replica 3 추가</span>
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<p><img src="/assets/images/cache/13-cache-add-slave-docker.png" alt="Create Admin" /></p>
<h2 id="참고">참고</h2>
<p><a href="https://uchupura.tistory.com/56">우쭈뿌라 개발노트</a><br />
<a href="https://pinggoopark.tistory.com/268">과거의 나를 위해</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="docker" /><summary type="html"><![CDATA[redis.conf 편집]]></summary></entry><entry><title type="html">@Inject과 @Autowired의 차이점</title><link href="http://localhost:4000/springboot/difference-autowired-inject/" rel="alternate" type="text/html" title="@Inject과 @Autowired의 차이점" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T00:00:00+09:00</updated><id>http://localhost:4000/springboot/difference-autowired-inject</id><content type="html" xml:base="http://localhost:4000/springboot/difference-autowired-inject/"><![CDATA[<h2 id="inject-vs-autowired">@Inject vs @Autowired</h2>
<p>@Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다.
@Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.</p>

<table>
  <thead>
    <tr>
      <th>Sr. No.	Key</th>
      <th>@Inject</th>
      <th>@Autowired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1	Basic</td>
      <td>그것은 자바 CDI의 일부입니다</td>
      <td>스프링 프레임 워크의 일부입니다.</td>
    </tr>
    <tr>
      <td>2	Required</td>
      <td>required 속성이 없습니다.</td>
      <td>required속성이 있습니다.</td>
    </tr>
    <tr>
      <td>3	Default Scope	autowire</td>
      <td>기본 범위는 싱글톤입니다.</td>
      <td>주입 빈의 기본 범위는 prototype입니다.</td>
    </tr>
    <tr>
      <td>4	Ambiguity</td>
      <td>주입을 위해 빈에 모호성이있는 경우 코드에 @Named해야합니다</td>
      <td>주입을 위해 Bean에 모호한 경우 코드에 @Qualifer 추가해야합니다.</td>
    </tr>
    <tr>
      <td>5	Advantage</td>
      <td>Java CDI의 일부이므로 DI 프레임워크에 의존하지 않습니다.</td>
      <td>시스템을 느슨하게 결합합니다.</td>
    </tr>
  </tbody>
</table>

<p>응용 프로그램을 Spring 프레임워크와 밀접하게 결합시킵니다. 나중에 다른 DI 프레임워크로 이동하려면 응용 프로그램을 다시 구성해야합니다.</p>

<p>@Injection 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InjectionExample</span> <span class="o">{</span>
   <span class="nd">@Inject</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@Autowired 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutowiredExample</span> <span class="o">{</span>
   <span class="nd">@Autowired</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="springboot" /><summary type="html"><![CDATA[@Inject vs @Autowired @Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다. @Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.]]></summary></entry><entry><title type="html">Redis 시작하기 - 레디스 모니터링 Redis Stat</title><link href="http://localhost:4000/cache/monitoring-redis-stat/" rel="alternate" type="text/html" title="Redis 시작하기 - 레디스 모니터링 Redis Stat" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/monitoring-redis-stat</id><content type="html" xml:base="http://localhost:4000/cache/monitoring-redis-stat/"><![CDATA[<p>Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.</p>

<h2 id="redis-stat-설치">Redis Stat 설치</h2>
<p>Redis Stat는 ruby로 개발되어 있어서 Ruby가 설치되어 있어야 합니다. Ruby를 설치하기전에 의존성 패키지를 먼저 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ruby-devel gcc make rpm-build rubygems
<span class="c"># Ruby install</span>
git clone https://github.com/rbenv/rbenv-installer
<span class="nb">cd </span>rbenv-installer
<span class="nb">cd </span>bin
./rbenv-installer 
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/.rbenv/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'eval "$(rbenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc
rbenv <span class="nb">install </span>2.6.0
rbenv global 2.6.0
gem <span class="nb">install </span>redis-stat
</code></pre></div></div>
<p>redis-stat를 다음과 같이 실행합니다.</p>

<p>redis-stat 주소:포트번호 주소:포트번호 주소:포트번호  –verbose –daemon –server=8888</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-stat localhost:6300 localhost:6301 localhost:6302 localhost:6400 localhost:6401 localhost:6402 <span class="nt">--daemon</span> <span class="nt">--server</span><span class="o">=</span>8888
</code></pre></div></div>
<p>브라우저 Url 입력창에 http://localhost:8888 접속하여 Redis Stat UI console에 접속합니다.</p>

<p><img src="/assets/images/cache/12-cache-redis-stat-1.png" alt="Jupyter log" /></p>

<p><img src="/assets/images/cache/12-cache-redis-stat-2.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="redis-stat" /><summary type="html"><![CDATA[Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Redis Cluster</title><link href="http://localhost:4000/cache/redis-cluster/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis Cluster" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster/"><![CDATA[<h2 id="redis-cluster-환경구성">Redis Cluster 환경구성</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port <span class="o">[</span>각자포트]
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-[각자포트].conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_[각자포트].aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_[각자포트].pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_[각자포트].log
</code></pre></div></div>
<p>redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-server 6300</span>
<span class="nb">cp </span>redis.conf redis_6300.conf
vi redis_6300.conf
</code></pre></div></div>
<p>redis_6300.conf 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port 6300
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-6300.conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_6300.aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_6300.pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_6300.log
</code></pre></div></div>
<p>나머지 redis server의 환경파일을 복사하고 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6300.conf redis_6301.conf
<span class="nb">cp </span>redis_6300.conf redis_6302.conf
<span class="nb">cp </span>redis_6300.conf redis_6400.conf
<span class="nb">cp </span>redis_6300.conf redis_6401.conf
<span class="nb">cp </span>redis_6300.conf redis_6402.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6301/g'</span> redis_6301.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6302/g'</span> redis_6302.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6400/g'</span> redis_6400.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6401/g'</span> redis_6401.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6402/g'</span> redis_6402.conf
</code></pre></div></div>

<h2 id="redis-cluster-실행">Redis Cluster 실행</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./src/redis-server redis_6300.conf
./src/redis-server redis_6301.conf
./src/redis-server redis_6302.conf
./src/redis-server redis_6400.conf
./src/redis-server redis_6401.conf
./src/redis-server redis_6402.conf

redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
</code></pre></div></div>
<h4 id="redis-cluster-실행로그">redis cluster 실행로그</h4>
<p><img src="/assets/images/cache/08-cache-create-redis-cluster.png" alt="Jupyter log" /></p>

<h4 id="master-노드-로그">Master 노드 로그</h4>
<p><img src="/assets/images/cache/09-cache-log-redis-cluster.png" alt="Jupyter log" /></p>

<h2 id="slave1-등록">Slave1 등록</h2>
<p>Master1(6300)에 Slave1(6400) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>
</code></pre></div></div>
<h4 id="slave-등록-로그">Slave 등록 로그</h4>
<p><img src="/assets/images/cache/10-cache-add-slave-node.png" alt="Jupyter log" /></p>

<h4 id="master-로그">Master 로그</h4>
<p><img src="/assets/images/cache/11-cache-log-redis-master.png" alt="Jupyter log" /></p>

<h4 id="slave2-등록">Slave2 등록</h4>
<p>Master2(6301)에 Slave1(6401) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h4 id="slave3-등록">Slave3 등록</h4>
<p>Master3(6302)에 Slave1(6402) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h2 id="클러스터-정보확인">클러스터 정보확인</h2>
<p>redis 클러스터 정보를 다음과 같이 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> info 127.0.0.1:6300
</code></pre></div></div>
<h4 id="redis-cluster-failover">Redis Cluster Failover</h4>
<p>Redis Master를 강제로 종료했을 떄 어떻게 failover되는지 확인하기 위해 master1(6300)을 강제로 종료하여 redis stat로 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis
<span class="nb">kill</span> <span class="nt">-9</span> pid
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Cluster 환경구성 port [각자포트] # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-[각자포트].conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_[각자포트].aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_[각자포트].pid # 로그 파일 저장 경로 지정 logfile logs/redis_[각자포트].log redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다. # redis-server 6300 cp redis.conf redis_6300.conf vi redis_6300.conf redis_6300.conf 파일을 다음과 같이 수정합니다. port 6300 # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-6300.conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_6300.aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_6300.pid # 로그 파일 저장 경로 지정 logfile logs/redis_6300.log 나머지 redis server의 환경파일을 복사하고 수정합니다. ```bash cp redis_6300.conf redis_6301.conf cp redis_6300.conf redis_6302.conf cp redis_6300.conf redis_6400.conf cp redis_6300.conf redis_6401.conf cp redis_6300.conf redis_6402.conf]]></summary></entry><entry><title type="html">Redis 시작하기 - Redis Sentinel &amp;amp; HAProxy</title><link href="http://localhost:4000/cache/haproxy/" rel="alternate" type="text/html" title="Redis 시작하기 - Redis Sentinel &amp;amp; HAProxy" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/haproxy</id><content type="html" xml:base="http://localhost:4000/cache/haproxy/"><![CDATA[<p>Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.</p>

<h2 id="haproxy-환경-구성">Haproxy 환경 구성</h2>

<h4 id="haproxy-설치를-위한-의존성-패키지-설치">HAProxy 설치를 위한 의존성 패키지 설치</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># HAProxy 설치를 위한 의존성 패키지 설치</span>
yum <span class="nb">install</span> <span class="nt">-y</span> gcc openssl openssl-devel pcre-static pcre-devel systemd-devel
</code></pre></div></div>

<h4 id="haproxy-설치">Haproxy 설치</h4>
<p>haproxy를 구성하기 위해 haproxy 최근 버전을 <a href="http://www.haproxy.org/download/2.8/src/devel/">download</a>하여 build 및 install합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://www.haproxy.org/download/2.8/src/devel/haproxy-2.8-dev7.tar.gz
<span class="nb">tar </span>xvzf haproxy-2.8-dev7.tar.gz
<span class="nb">cd </span>haproxy-2.8-dev7 
make <span class="nv">TARGET</span><span class="o">=</span>linux-glibc <span class="nv">USE_OPENSSL</span><span class="o">=</span>1 <span class="nv">USE_PCRE</span><span class="o">=</span>1 <span class="nv">USE_ZLIB</span><span class="o">=</span>1 <span class="nv">USE_SYSTEMD</span><span class="o">=</span>1

<span class="c">## Install haproxy</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>아래의 명령어를 입력하여 설치된 HAProxy 버전을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/sbin/haproxy <span class="nt">-v</span>
</code></pre></div></div>
<p>OS가 reboot되어도 재시작하도록 service 파일을 작서합니다. 아래의 명령어를 입력하여 HAProxy 서비스 예제 파일을 다운로드합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"http://git.haproxy.org/?p=haproxy-2.3.git;a=blob_plain;f=contrib/systemd/haproxy.service.in"</span> <span class="nt">-o</span> /etc/systemd/system/haproxy.service

<span class="c"># 서비스파일 편집</span>
vi /etc/systemd/system/haproxy.service
</code></pre></div></div>
<p>아래와 같이 서비스 파일에서 아래의 3개의 내용을 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
</code></pre></div></div>

<p>서비프파일 전체 내용</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>HAProxy Load Balancer
<span class="nv">After</span><span class="o">=</span>network-online.target
<span class="nv">Wants</span><span class="o">=</span>network-online.target

<span class="o">[</span>Service]
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/default/haproxy
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/sysconfig/haproxy
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"CONFIG=/etc/haproxy/haproxy.cfg"</span> <span class="s2">"PIDFILE=/run/haproxy.pid"</span> <span class="s2">"EXTRAOPTS=-S /run/haproxy-master.sock"</span>
<span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
<span class="nv">ExecReload</span><span class="o">=</span>/bin/kill <span class="nt">-USR2</span> <span class="nv">$MAINPID</span>
<span class="nv">KillMode</span><span class="o">=</span>mixed
<span class="nv">Restart</span><span class="o">=</span>always
<span class="nv">SuccessExitStatus</span><span class="o">=</span>143
<span class="nv">Type</span><span class="o">=</span>notify

<span class="c"># The following lines leverage SystemD's sandboxing options to provide</span>
<span class="c"># defense in depth protection at the expense of restricting some flexibility</span>
<span class="c"># in your setup (e.g. placement of your configuration files) or possibly</span>
<span class="c"># reduced performance. See systemd.service(5) and systemd.exec(5) for further</span>
<span class="c"># information.</span>

<span class="c"># NoNewPrivileges=true</span>
<span class="c"># ProtectHome=true</span>
<span class="c"># If you want to use 'ProtectSystem=strict' you should whitelist the PIDFILE,</span>
<span class="c"># any state files and any other files written using 'ReadWritePaths' or</span>
<span class="c"># 'RuntimeDirectory'.</span>
<span class="c"># ProtectSystem=true</span>
<span class="c"># ProtectKernelTunables=true</span>
<span class="c"># ProtectKernelModules=true</span>
<span class="c"># ProtectControlGroups=true</span>
<span class="c"># If your SystemD version supports them, you can add: @reboot, @swap, @sync</span>
<span class="c"># SystemCallFilter=~@cpu-emulation @keyring @module @obsolete @raw-io</span>

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div></div>
<h2 id="haproxy-설정파일-수정">haproxy 설정파일 수정</h2>
<p>아래의 명령어를 입력하여 HAProxy 폴더를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/log/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/certs
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/errors/
</code></pre></div></div>
<p>HAProxy 설정 파일에 아래와 같이 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------------------------------------------------------------------</span>
<span class="c"># common defaults that all the 'listen' and 'backend' sections will</span>
<span class="c"># use if not designated in their block</span>
<span class="c">#---------------------------------------------------------------------</span>
defaults
    mode                    tcp
    log                     127.0.0.1 local0
    retries                 3
    <span class="nb">timeout </span>http-request    10s
    <span class="nb">timeout </span>queue           1m
    <span class="nb">timeout </span>connect         5s
    <span class="nb">timeout </span>client          5s
    <span class="nb">timeout </span>server          5s
    <span class="nb">timeout </span>http-keep-alive 10s
    <span class="nb">timeout </span>check           1s
    maxconn                 10000
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_master
    <span class="nb">bind</span> <span class="k">*</span>:8000
    default_backend bk_redis_master
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_master
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:master
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check

<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_slave
    <span class="nb">bind</span> <span class="k">*</span>:8001
    default_backend bk_redis_slave
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_slave
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:slave
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># admin uI</span>
<span class="c">#---------------------------------------------------------------------</span>
listen stats
 <span class="nb">bind</span> :80
 mode http
 balance roundrobin
 maxconn 10
 <span class="nb">timeout </span>client 5000
 <span class="nb">timeout </span>connect 4000
 <span class="nb">timeout </span>server 30000

 <span class="c"># Enable stats page</span>
 stats <span class="nb">enable</span>

 <span class="c"># Hide HAProxy version</span>
 stats hide-version

  <span class="c">#This is the virtual URL to access the stats page</span>
 stats uri /haproxy_stats

 <span class="c">#Authentication realm. This can be set to anything.</span>
 <span class="c">#Escape space characters with a backslash.</span>
 stats realm HAProxy<span class="se">\ </span>Statistics

 <span class="c">#The user/pass you want to use. Change this password!</span>
 stats auth admin:admin

 <span class="c">#This allows you to take down and bring up back end servers.</span>
 <span class="c">#This will produce an error on older versions of HAProxy.</span>
 stats admin <span class="k">if </span>TRUE
</code></pre></div></div>

<p>## HAProxy 실행
HAProxy를 서비스를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> systemctl daemon-reload
 systemctl <span class="nb">enable </span>haproxy
 systemctl start haproxy
</code></pre></div></div>

<h2 id="haproxy-ui-for-redis">HAProxy UI for redis</h2>
<p>HAProxy UI를 접속하기 위해 아래의 Url http://localhost/haproxy_stats 에 접속하면 Redis master와
slave의 상태를 확인할 수 있습니다.</p>

<p>![haproxy]](07-cache-haproxy.png)</p>

<h2 id="haproxy-연결-테스트">HAProxy 연결 테스트</h2>
<p>Redis master에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8000
localhost:8000&gt; <span class="nb">set </span>k1 v1
</code></pre></div></div>
<p>Redis slave에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8001
localhost:8001&gt; get k1
</code></pre></div></div>

<p>Redis master 를 강제로 종료시키고 HAProxy UI화면을 refresh하면 master/slave정보가 변경된 것을 확인할 수 있습니다.
redis-cli를 사용해 slave에 연결해서 계속해서 조회가 가능합니다.</p>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/22">5분 안에 구축하는 Redis-Sentinel + HAProxy</a>
<a href="https://engineeringcode.tistory.com/125">공학코드 연구노트</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.]]></summary></entry></feed>