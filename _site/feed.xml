<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-19T21:40:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Jenkins-Prometheus/Grafana 설치</title><link href="http://localhost:4000/devops/jenkins-with-grafana/" rel="alternate" type="text/html" title="Jenkins-Prometheus/Grafana 설치" /><published>2023-02-19T00:00:00+09:00</published><updated>2023-02-19T00:00:00+09:00</updated><id>http://localhost:4000/devops/jenkins%20with%20grafana</id><content type="html" xml:base="http://localhost:4000/devops/jenkins-with-grafana/"><![CDATA[<h2 id="jenkins-와-prometheusgrafana-여녜">Jenkins 와 Prometheus/Grafana 여녜</h2>

<p>Jenkins Controller와 Agent를 를 모너터링하기 위해 Prometheus Plugin을 설치하고 Jenkins에서 수집한 
Metrics정보를 기반으로 Prometheus를 통해 Metrics 정보를 주시적으로 수집하고, 수집된 정보를 기반으로 Grafana에 Visual하게
모니터링합니다.</p>

<h2 id="prometheus-metrics-plugin-설치">Prometheus metrics plugin 설치</h2>

<p>Manage Jenkins &gt; Manage Plugins &gt; Available Plugins에서 Prometheus metrics Plugins을 선택, 
Install without restart를 클릭해서 Plugin을 설치합니다.</p>

<p><img src="/assets/images/jenkins/01-prometheus-plugin.png" alt="gitlab-ce" /></p>

<h2 id="prometheus-설정">Prometheus 설정</h2>
<p>prometheus.yml 파일을 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>global:
  scrape_interval:     15s <span class="c"># By default, scrape targets every 15 seconds.</span>
  evaluation_interval: 15s
  scrape_timeout:      10s

  <span class="c"># Attach these labels to any time series or alerts when communicating with</span>
  <span class="c"># external systems (federation, remote storage, Alertmanager).</span>
  external_labels:
    monitor: <span class="s1">'codelab-monitor'</span>

<span class="c"># A scrape configuration containing exactly one endpoint to scrape:</span>
<span class="c"># Here it's Prometheus itself.</span>
scrape_configs:
  <span class="c"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span>
  - job_name: <span class="s1">'prometheus'</span>

    <span class="c"># Override the global default and scrape targets from this job every 5 seconds.</span>
    scrape_interval: 5s

    static_configs:
      - targets: <span class="o">[</span><span class="s1">'localhost:9090'</span><span class="o">]</span>
  - job_name: <span class="s1">'jenkins'</span>
    metrics_path: /prometheus/
    static_configs:
      - targets: <span class="o">[</span><span class="s1">'Your-JenkinsIP:8080'</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="prometheusgrafana-설정">Prometheus/Grafana 설정</h2>
<p>Prometheus/Grafana 폴더를 binding하기 위해 폴더를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> prometheus grafana/provisioning grafana/volume
</code></pre></div></div>
<p>grafana.ini 파일을 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app_mode <span class="o">=</span> production
instance_name <span class="o">=</span> virtualserver01.HyukSeoung-Choi-s-Account.cloud

<span class="c">#################################### Server ########################</span>
protocol <span class="o">=</span> http
http_addr <span class="o">=</span>
http_port <span class="o">=</span> 3000

<span class="c">#################################### Database #######################</span>
<span class="o">[</span>database]
<span class="nb">type</span> <span class="o">=</span> mysql
host <span class="o">=</span> db:3306
name <span class="o">=</span> grafana
user <span class="o">=</span> grafana
password <span class="o">=</span> grafana


<span class="c">#################################### Logging ########################</span>
<span class="o">[</span>log]
mode <span class="o">=</span> console
level <span class="o">=</span> info

<span class="c">#################################### Alerting ########################</span>
<span class="o">[</span>alerting]
enabled <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p><img src="/assets/images/jenkins/02-prometheus-folder.png" alt="gitlab-ce" /></p>

<h2 id="prometheusgrafana-작성">Prometheus/Grafana 작성</h2>
<p>Prometheus/Grafana docker-compose 파일을 작성합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.9"</span>

<span class="na">networks</span><span class="pi">:</span>
  <span class="na">monitering</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">mysql-data</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">grafana-data</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">prometheus-data</span><span class="pi">:</span> <span class="pi">{}</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">mysql</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:5.7</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">grafana</span>
      <span class="na">MYSQL_DATABASE</span><span class="pi">:</span> <span class="s">grafana</span>
      <span class="na">MYSQL_USER</span><span class="pi">:</span> <span class="s">grafana</span>
      <span class="na">MYSQL_PASSWORD</span><span class="pi">:</span> <span class="s">grafana</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mysql-data:/var/lib/mysql</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">monitering</span>
    <span class="na">logging</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s2">"</span><span class="s">json-file"</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">max-size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">8m"</span>
        <span class="na">max-file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">10"</span>

  <span class="na">node-exporter</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">prom/node-exporter:latest</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">node-exporter</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/proc:/host/proc:ro</span>
      <span class="pi">-</span> <span class="s">/sys:/host/sys:ro</span>
      <span class="pi">-</span> <span class="s">/:/rootfs:ro</span>
    <span class="na">command</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--path.procfs=/host/proc'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--path.rootfs=/rootfs'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--path.sysfs=/host/sys'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)'</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">9100:9100"</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">monitering</span>

  <span class="na">prometheus</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">prom/prometheus:latest</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">prometheus</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml</span>
      <span class="pi">-</span> <span class="s">prometheus-data:/prometheus</span>
    <span class="na">command</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--config.file=/etc/prometheus/prometheus.yml'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--storage.tsdb.path=/prometheus'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--web.console.libraries=/etc/prometheus/console_libraries'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--web.console.templates=/etc/prometheus/consoles'</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">--web.enable-lifecycle'</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">9090:9090"</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">monitering</span>

  <span class="na">grafana</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">grafana</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">grafana/grafana</span>
    <span class="na">user</span><span class="pi">:</span> <span class="s2">"</span><span class="s">104"</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3000:3000"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./grafana/grafana.ini:/etc/grafana/grafana.ini:ro</span>
      <span class="pi">-</span> <span class="s">grafana-data:/var/lib/grafana</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">prometheus</span>
      <span class="pi">-</span> <span class="s">db</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">monitering</span>
    <span class="na">logging</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s2">"</span><span class="s">json-file"</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">max-size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">8m"</span>
        <span class="na">max-file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">10"</span>
</code></pre></div></div>

<h2 id="prometheusgrafana-실행">Prometheus/Grafana 실행</h2>
<p>docker-compose.yaml 파일이 있는 폴더에서  docker-compose를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><category term="prometheus" /><category term="grafana" /><summary type="html"><![CDATA[Jenkins 와 Prometheus/Grafana 여녜]]></summary></entry><entry><title type="html">Jenkins-Grafana 설정</title><link href="http://localhost:4000/devops/grafana-setup/" rel="alternate" type="text/html" title="Jenkins-Grafana 설정" /><published>2023-02-19T00:00:00+09:00</published><updated>2023-02-19T00:00:00+09:00</updated><id>http://localhost:4000/devops/grafana%20setup</id><content type="html" xml:base="http://localhost:4000/devops/grafana-setup/"><![CDATA[<h2 id="grafana-로그인">Grafana 로그인</h2>
<p>Grafana에 로그인하고, 비밀번호를 변경합니다.<br />
<img src="/assets/images/jenkins/03-grafana-login.png" alt="gitlab-ce" /></p>

<h2 id="prometheus-설정">Prometheus 설정</h2>
<p>Grafana에 로그인하면 다음과 같이 화면이 출력됩니다.<br />
<img src="/assets/images/jenkins/04-grafana-first.png" alt="gitlab-ce" /></p>

<p>설정을 선택하고, Grafana에 datasource를 추가하기 위해 Add data source를 클릭합니다.<br />
<img src="/assets/images/jenkins/05-grafana-add-datasource.png" alt="gitlab-ce" /></p>

<p>Prometheus datasource를 선택합니다.<br />
<img src="/assets/images/jenkins/06-grafana-prometheus-datasource.png" alt="gitlab-ce" /></p>

<p>Prometheus datasource를 설정합니다.<br />
<img src="/assets/images/jenkins/06-grafana-prometheus-setting.png" alt="gitlab-ce" /></p>

<p>Prometheus save-test 버튼을 클릭하면 Data source is working 메시지를 출력됩니다.<br />
![gitlab-ce](/assets/images/jenkins/07-grafana-prometheus-save-test.png</p>

<h2 id="jenkins-dashboard-선택">Jenkins dashboard 선택</h2>

<p><a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a> 에서 download jenkins dashboard를 선택합니다.</p>

<p><img src="/assets/images/jenkins/08-grafana-select-dashboard.png" alt="gitlab-ce" /></p>

<p>Jenkins Dashbaord Id를 clipboard에 복사합니다.<br />
<img src="/assets/images/jenkins/09-grafana-copy-clipboard.png" alt="gitlab-ce" /></p>

<p>Grafana에 Jenkins Dashboard ID를 반입합니다.<br />
<img src="/assets/images/jenkins/10-grafana-import-id.png" alt="gitlab-ce" /></p>

<p>Dashboard ID를 load합니다.<br />
<img src="/assets/images/jenkins/11-grafana-load.png" alt="gitlab-ce" /></p>

<p>Dashboard ID를 load합니다.<br />
<img src="/assets/images/jenkins/11-grafana-load.png" alt="gitlab-ce" /></p>

<p>Prometheus 항목에서 Prometheus-jenkins를 선택하고 import 버튼을 클릭합니다.<br />
<img src="/assets/images/jenkins/12-grafana-import-prometheus.png" alt="gitlab-ce" /></p>

<p>Jenkins Dashboard가 import 된 화면이 출력됩니다.<br />
<img src="/assets/images/jenkins/12-grafana-import-prometheus.png" alt="gitlab-ce" /></p>

<p>Jenkins Dashboard 첫 화면이 출력됩니다.<br />
<img src="/assets/images/jenkins/13-grafana-first-logon.png" alt="gitlab-ce" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><category term="prometheus" /><category term="grafana" /><summary type="html"><![CDATA[Grafana 로그인 Grafana에 로그인하고, 비밀번호를 변경합니다.]]></summary></entry><entry><title type="html">Helm 설치</title><link href="http://localhost:4000/kubernetes/install-helm/" rel="alternate" type="text/html" title="Helm 설치" /><published>2023-02-18T00:00:00+09:00</published><updated>2023-02-18T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/install%20helm</id><content type="html" xml:base="http://localhost:4000/kubernetes/install-helm/"><![CDATA[<h2 id="helm-cli를--설치">Helm CLI를  설치</h2>
<p>Helm Chart를 설치하기 위해 Helm CLI를 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> curl <span class="nt">-fsSL</span> <span class="nt">-o</span> get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
<span class="nb">chmod </span>700 get_helm.sh
./get_helm.sh
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="helm" /><category term="헬치" /><summary type="html"><![CDATA[Helm CLI를 설치 Helm Chart를 설치하기 위해 Helm CLI를 설치합니다. curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh]]></summary></entry><entry><title type="html">Jenkins master/slave 구성</title><link href="http://localhost:4000/devops/jenkins-controller-and-agent/" rel="alternate" type="text/html" title="Jenkins master/slave 구성" /><published>2023-02-18T00:00:00+09:00</published><updated>2023-02-18T00:00:00+09:00</updated><id>http://localhost:4000/devops/jenkins%20controller%20and%20agent</id><content type="html" xml:base="http://localhost:4000/devops/jenkins-controller-and-agent/"><![CDATA[<h2 id="jenkins-설치">Jenkins 설치</h2>

<p>Jenkins Master/Slave는 Controller/Agent로 명칭을 수정해서 글을 post합니다.</p>

<p><a href="https://yoonjk.github.io/devops/setup-jenkins/">Jenkins 설치 따라하기</a>를 참조해서 Jenkins를 설치합니다.</p>

<h2 id="jenkins-agent-개요">Jenkins Agent 개요</h2>

<p>Jenkins Pipeline을 remote Node에서 실행할 Agent를 추가합니다.<br />
Jenkins Agent는 다음과 같이 유형의 Agent가 있습니다.</p>

<ul>
  <li>Server 기반의 Agent</li>
  <li>Docker Container</li>
  <li>Kubernetes Dynamic Pod Agent</li>
</ul>

<p>Server 기반 Agent도 JNLP 기반 Agent와 ssh 기반 Agent가 있습니다.
JNLP기반 Agent는 분산된 서버에 agent.jar를 설치하고, 
java agent를 실행하고 Jenkins Master(Controller)와 연될되어 Pipeline을 실행합니다.</p>

<p>Docker Container 기반 Agent는 선언형 Pipeline에서 각 stage별로 적합한 container를 설정하여 docker를 실행합니다.</p>

<p>Dynmaic Kubernetes Pod Agent는 pipeline을 Kubernetes cluster에 Pod로 실행하고, 종료되면 Pod가 소별하는 방식입니다.</p>

<h2 id="jenkins-agent-node">Jenkins Agent Node</h2>
<p>Agent Node에 jenkins 계정을 생성하고, jenkins 패스워드를 지정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useradd jenkins
su - jenkins
<span class="nb">mkdir</span> <span class="nt">-p</span> .ssh
<span class="nb">exit
</span>passwd jenkins
</code></pre></div></div>

<h2 id="jenkins-controller-node">Jenkins Controller Node</h2>
<p>Jenkins Controller에서 인증서를 생성합니다.  <br />
<img src="/assets/images/jenkins/22-jenkins-master-agent.png" alt="New Node" /></p>

<p>공개 키를 Agent Node에 복사합니다.
Are you sure you want to continue connecting (yes/no)? yes를 입력합니다.<br />
Agent Node에서 ~/.ssh 폴더에 authorized_keys 파일이 생성된 것을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp  ~/.ssh/id_rsa.pub jenkins@Your-AgentNodeIP:/home/jenkins/.ssh/authorized_keys
</code></pre></div></div>
<p><img src="/assets/images/jenkins/22-jenkins-scp-credentials.png" alt="New Node" /></p>

<h2 id="jenkins-agent-node-1">Jenkins Agent Node</h2>
<p>Agent Node에서 .ssh 폴더와 authorized_keys의 접근권한을 설정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>700 .ssh
<span class="nb">chmod </span>644 ~/.ssh/authorized_keys
</code></pre></div></div>
<h2 id="jenkins-controller-node-1">Jenkins Controller Node</h2>
<p>Jenkins Controller Node에서 ssh로 Jenkins Agent로 접속하여 비밀번호를 없이 접속되는지 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh jenkins@Your-Jenkins-AgentIP
</code></pre></div></div>

<p><img src="/assets/images/jenkins/22-jenkins-ssh-connect.png" alt="New Node" /></p>

<h2 id="agent-환경구성">Agent 환경구성</h2>

<p>Manage Jenkins를 선택하고, Manage Nodes and Clouds를 선택<br />
<img src="/assets/images/jenkins/23-jenkins-manage-nodes-clouds.png" alt="New Node" /></p>

<p>New Node를 선택합니다.<br />
<img src="/assets/images/jenkins/24-jenkins-new-agent.png" alt="New Node" /></p>

<p>Agent에 name, label agent root directory를 설정합니다.
Number of executors는 Agent의 vcpu 개수만큼 지정합니다.    <br />
<img src="/assets/images/jenkins/25-jenkins-agent-root-dir.png" alt="New Node" /></p>

<p>Agent Node IP 설정 및 ssh로 접속하기 위해 credentials을 설정합니다.<br />
<img src="/assets/images/jenkins/24-jenkins-launch-method.png" alt="New Node" /></p>

<p>Add credentials을 선택합니다.<br />
<img src="/assets/images/jenkins/26-jenkins-add-credentials.png" alt="New Node" /></p>

<p>Kind 선택항목에서 username with private key 를 선택하고, ID, Description, username을 설정합니다.<br />
<img src="/assets/images/jenkins/28-jenkins-username-with-private-key.png" alt="New Node" /></p>

<p>Private Key 항목에서 Enter directly를 선택하고, Add 버튼을 클릭합니다. <br />
<img src="/assets/images/jenkins/27-jenkins-private-key-enter-directly.png" alt="New Node" /></p>

<p>Jenkins Controller Node에서 생성한 private key 인증서의 내용을 복사하여 붙여넣기하고 저장합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> ~/.ssh/id_rsa
</code></pre></div></div>
<p>Jenkins Controller Node에서  ~/.ssh/id_rsa 인증서 내용을 복사합니다.<br />
<img src="/assets/images/jenkins/29-jenkins-copy-id_rsa.png" alt="New Node" /></p>

<p>id_rsa 인증서 내용을 붙여넣기하고 Add버튼클 클릭합니다.<br />
<img src="/assets/images/jenkins/29-jenkins-paste-private-key-and-save.png" alt="New Node" /></p>

<p>Jenkins Agent에서 Credentials을 선택하고, Host Key Verification Strategy 에서 Manually trusted key Verification Strategy를 선택하고, 저장버튼을 클릭합니다.<br />
<img src="/assets/images/jenkins/30-jenkins-select-credentials.png" alt="New Node" /></p>

<p>Jenkins Controller 인 Built-in-Node를 선택해서 Number of executors의 항목을 0으로 설정하고 저장합니다.</p>

<p><img src="/assets/images/jenkins/31-jenkins-build-in-node.png" alt="New Node" /></p>

<p>Manage Jenkins &gt; Global Tool Configuration에서 Maven installations 세션에서 
maven을 다음과 같이 추가합니다.<br />
<img src="/assets/images/jenkins/32-jenkins-global-tool-config-maven.png" alt="New Node" /></p>

<p>Manage Jenkins &gt; Manage Nodes and Clouds &gt; linux agent를 선택
Configure 를 선택해서 Node Properties 섹션에서 maven을 설정하고 저장합니다. <br />
<img src="/assets/images/jenkins/33-jenkins-linux-agent-tool-location.png" alt="New Node" /></p>

<p>Jenkins Agent Node에서 다음의 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>sysctl user.max_user_namespaces<span class="o">=</span>15000
</code></pre></div></div>
<p><img src="/assets/images/jenkins/34-jenkins-max_user_namespace.png" alt="New Node" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><category term="master" /><category term="slave" /><summary type="html"><![CDATA[Jenkins 설치]]></summary></entry><entry><title type="html">podman에서 max_user_namespaces 에러</title><link href="http://localhost:4000/devops/podman-max_user_namespaces/" rel="alternate" type="text/html" title="podman에서 max_user_namespaces 에러" /><published>2023-02-18T00:00:00+09:00</published><updated>2023-02-18T00:00:00+09:00</updated><id>http://localhost:4000/devops/podman-max_user_namespaces</id><content type="html" xml:base="http://localhost:4000/devops/podman-max_user_namespaces/"><![CDATA[<h2 id="podman-실행시-다음의-에러-해결">podman 실행시 다음의 에러 해결</h2>

<p>Podman run error in non-root mode: “user namespaces are not enabled in /proc/sys/user/max_user_namespaces”</p>

<p>Jenkins Pipeline에서 podman 실행시 다음의 에러가 발생할 떄</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user namespaces are not enabled <span class="k">in</span> /proc/sys/user/max_user_namespaces
Error: could not get runtime: cannot re-exec process
</code></pre></div></div>
<p>다음의 <a href="https://github.com/containers/podman/issues/7704">링크</a>를 참조합니다.</p>

<p><a href="https://github.com/containers/podman/issues/7704">https://github.com/containers/podman/issues/7704</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><category term="podman" /><summary type="html"><![CDATA[podman 실행시 다음의 에러 해결]]></summary></entry><entry><title type="html">kind 에 dashboard 설치하기</title><link href="http://localhost:4000/kubernetes/install-dashboard-for-kind/" rel="alternate" type="text/html" title="kind 에 dashboard 설치하기" /><published>2023-02-15T00:00:00+09:00</published><updated>2023-02-15T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/install%20dashboard%20for%20kind</id><content type="html" xml:base="http://localhost:4000/kubernetes/install-dashboard-for-kind/"><![CDATA[<h2 id="dashboard-설치">Dashboard 설치</h2>
<p>kind를 사용하여 Kubernetes cluster를 구성하고 dashboard를 구성합니다.
dashboard는 다음과 같이 remote에 있는 yaml을 직접적용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
</code></pre></div></div>

<h2 id="port-forward로-port-오픈">port-forward로 port 오픈</h2>
<p>port-forward를 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward svc/kubernetes-dashboard <span class="nt">-n</span> kubernetes-dashboard  443 <span class="nt">--address</span> 0.0.0.0
</code></pre></div></div>
<p>chrome 중앙의 to get chrome’s 를 클릭하고 thisisunsafe를 입력하고 enter를 누릅니다.</p>

<p><img src="/assets/images/k8s/03-k8s-yourconnection-is-not-private.png" alt="port-forward" /></p>

<p>그러면 다음과 가이 dashboard 로그인 화면이 나타납니다.<br />
<img src="/assets/images/k8s/04-k8s-kubernetes-dashboard.png" alt="port-forward" /></p>

<h2 id="create-serviceaccount-and-role-token">Create serviceaccount and role, token</h2>
<p>kubernetes dashboard를 위한 serviceaccount와 cluster-role를 생성한 다음 token을 생성합니다. 그리고 생성한 token 값을 
dashboard login token 입력항목에 붙여넣기를 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create sa dashboard-admin <span class="nt">-n</span> kubernetes-dashboard
kubectl create clusterrolebinding dashbaord-admin <span class="nt">--clusterrole</span> admin <span class="nt">--serviceaccount</span> kubernetes-dashboard:dashboard-admin
kubectl create token dashboard-admin <span class="nt">-n</span> kubernetes-dashboard

<span class="o">[</span>수행결과]
eyJhbGciOiJSUzI1NiIsImtpZCI6IjcxeDlkdFlKOVhLZjRXOFdfNzVmLTZpUFVLOUtvQVM5M0RUMlMxcVBtblEifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc2NDkzNzA3LCJpYXQiOjE2NzY0OTAxMDcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJkYXNoYm9hcmQtYWRtaW4iLCJ1aWQiOiIwNDdlM2RjYS03N2JiLTRmYzMtYTkzZS0yMjAwNWNkZDBkOWYifX0sIm5iZiI6MTY3NjQ5MDEwNywic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.uDhrySLj1sZgsRovMS7TqT4DuTipdhaa2n1uKDLnfGq_-JNwQma7S0qOuLY20FAXfIGceax_k_LY5js0SP0GFWHSrw8m2S2jOEeDXkcvEkBQVDXi5DY-bp6p_y2dI4CleUxauFgPXOwXTOu8Un1fOfgltMCvGBcf68qPjZ1pxrni5_HlPi_o9xjhmfbggUxEq8zx0n2H5j0ssVITM7jH38F6eO7rMPVHRBngMok2qqOydviQZ0994TPgq_NByKkWDk1npCXOvrt03z9X6I7Q5-k6yX8vVEZSKq9rbq0lAJQLKlpKlttTHz6YJf0YEQwgygcakDxKCRsCk07kgEXP2Q
</code></pre></div></div>
<p>token을 입력합니다.<br />
<img src="/assets/images/k8s/05-k8s-input-token-dashboard.png" alt="port-forward" /></p>

<p>dashboard 로그인 화면입니다.<br />
<img src="/assets/images/k8s/06-k8s-dashboard-login.png" alt="port-forward" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="kind" /><summary type="html"><![CDATA[Dashboard 설치 kind를 사용하여 Kubernetes cluster를 구성하고 dashboard를 구성합니다. dashboard는 다음과 같이 remote에 있는 yaml을 직접적용합니다. kubectl apply -f kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml]]></summary></entry><entry><title type="html">Nginx proxy 리모트 kind cluster 접근</title><link href="http://localhost:4000/kubernetes/access-a-remote-kind/" rel="alternate" type="text/html" title="Nginx proxy 리모트 kind cluster 접근" /><published>2023-02-15T00:00:00+09:00</published><updated>2023-02-15T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/access-a-remote-kind</id><content type="html" xml:base="http://localhost:4000/kubernetes/access-a-remote-kind/"><![CDATA[<h2 id="사전설치환경-구성">사전설치환경 구성</h2>
<p>kind를 구성하기 위해 docker를 설치합니다. docker engine 설치  blog posting을 확인하세요.</p>

<h2 id="setup--on-kind-cluster-server">Setup  on kind cluster server</h2>
<p>kind 로컬 머신에 VM을 생성하고 하나의 노드만 포함하는 경량의 클러스터를 배포하는 쿠버네티스 입니다. kind는 Linux, macOS 및 Windows 시스템에서 사용할 수 있습니다.</p>

<p>Kind가 작동하려면 하이퍼바이저(버추얼 박스 또는 KVM)가 필요하지만 이미 가상 머신 내부에 있는 경우 none 드라이버를 사용하여 추가 VM 계층 생성을 건너뛸 수 있습니다<br />
이번에는 VM에 Docker 엔진을 설치하고, 가상화 대신 도커를 사용하여 local server에서 remote kind cluster에 접근하는 구성합니다.</p>

<p>docker를 성공적으로 설치한 후 다음 명령을 사용하여 로컬 Kubernetes를 시작할 차례입니다.</p>

<p><a href="https://kind.sigs.k8s.io/docs/user/quick-start/">kind Quick 설치 가이드</a></p>

<p>Linux 환경에서 설치</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-Lo</span> ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64
<span class="nb">chmod</span> +x ./kind
<span class="nb">sudo mv</span> ./kind /usr/local/bin/kind
</code></pre></div></div>

<p>kind를 시작하기 위해 kind cluster config 파일을 다음과 같이 control-plane, 2개의 worker node로 구성된 cluster를 작성합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">Cluster</span>
<span class="na">networking</span><span class="pi">:</span>
  <span class="na">apiServerAddress</span><span class="pi">:</span> <span class="s2">"</span><span class="s">119.81.103.70"</span>
  <span class="na">apiServerPort</span><span class="pi">:</span> <span class="m">58350</span>
<span class="na">nodes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">control-plane</span>
  <span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
  <span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
</code></pre></div></div>

<p>kind cluster를 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kind create cluster <span class="nt">--config</span> jenkins-config.yaml
</code></pre></div></div>

<p>원격 호스트에서 실행되는 Kubernetes 클러스터가 있습니다. Kind는 홈 디렉토리의 .kube/ 디렉토리 안에 config 파일을 생성합니다.</p>

<p>kubernetes의 config 파일에는 다음의 내용이 있습니다.<br />
•	certificate-authority(인증 기관) - 사용자가 제어하는 CA(인증 기관)에서 서명한 TLS 인증서를 프로비저닝할 수 있는 API를 제공합니다. 이러한 CA 및 인증서는 워크로드에서 신뢰를 설정하는 데 사용할 수 있습니다.<br />
•	server - 파드, 서비스, 복제 컨트롤러 등을 포함하는 API 객체에 대한 데이터의 유효성을 검사하고 구성하는 쿠버네티스 API 서버의 주소이다.<br />
•	client-certificate -.쿠버네티스/미니큐브는 TLS를 통한 인증을 위해 PKI 인증서가 필요하다.<br />
•	client-key - 클라이언트 인증서와 일치하는 키입니다.</p>

<p>.kube/config에 들어있는 인증서 내용을 x509 형식으로 변환합니다.</p>
<ul>
  <li>client-certificate-data 데이터를 base64로 decoding</li>
  <li>client-key-data 데이터를 base64로 decode</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">cat</span> .kube/config

<span class="nv">ca_crt</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> .kube/config|grep certificate-authority-data|cut <span class="nt">-d</span><span class="s2">":"</span> <span class="nt">-f2-</span>|cut <span class="nt">-d</span><span class="s2">" "</span> <span class="nt">-f1-</span><span class="si">)</span>

<span class="nv">client_crt</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> .kube/config|grep client-certificate-data|cut <span class="nt">-d</span><span class="s2">":"</span> <span class="nt">-f2-</span>|cut <span class="nt">-d</span><span class="s2">" "</span> <span class="nt">-f1-</span><span class="si">)</span>

<span class="nv">client_key</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> .kube/config|grep client-key-data|cut <span class="nt">-d</span><span class="s2">":"</span> <span class="nt">-f2-</span>|cut <span class="nt">-d</span><span class="s2">" "</span> <span class="nt">-f1-</span><span class="si">)</span>

</code></pre></div></div>

<h1 id="convert-encoded-certificates-to-x509-format">convert encoded certificates to x509 format</h1>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kind
<span class="nb">echo</span> <span class="nv">$client_crt</span> | <span class="nb">base64</span> <span class="nt">-d</span> <span class="o">&gt;</span> .kind/client.crt
<span class="nb">echo</span> <span class="nv">$client_key</span> | <span class="nb">base64</span> <span class="nt">-d</span> <span class="o">&gt;</span> .kind/client.key
</code></pre></div></div>
<h2 id="install-nginx-for-reverse-proxy-on--kind-cluster-server">Install nginx for Reverse Proxy on  Kind Cluster server</h2>
<p>리모트에서 Kind에 접근하기 위해 reverse proxy를 구성합니다.</p>

<p>미니큐브 앞에 Nginx Reverse 프록시를 배포합니다.</p>

<p>쿠버네티스 API 서버는 커맨드 라인 도구 kubectl을 사용할 때 모든 요청이 전달되는 지점입니다. kubectl을 사용하면 쿠버네티스 클러스터에 대해 명령을 실행할 수 있다. 이 예에서 내 kube-apiserver의 주소는 https://Your-ServierIP:58350 Kind의 IP 주소입니다. Kind는 로컬에서만 액세스할 수 있으나, 원격으로 액세스할 수 없습니다. 이러한 이유로 Kind 옆에 Nginx 역방향 프록시를 배포하여 원격 클라이언트의 요청을 수신한 다음 kube-apiserver로 전달할 수 있도록 해야 합니다.</p>

<p>docker를 통해 배포하므로 마운트에 필요한 디렉토리와 파일을 만들어야합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/nginx/conf.d/ /etc/nginx/certs
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/nginx/conf.d/default.conf 
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;
    auth_basic "Administrator's Area";
    auth_basic_user_file /etc/nginx/.htpasswd;

    location / {
        proxy_pass https://Your-Kind-ServerIP:58443;
        proxy_ssl_certificate /etc/nginx/certs/kind-client.crt;
        proxy_ssl_certificate_key /etc/nginx/certs/kind-client.key;
    }
}
</span><span class="no">EOF
</span></code></pre></div></div>

<p>아직 사용자 이름/암호 쌍을 만들지 않았습니다. 이를 위해 htpasswd라는 cmd 도구를 사용합니다<br />
. 아직 설치하지 않은 경우 yum 을 통해 설치하십시오.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> httpd-tools 
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd kind-kind
</code></pre></div></div>

<p>Ubuntu 환경인 경우 htpasswd 유틸 설치</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get <span class="nb">install </span>apache2-utils <span class="nt">-y</span>
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd kind-kind
</code></pre></div></div>
<p>이제 사용자이름/암호가 /etc/nginx/.htpasswd 파일에 저장됩니다. 필요한 구성 파일이 이미 있으므로 다음 명령을 사용하여 Nginx를 배포 할 준비가 되었습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="se">\</span>
<span class="nt">--name</span> nginx <span class="se">\</span>
<span class="nt">--network</span> kind <span class="se">\</span>
<span class="nt">-p</span> 9080:80 <span class="se">\</span>
<span class="nt">-v</span> /root/.kind/client.key:/etc/nginx/certs/kind-client.key <span class="se">\</span>
<span class="nt">-v</span> /root/.kind/client.crt:/etc/nginx/certs/kind-client.crt <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/conf.d/:/etc/nginx/conf.d <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/.htpasswd:/etc/nginx/.htpasswd <span class="se">\</span>
nginx
</code></pre></div></div>

<p>브라우저에서 Nginx에 요청하려고 하면 사용자 이름과 비밀번호가 필요하다는 다음 팝업 창이 나타납니다. 브라우저에서 페이지를 열려면 다음 주소로 이동하십시오</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;YOUR_SERVER_IP&gt;:9080  
</code></pre></div></div>

<h2 id="install-kubectl-on-local-computer">Install kubectl on local computer</h2>

<p>Kind에 접속할려는 서버에 kubectl 를 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>curl <span class="nt">-L</span> <span class="s2">"https://dl.k8s.io/release/</span><span class="si">$(</span>curl <span class="nt">-L</span> <span class="nt">-s</span> https://dl.k8s.io/release/stable.txt<span class="si">)</span><span class="s2">/bin/linux/amd64/kubectl"</span> <span class="nt">-o</span> /usr/local/bin/kubectl

<span class="nb">sudo chmod</span> +x /usr/local/bin/kubectl
</code></pre></div></div>

<p>이미 kubectl이 설치되어 있으므로이 단계를 건너 뜁니다.<br />
이제 미니큐브에 대한 kubectl을 구성해야 한다. 원격 호스트에서 구성 파일의 내용을 복사하고(Img.3 참조) 로컬 server 붙여넣습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.kube/  <span class="c"># execute on local computer</span>
</code></pre></div></div>

<p>아래 이미지에는 변경해야 할 강조 표시된 줄이 있습니다.<br />
remote 서버에 있는 config 파일을 복사하고 강조 표시된 부분을 수정합니다.<br />
ENTER_YOUR_PASSWORD_HERE : remote 서버에서 설정한 kind-kind 비밀번호<br />
YOUR_SERVER_IP : remote 서버<br />
•	certificate-authority , client-certificate , and client-key</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://kind-kind:&lt;ENTER_YOUR_PASSWORD_HERE&gt;@&lt;YOUR_SERVER_IP&gt;:9080
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF &gt; .kube/config</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">clusters</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">cluster</span><span class="pi">:</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">http://kind-kind:admin1234@@Your-KindClusterServerIP:9080</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kind-kind</span>
<span class="na">contexts</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">context</span><span class="pi">:</span>
    <span class="na">cluster</span><span class="pi">:</span> <span class="s">kind-kind</span>
    <span class="na">user</span><span class="pi">:</span> <span class="s">kind-kind</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kind-kind</span>
<span class="na">current-context</span><span class="pi">:</span> <span class="s">kind-kind</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Config</span>
<span class="na">preferences</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">users</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kind-kind</span>
  <span class="na">user</span><span class="pi">:</span>
<span class="s">EOF</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="kind" /><summary type="html"><![CDATA[사전설치환경 구성 kind를 구성하기 위해 docker를 설치합니다. docker engine 설치 blog posting을 확인하세요.]]></summary></entry><entry><title type="html">Install kind for Jenkins</title><link href="http://localhost:4000/kubernetes/install-kind/" rel="alternate" type="text/html" title="Install kind for Jenkins" /><published>2023-02-12T00:00:00+09:00</published><updated>2023-02-12T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/install-kind</id><content type="html" xml:base="http://localhost:4000/kubernetes/install-kind/"><![CDATA[<h2 id="pre-requisites--install-docker-engine">Pre-requisites : Install docker engine</h2>
<p>docker engine 설치는 docker engine 설치 글을 참조해 주세요.</p>

<h2 id="step-1--download-kind-binary">Step 1 : Download kind binary</h2>
<p>kind binary를 download 받습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-Lo</span> ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64
<span class="nb">chmod</span> +x ./kind
<span class="nb">sudo mv</span> ./kind /usr/local/bin/kind
</code></pre></div></div>

<h2 id="step-2--config-파일-작성성">Step 2 : config 파일 작성성</h2>

<p>Kind를 이용하여 Kubernetes Cluster를 생성하기 위해 jenkins-config.yaml 파일을 아래와 같이 작성합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kind.x-k8s.io/v1alpha4</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Cluster</span>
<span class="na">nodes</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">control-plane</span>
<span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
<span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
</code></pre></div></div>

<h2 id="step-3--create-cluster">Step 3 : Create Cluster</h2>
<p>Cluster를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kind create cluster <span class="nt">--config</span> jenkins-config.yaml
</code></pre></div></div>

<p><img src="/assets/images/k8s/02-k8s-kind-create-cluster.png" alt="kube-dashboard" /></p>

<h2 id="step-4--configure">Step 4 : Configure</h2>
<p>Kind는 .kube/config파일 변경 없이 인증서 파일의 내용이 config파일에 있어서 변환할 필요는 없습니다.<br />
minikube와 동일하게 Jenkins를 설정합니다.</p>
<ul>
  <li>Install Kubernetes Plugins</li>
  <li>Manage Jenkins &gt; Manage Nodes and Clouds &gt; Configure Clouds</li>
</ul>

<h2 id="step-4--kubernetes-dashboard-설치">Step 4 : Kubernetes Dashboard 설치</h2>

<p>Kubernetes dashboard yaml파일을 remote에 있는 것을 직접 kubernetes cluster에 적용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml
</code></pre></div></div>

<h2 id="step-5--kubernetes-dashboard-접속">Step 5 : Kubernetes Dashboard 접속</h2>
<p>kubectl proxy로 8001 port를 다음과 같이 오픈합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward svc/kubernetes-dashboard <span class="nt">-n</span> kubernetes-dashboard 443:443 <span class="nt">--address</span> 0.0.0.0
</code></pre></div></div>

<p>브라우저에서 dashboard에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://Your-Server-IP/
</code></pre></div></div>

<p><img src="/assets/images/k8s/04-k8s-kubernetes-dashboard.png" alt="kube-dashboard" /></p>

<h2 id="step-6--token-생성">Step 6 : Token 생성</h2>
<ul>
  <li>kubernetes-dashboard namespace에 admin-user Serviceaccount를 생성
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create sa admin-user <span class="nt">-n</span> kubernetes-dashboard
</code></pre></div>    </div>
  </li>
  <li>cluster-admin을 clusterrolebinding합니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create clusterrolebinding admin <span class="nt">--clusterrole</span> cluster-admin <span class="nt">--serviceaccount</span> kubernetes-dashboard:admin-user
</code></pre></div>    </div>
  </li>
  <li>token을 생성
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create token admin-user <span class="nt">-n</span> kuberneetes-dashboard
<span class="c"># [수행결과] </span>
eyJhbGciOiJSUzI1NiIsImtpZCI6ImgxSUxfYzA4Zk54TFdRNF9pdDY3VFgtall1N1M5b1BPMFp2c3JXRVFodFUifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc2Mjk2MDE3LCJpYXQiOjE2NzYyOTI0MTcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiNTAwNGUwMDYtMTNjYy00YWYwLWE2MWEtZjFmYWJiMjczNzBhIn19LCJuYmYiOjE2NzYyOTI0MTcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.AVfEFQBnSHW4DQR3Iyf15-BRMDdIAloSkC1BGpUaK-gLVHt-5EB72EK9XX1TK675-DClXEHbNTgEHey_ViP68JPTr99B3mRLy5KXD8gOxjueRMSvQbHo-le85j-DwIOu3TfE9Zyo7NlkGVglU61IBylIfZbg7Sh1TeYpoD6qmTAub6EVWMw1m5OGThBRd7Da6WMd1nI0MMlrT8hGUkCPml3F-x4ExNETjukTfhQTbz0HwRg-jVkad9QwFuCN9_uGuUvw4QUPeZ04hdccADP7fwbd7r4U0Jx2YANVZYNefbmSRl3M4s_Lu5aVxZ4PdcTFR04yiZBQ1C911lluT6hOGw
</code></pre></div>    </div>
  </li>
</ul>

<p>생성한 token을 dashboard token 입력항목에 붙여넣기 합니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="kind" /><summary type="html"><![CDATA[Pre-requisites : Install docker engine docker engine 설치는 docker engine 설치 글을 참조해 주세요.]]></summary></entry><entry><title type="html">Nginx proxy로 리모트 Minikube 연결</title><link href="http://localhost:4000/kubernetes/access-a-remote-minikube/" rel="alternate" type="text/html" title="Nginx proxy로 리모트 Minikube 연결" /><published>2023-02-11T00:00:00+09:00</published><updated>2023-02-11T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/access-a-remote-minikube</id><content type="html" xml:base="http://localhost:4000/kubernetes/access-a-remote-minikube/"><![CDATA[<h2 id="setup-minikube-on-minikube-server">Setup Minikube on minikube server</h2>

<p>Minikube는 로컬 머신에 VM을 생성하고 하나의 노드만 포함하는 경량의 클러스터를 배포하는 쿠버네티스 입니다. Minikube는 Linux, macOS 및 Windows 시스템에서 사용할 수 있습니다.</p>

<p>Minikube가 작동하려면 하이퍼바이저(버추얼 박스 또는 KVM)가 필요하지만 이미 가상 머신 내부에 있는 경우 none 드라이버를 사용하여 추가 VM 계층 생성을 건너뛸 수 있습니다<br />
이 경우  해당 VM에 Docker 엔진을 설치해야 합니다. 이는 가상화 대신 도커를 사용한다는 의미입니다 (버추얼 박스, VM웨어 퓨전, kvm2, VM웨어 등).</p>

<p>docker를 성공적으로 설치한 후 다음 명령을 사용하여 로컬 Kubernetes를 시작할 차례입니다.</p>

<p><img src="/assets/images/k8s/01-k8s-download-minikube.png" alt="download-minikube" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>curl <span class="nt">-LO</span> https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
<span class="nb">install </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="c"># 또는</span>
<span class="nb">sudo mv </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="nb">sudo chmod</span> +x /usr/local/bin/minikube
</code></pre></div></div>

<p>minikube를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube start <span class="nt">--driver</span><span class="o">=</span>docker
</code></pre></div></div>

<p>원격 호스트에서 실행되는 Kubernetes 클러스터가 있습니다. Minikube는 홈 디렉토리의 .kube/ 디렉토리 안에 config 파일을 생성합니다.</p>

<p>kubernetes의 config 파일에는 다음의 내용이 있습니다.<br />
•	certificate-authority(인증 기관) - 사용자가 제어하는 CA(인증 기관)에서 서명한 TLS 인증서를 프로비저닝할 수 있는 API를 제공합니다. 이러한 CA 및 인증서는 워크로드에서 신뢰를 설정하는 데 사용할 수 있습니다.<br />
•	server - 파드, 서비스, 복제 컨트롤러 등을 포함하는 API 객체에 대한 데이터의 유효성을 검사하고 구성하는 쿠버네티스 API 서버의 주소이다.<br />
•	client-certificate -.쿠버네티스/미니큐브는 TLS를 통한 인증을 위해 PKI 인증서가 필요하다.<br />
•	client-key - 클라이언트 인증서와 일치하는 키입니다.</p>

<p><img src="/assets/images/k8s/02-k8s-cat-kube-config.png" alt="start-minikube" /></p>

<h2 id="install-nginx-for-reverse-proxy-on-minikube-server">Install nginx for Reverse Proxy on minikube server</h2>
<p>리모트에서 minikube에 접근하기 위해 reverse proxy를 구성합니다.</p>

<p>미니큐브 앞에 Nginx Reverse 프록시를 배포합니다.</p>

<p>쿠버네티스 API 서버는 커맨드 라인 도구 kubectl을 사용할 때 모든 요청이 전달되는 지점입니다. kubectl을 사용하면 쿠버네티스 클러스터에 대해 명령을 실행할 수 있다. 이 예에서 내 kube-apiserver의 주소는 https://10.142.0.17:8443 여기서 10.142.0.17은  minikube의 IP 주소입니다. minikube는 로컬에서만 액세스할 수 있으나, 원격으로 액세스할 수 없습니다. 이러한 이유로 minikube 옆에 Nginx 역방향 프록시를 배포하여 원격 클라이언트의 요청을 수신한 다음 kube-apiserver로 전달할 수 있도록 해야 합니다.</p>

<p>docker를 통해 배포하므로 마운트에 필요한 디렉토리와 파일을 만들어야합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/nginx/conf.d/ /etc/nginx/certs
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/nginx/conf.d/minikube.conf 
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;
    auth_basic "Administrator’s Area";
    auth_basic_user_file /etc/nginx/.htpasswd;    
    
    location / {   
        proxy_pass https://`minikube ip`:8443;
        proxy_ssl_certificate /etc/nginx/certs/minikube-client.crt;
        proxy_ssl_certificate_key /etc/nginx/certs/minikube-client.key;
    }
}
</span><span class="no">EOF
</span></code></pre></div></div>

<p>아직 사용자 이름/암호 쌍을 만들지 않았습니다. 이를 위해 htpasswd라는 cmd 도구를 사용합니다<br />
. 아직 설치하지 않은 경우 yum 을 통해 설치하십시오.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> httpd-tools 
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd minikube
</code></pre></div></div>

<p>Ubuntu 환경인 경우 htpasswd 유틸 설치</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get <span class="nb">install </span>apache2-utils <span class="nt">-y</span>
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd minikube
</code></pre></div></div>
<p>이제 사용자이름/암호가 /etc/nginx/.htpasswd 파일에 저장됩니다. 필요한 구성 파일이 이미 있으므로 다음 명령을 사용하여 Nginx를 배포 할 준비가 되었습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="se">\</span>
<span class="nt">--name</span> nginx <span class="se">\</span>
<span class="nt">--network</span> minikube <span class="se">\</span>
<span class="nt">-p</span> 9080:80 <span class="se">\</span>
<span class="nt">-v</span> /root/.minikube/profiles/minikube/client.key:/etc/nginx/certs/minikube-client.key <span class="se">\</span>
<span class="nt">-v</span> /root/.minikube/profiles/minikube/client.crt:/etc/nginx/certs/minikube-client.crt <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/conf.d/:/etc/nginx/conf.d <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/.htpasswd:/etc/nginx/.htpasswd <span class="se">\</span>
nginx
</code></pre></div></div>

<p>브라우저에서 Nginx에 요청하려고 하면 사용자 이름과 비밀번호가 필요하다는 다음 팝업 창이 나타납니다. 브라우저에서 페이지를 열려면 다음 주소로 이동하십시오</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;YOUR_SERVER_IP&gt;:9080  
</code></pre></div></div>

<h2 id="install-kubectl-on-local-computer">Install kubectl on local computer</h2>

<p>minikube에 접속할려는 서버에 kubectl 를 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>curl <span class="nt">-L</span> <span class="s2">"https://dl.k8s.io/release/</span><span class="si">$(</span>curl <span class="nt">-L</span> <span class="nt">-s</span> https://dl.k8s.io/release/stable.txt<span class="si">)</span><span class="s2">/bin/linux/amd64/kubectl"</span> <span class="nt">-o</span> /usr/local/bin/kubectl

<span class="nb">sudo chmod</span> +x /usr/local/bin/kubectl
</code></pre></div></div>

<p>이미 kubectl이 설치되어 있으므로이 단계를 건너 뜁니다.<br />
이제 미니큐브에 대한 kubectl을 구성해야 한다. 원격 호스트에서 구성 파일의 내용을 복사하고(Img.3 참조) 로컬 server 붙여넣습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.kube/  <span class="c"># execute on local computer</span>
</code></pre></div></div>

<p>아래 이미지에는 변경해야 할 강조 표시된 줄이 있습니다.<br />
remote 서버에 있는 config 파일을 복사하고 강조 표시된 부분을 수정합니다.<br />
ENTER_YOUR_PASSWORD_HERE : remote 서버에서 설정한 minikube 비밀번호<br />
YOUR_SERVER_IP : remote 서버<br />
•	certificate-authority , client-certificate , and client-key</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://minikube:&lt;ENTER_YOUR_PASSWORD_HERE&gt;@&lt;YOUR_SERVER_IP&gt;:9080
</code></pre></div></div>

<p><img src="/assets/images/k8s/03-k8s-local-kube-config.png" alt="kube-config-minikube" /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF &gt; .kube/config</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">clusters</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">cluster</span><span class="pi">:</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">http://minikube:admin1234@@119.81.106.194:9080</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">minikube</span>
<span class="na">contexts</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">context</span><span class="pi">:</span>
    <span class="na">cluster</span><span class="pi">:</span> <span class="s">minikube</span>
    <span class="na">user</span><span class="pi">:</span> <span class="s">minikube</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">minikube</span>
<span class="na">current-context</span><span class="pi">:</span> <span class="s">minikube</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Config</span>
<span class="na">preferences</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">users</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">minikube</span>
  <span class="na">user</span><span class="pi">:</span>
<span class="s">EOF</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="minikube" /><summary type="html"><![CDATA[Setup Minikube on minikube server]]></summary></entry><entry><title type="html">Tekton 설치</title><link href="http://localhost:4000/devops/tekton-installation/" rel="alternate" type="text/html" title="Tekton 설치" /><published>2023-02-05T00:00:00+09:00</published><updated>2023-02-05T00:00:00+09:00</updated><id>http://localhost:4000/devops/tekton-installation</id><content type="html" xml:base="http://localhost:4000/devops/tekton-installation/"><![CDATA[<h2 id="tekton-설치">Tekton 설치</h2>
<p>Tekton pipeline을 Kubernetes에 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">--filename</span> https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
</code></pre></div></div>

<p>터미널 화면을 신규로 더 실행하여, 신규 터미널에서 tekton pipeline 설치를 확인하기 위해 다음의 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">--namespace</span> tekton-pipelines <span class="nt">-w</span>
</code></pre></div></div>
<h4 id="tekton-dashboard-설치">Tekton dashboard 설치</h4>

<p>tekton pipeline, task를 실행되는 WEB UI를 통해 보고자 하는 경우 tekton dashboard를 활용하여 현재 설치되어 있는 pipeline, task, 실행결과를 확인 할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">--filename</span> https://storage.googleapis.com/tekton-releases/dashboard/latest/release.yaml
</code></pre></div></div>

<p>tekton dashboard 설치를 확인하기 위해 다음의 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">--namespace</span> tekton-pipelines <span class="nt">-w</span>
</code></pre></div></div>

<p>Tekton pipeline 설치에 대해 자세한 것은 아래의 <a href="https://tekton.dev/docs/pipelines/install/">링크</a>를 확인하세요.</p>

<p><a href="https://tekton.dev/docs/pipelines/install/">https://tekton.dev/docs/pipelines/install/</a></p>

<p>Tekton dashboard 설치에 대해 자세한 것은 아래의 <a href="https://tekton.dev/docs/dashboard/install/">링크</a>를 확인하세요.</p>

<p><a href="https://tekton.dev/docs/dashboard/install/">https://tekton.dev/docs/dashboard/install/</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="tekton" /><summary type="html"><![CDATA[Tekton 설치 Tekton pipeline을 Kubernetes에 설치합니다.]]></summary></entry></feed>