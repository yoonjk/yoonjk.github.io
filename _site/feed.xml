<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-12T08:09:01+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">@Inject과 @Autowired의 차이점</title><link href="http://localhost:4000/springboot/difference-autowired-inject/" rel="alternate" type="text/html" title="@Inject과 @Autowired의 차이점" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T00:00:00+09:00</updated><id>http://localhost:4000/springboot/difference-autowired-inject</id><content type="html" xml:base="http://localhost:4000/springboot/difference-autowired-inject/"><![CDATA[<h2 id="inject-vs-autowired">@Inject vs @Autowired</h2>
<p>@Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다.
@Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.</p>

<table>
  <thead>
    <tr>
      <th>Sr. No.	Key</th>
      <th>@Inject</th>
      <th>@Autowired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1	Basic</td>
      <td>그것은 자바 CDI의 일부입니다</td>
      <td>스프링 프레임 워크의 일부입니다.</td>
    </tr>
    <tr>
      <td>2	Required</td>
      <td>required 속성이 없습니다.</td>
      <td>required속성이 있습니다.</td>
    </tr>
    <tr>
      <td>3	Default Scope	autowire</td>
      <td>기본 범위는 싱글톤입니다.</td>
      <td>주입 빈의 기본 범위는 prototype입니다.</td>
    </tr>
    <tr>
      <td>4	Ambiguity</td>
      <td>주입을 위해 빈에 모호성이있는 경우 코드에 @Named해야합니다</td>
      <td>주입을 위해 Bean에 모호한 경우 코드에 @Qualifer 추가해야합니다.</td>
    </tr>
    <tr>
      <td>5	Advantage</td>
      <td>Java CDI의 일부이므로 DI 프레임워크에 의존하지 않습니다.</td>
      <td>시스템을 느슨하게 결합합니다.</td>
    </tr>
  </tbody>
</table>

<p>응용 프로그램을 Spring 프레임워크와 밀접하게 결합시킵니다. 나중에 다른 DI 프레임워크로 이동하려면 응용 프로그램을 다시 구성해야합니다.</p>

<p>@Injection 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InjectionExample</span> <span class="o">{</span>
   <span class="nd">@Inject</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@Autowired 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutowiredExample</span> <span class="o">{</span>
   <span class="nd">@Autowired</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="springboot" /><summary type="html"><![CDATA[@Inject vs @Autowired @Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다. @Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Sentinel &amp;amp; HAProxy</title><link href="http://localhost:4000/cache/haproxy/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Sentinel &amp;amp; HAProxy" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/haproxy</id><content type="html" xml:base="http://localhost:4000/cache/haproxy/"><![CDATA[<p>Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.</p>

<h2 id="haproxy-환경-구성">Haproxy 환경 구성</h2>

<h4 id="haproxy-설치를-위한-의존성-패키지-설치">HAProxy 설치를 위한 의존성 패키지 설치</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># HAProxy 설치를 위한 의존성 패키지 설치</span>
yum <span class="nb">install</span> <span class="nt">-y</span> gcc openssl openssl-devel pcre-static pcre-devel systemd-devel
</code></pre></div></div>

<h4 id="haproxy-설치">Haproxy 설치</h4>
<p>haproxy를 구성하기 위해 haproxy 최근 버전을 <a href="http://www.haproxy.org/download/2.8/src/devel/">download</a>하여 build 및 install합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://www.haproxy.org/download/2.8/src/devel/haproxy-2.8-dev7.tar.gz
<span class="nb">tar </span>xvzf haproxy-2.8-dev7.tar.gz
<span class="nb">cd </span>haproxy-2.8-dev7 
make <span class="nv">TARGET</span><span class="o">=</span>linux-glibc <span class="nv">USE_OPENSSL</span><span class="o">=</span>1 <span class="nv">USE_PCRE</span><span class="o">=</span>1 <span class="nv">USE_ZLIB</span><span class="o">=</span>1 <span class="nv">USE_SYSTEMD</span><span class="o">=</span>1

<span class="c">## Install haproxy</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>아래의 명령어를 입력하여 설치된 HAProxy 버전을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/sbin/haproxy <span class="nt">-v</span>
</code></pre></div></div>
<p>OS가 reboot되어도 재시작하도록 service 파일을 작서합니다. 아래의 명령어를 입력하여 HAProxy 서비스 예제 파일을 다운로드합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"http://git.haproxy.org/?p=haproxy-2.3.git;a=blob_plain;f=contrib/systemd/haproxy.service.in"</span> <span class="nt">-o</span> /etc/systemd/system/haproxy.service

<span class="c"># 서비스파일 편집</span>
vi /etc/systemd/system/haproxy.service
</code></pre></div></div>
<p>아래와 같이 서비스 파일에서 아래의 3개의 내용을 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
</code></pre></div></div>

<p>서비프파일 전체 내용</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>HAProxy Load Balancer
<span class="nv">After</span><span class="o">=</span>network-online.target
<span class="nv">Wants</span><span class="o">=</span>network-online.target

<span class="o">[</span>Service]
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/default/haproxy
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/sysconfig/haproxy
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"CONFIG=/etc/haproxy/haproxy.cfg"</span> <span class="s2">"PIDFILE=/run/haproxy.pid"</span> <span class="s2">"EXTRAOPTS=-S /run/haproxy-master.sock"</span>
<span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
<span class="nv">ExecReload</span><span class="o">=</span>/bin/kill <span class="nt">-USR2</span> <span class="nv">$MAINPID</span>
<span class="nv">KillMode</span><span class="o">=</span>mixed
<span class="nv">Restart</span><span class="o">=</span>always
<span class="nv">SuccessExitStatus</span><span class="o">=</span>143
<span class="nv">Type</span><span class="o">=</span>notify

<span class="c"># The following lines leverage SystemD's sandboxing options to provide</span>
<span class="c"># defense in depth protection at the expense of restricting some flexibility</span>
<span class="c"># in your setup (e.g. placement of your configuration files) or possibly</span>
<span class="c"># reduced performance. See systemd.service(5) and systemd.exec(5) for further</span>
<span class="c"># information.</span>

<span class="c"># NoNewPrivileges=true</span>
<span class="c"># ProtectHome=true</span>
<span class="c"># If you want to use 'ProtectSystem=strict' you should whitelist the PIDFILE,</span>
<span class="c"># any state files and any other files written using 'ReadWritePaths' or</span>
<span class="c"># 'RuntimeDirectory'.</span>
<span class="c"># ProtectSystem=true</span>
<span class="c"># ProtectKernelTunables=true</span>
<span class="c"># ProtectKernelModules=true</span>
<span class="c"># ProtectControlGroups=true</span>
<span class="c"># If your SystemD version supports them, you can add: @reboot, @swap, @sync</span>
<span class="c"># SystemCallFilter=~@cpu-emulation @keyring @module @obsolete @raw-io</span>

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div></div>
<h2 id="haproxy-설정파일-수정">haproxy 설정파일 수정</h2>
<p>아래의 명령어를 입력하여 HAProxy 폴더를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/log/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/certs
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/errors/
</code></pre></div></div>
<p>HAProxy 설정 파일에 아래와 같이 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------------------------------------------------------------------</span>
<span class="c"># common defaults that all the 'listen' and 'backend' sections will</span>
<span class="c"># use if not designated in their block</span>
<span class="c">#---------------------------------------------------------------------</span>
defaults
    mode                    tcp
    log                     127.0.0.1 local0
    retries                 3
    <span class="nb">timeout </span>http-request    10s
    <span class="nb">timeout </span>queue           1m
    <span class="nb">timeout </span>connect         5s
    <span class="nb">timeout </span>client          5s
    <span class="nb">timeout </span>server          5s
    <span class="nb">timeout </span>http-keep-alive 10s
    <span class="nb">timeout </span>check           1s
    maxconn                 10000
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_master
    <span class="nb">bind</span> <span class="k">*</span>:8000
    default_backend bk_redis_master
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_master
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:master
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check

<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_slave
    <span class="nb">bind</span> <span class="k">*</span>:8001
    default_backend bk_redis_slave
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_slave
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:slave
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># admin uI</span>
<span class="c">#---------------------------------------------------------------------</span>
listen stats
 <span class="nb">bind</span> :80
 mode http
 balance roundrobin
 maxconn 10
 <span class="nb">timeout </span>client 5000
 <span class="nb">timeout </span>connect 4000
 <span class="nb">timeout </span>server 30000

 <span class="c"># Enable stats page</span>
 stats <span class="nb">enable</span>

 <span class="c"># Hide HAProxy version</span>
 stats hide-version

  <span class="c">#This is the virtual URL to access the stats page</span>
 stats uri /haproxy_stats

 <span class="c">#Authentication realm. This can be set to anything.</span>
 <span class="c">#Escape space characters with a backslash.</span>
 stats realm HAProxy<span class="se">\ </span>Statistics

 <span class="c">#The user/pass you want to use. Change this password!</span>
 stats auth admin:admin

 <span class="c">#This allows you to take down and bring up back end servers.</span>
 <span class="c">#This will produce an error on older versions of HAProxy.</span>
 stats admin <span class="k">if </span>TRUE
</code></pre></div></div>

<p>## HAProxy 실행
HAProxy를 서비스를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> systemctl daemon-reload
 systemctl <span class="nb">enable </span>haproxy
 systemctl start haproxy
</code></pre></div></div>

<h2 id="haproxy-ui-for-redis">HAProxy UI for redis</h2>
<p>HAProxy UI를 접속하기 위해 아래의 Url http://localhost/haproxy_stats 에 접속하면 Redis master와
slave의 상태를 확인할 수 있습니다.</p>

<p>![haproxy]](07-cache-haproxy.png)</p>

<h2 id="haproxy-연결-테스트">HAProxy 연결 테스트</h2>
<p>Redis master에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8000
localhost:8000&gt; <span class="nb">set </span>k1 v1
</code></pre></div></div>
<p>Redis slave에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8001
localhost:8001&gt; get k1
</code></pre></div></div>

<p>Redis master 를 강제로 종료시키고 HAProxy UI화면을 refresh하면 master/slave정보가 변경된 것을 확인할 수 있습니다.
redis-cli를 사용해 slave에 연결해서 계속해서 조회가 가능합니다.</p>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/22">5분 안에 구축하는 Redis-Sentinel + HAProxy</a>
<a href="https://engineeringcode.tistory.com/125">공학코드 연구노트</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - 레디스 모니터링 Redis Stat</title><link href="http://localhost:4000/cache/monitoring-redis-stat/" rel="alternate" type="text/html" title="Getting Start Redis - 레디스 모니터링 Redis Stat" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/monitoring-redis-stat</id><content type="html" xml:base="http://localhost:4000/cache/monitoring-redis-stat/"><![CDATA[<p>Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.</p>

<h2 id="redis-stat-설치">Redis Stat 설치</h2>
<p>Redis Stat는 ruby로 개발되어 있어서 Ruby가 설치되어 있어야 합니다. Ruby를 설치하기전에 의존성 패키지를 먼저 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ruby-devel gcc make rpm-build rubygems
<span class="c"># Ruby install</span>
git clone https://github.com/rbenv/rbenv-installer
<span class="nb">cd </span>rbenv-installer
<span class="nb">cd </span>bin
./rbenv-installer 
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/.rbenv/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'eval "$(rbenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc
rbenv <span class="nb">install </span>2.6.0
rbenv global 2.6.0
gem <span class="nb">install </span>redis-stat
</code></pre></div></div>
<p>redis-stat를 다음과 같이 실행합니다.</p>

<p>redis-stat 주소:포트번호 주소:포트번호 주소:포트번호  –verbose –daemon –server=8888</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-stat localhost:6300 localhost:6301 localhost:6302 localhost:6400 localhost:6401 localhost:6402 <span class="nt">--daemon</span> <span class="nt">--server</span><span class="o">=</span>8888
</code></pre></div></div>
<p>브라우저 Url 입력창에 http://localhost:8888 접속하여 Redis Stat UI console에 접속합니다.</p>

<p><img src="/assets/images/cache/12-cache-redis-stat-1.png" alt="Jupyter log" /></p>

<p><img src="/assets/images/cache/12-cache-redis-stat-2.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="redis-stat" /><summary type="html"><![CDATA[Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Cluster</title><link href="http://localhost:4000/cache/redis-cluster/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Cluster" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster/"><![CDATA[<h2 id="redis-cluster-환경구성">Redis Cluster 환경구성</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port <span class="o">[</span>각자포트]
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-[각자포트].conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_[각자포트].aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_[각자포트].pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_[각자포트].log
</code></pre></div></div>
<p>redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-server 6300</span>
<span class="nb">cp </span>redis.conf redis_6300.conf
vi redis_6300.conf
</code></pre></div></div>
<p>redis_6300.conf 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port 6300
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-6300.conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_6300.aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_6300.pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_6300.log
</code></pre></div></div>
<p>나머지 redis server의 환경파일을 복사하고 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6300.conf redis_6301.conf
<span class="nb">cp </span>redis_6300.conf redis_6302.conf
<span class="nb">cp </span>redis_6300.conf redis_6400.conf
<span class="nb">cp </span>redis_6300.conf redis_6401.conf
<span class="nb">cp </span>redis_6300.conf redis_6402.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6301/g'</span> redis_6301.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6302/g'</span> redis_6302.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6400/g'</span> redis_6400.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6401/g'</span> redis_6401.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6402/g'</span> redis_6402.conf
</code></pre></div></div>

<h2 id="redis-cluster-실행">Redis Cluster 실행</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./src/redis-server redis_6300.conf
./src/redis-server redis_6301.conf
./src/redis-server redis_6302.conf
./src/redis-server redis_6400.conf
./src/redis-server redis_6401.conf
./src/redis-server redis_6402.conf

redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
</code></pre></div></div>
<h4 id="redis-cluster-실행로그">redis cluster 실행로그</h4>
<p><img src="/assets/images/cache/08-cache-create-redis-cluster.png" alt="Jupyter log" /></p>

<h4 id="master-노드-로그">Master 노드 로그</h4>
<p><img src="/assets/images/cache/09-cache-log-redis-cluster.png" alt="Jupyter log" /></p>

<h2 id="slave1-등록">Slave1 등록</h2>
<p>Master1(6300)에 Slave1(6400) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>
</code></pre></div></div>
<h4 id="slave-등록-로그">Slave 등록 로그</h4>
<p><img src="/assets/images/cache/10-cache-add-slave-node.png" alt="Jupyter log" /></p>

<h4 id="master-로그">Master 로그</h4>
<p><img src="/assets/images/cache/11-cache-log-redis-master.png" alt="Jupyter log" /></p>

<h4 id="slave2-등록">Slave2 등록</h4>
<p>Master2(6301)에 Slave1(6401) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h4 id="slave3-등록">Slave3 등록</h4>
<p>Master3(6302)에 Slave1(6402) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h2 id="클러스터-정보확인">클러스터 정보확인</h2>
<p>redis 클러스터 정보를 다음과 같이 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> info 127.0.0.1:6300
</code></pre></div></div>
<h4 id="redis-cluster-failover">Redis Cluster Failover</h4>
<p>Redis Master를 강제로 종료했을 떄 어떻게 failover되는지 확인하기 위해 master1(6300)을 강제로 종료하여 redis stat로 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis
<span class="nb">kill</span> <span class="nt">-9</span> pid
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Cluster 환경구성 port [각자포트] # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-[각자포트].conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_[각자포트].aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_[각자포트].pid # 로그 파일 저장 경로 지정 logfile logs/redis_[각자포트].log redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다. # redis-server 6300 cp redis.conf redis_6300.conf vi redis_6300.conf redis_6300.conf 파일을 다음과 같이 수정합니다. port 6300 # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-6300.conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_6300.aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_6300.pid # 로그 파일 저장 경로 지정 logfile logs/redis_6300.log 나머지 redis server의 환경파일을 복사하고 수정합니다. ```bash cp redis_6300.conf redis_6301.conf cp redis_6300.conf redis_6302.conf cp redis_6300.conf redis_6400.conf cp redis_6300.conf redis_6401.conf cp redis_6300.conf redis_6402.conf]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Sentinel 구성</title><link href="http://localhost:4000/cache/setup-sentinel-redis/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Sentinel 구성" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-sentinel-redis</id><content type="html" xml:base="http://localhost:4000/cache/setup-sentinel-redis/"><![CDATA[<h2 id="redis-sentinel-구성">Redis Sentinel 구성</h2>
<p>Redis를 다음의 <a href="https://yoonjk.github.io/cache/install-redis/">링크</a>를 참조하여 설치합니다.</p>

<p>Redis 를 HA 구성하는 방법은 몇가지 방법은 아래와 같이 구성할 수 있습니다. 첫번째 방법은 Master가 장애가 발생하면 서비스 장애가 발생하는 구성이지만 구성은 간단합니다. 두번째 방법 Sentinel 방법은 Redis Master가 장애가 발생하여도 slave가 master로 승격되어 지속적인 서비스가 가능합니다. 장애가 발생했던 master가 복귀되면 이전의 master는 slave 역할로 서비스를 합니다.
마지막 방법은 Redis 구성은 이전 방법보다는 복잡하지만 좀더 낳은 고가용성을 제공하면서 처리량을 높이는 방법입니다.<br />
이번 글에서는 Redis Sentinel을 구을해 봅니다.</p>

<ul>
  <li>Redis Master and Slave</li>
  <li>Redis Sentinel</li>
  <li>Redis Cluster</li>
</ul>

<h2 id="redis-환경설정">redis 환경설정</h2>
<p>redis sentinel을 구성하기 위해 redis master/slave 를 위한 환경설정을 합니다.</p>
<ul>
  <li>redis config 구성</li>
  <li>sentinel config 구성</li>
</ul>

<p>redis master config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf redis_6382.conf
vi redis_6382.conf

<span class="c"># 포트 설정</span>
port 각자포트
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
logfile logs/redis_6382.log
</code></pre></div></div>

<p>redis slave config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6382.conf redis_6383.conf 
<span class="nb">cp </span>redis_6382.conf redis_6384.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6383/g'</span> redis_6383.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6384/g'</span> redis_6384.conf 

<span class="c"># slave1</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf

<span class="c"># slave2</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
</code></pre></div></div>

<h4 id="redis-sentinel-config-구성">redis sentinel config 구성</h4>
<p>redis sentinel config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>sentinel.conf redis_5000.conf
vi redis_5000.conf

<span class="c"># 포트 설정</span>
port 5000
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
<span class="nb">dir</span> <span class="s2">"./"</span>
logfile <span class="s2">"logs/redis_5000.log"</span>
<span class="c"># 감시할 마스터 정보 및 쿼럼(quorum) 설정</span>
sentinel monitor mymaster 127.0.0.1 6382 2
<span class="c"># 다운 되었다고 인지하는 시간 (3초)</span>
- 마스터 서버에 정기적으로 PING을 보내는데, 이 시간 동안 응답이 없으면 다운된 것으로 판단하고 장애조치<span class="o">(</span>failover<span class="o">)</span> 작업을 시작합니다
sentinel down-after-milliseconds mymaster 3000
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_5000.conf redis_5001.conf
<span class="nb">cp </span>redis_5000.conf redis_5002.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5001/g'</span> redis_5001.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5002/g'</span> redis_5002.conf 
</code></pre></div></div>

<h2 id="redis-실행">redis 실행</h2>
<p>Redis 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis_6382.conf
src/redis-server redis_6383.conf
src/redis-server redis_6384.conf
</code></pre></div></div>

<p>Redis Sentinel 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/sentinel-server redis_5000.conf
src/sentinel-server redis_5001.conf
src/sentinel-server redis_5002.conf
</code></pre></div></div>

<h2 id="redis-failover-테스트">redis failover 테스트</h2>
<p>redis master를 강제 종료시 slave가 master로 승격되는 확인하기 위해, sentinel 서버의 로그를 모니터링 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tail</span> <span class="nt">-f</span> logs/redis_5000.log
</code></pre></div></div>
<p>redis master process를 확인하고 서버를 강제로 종료합니다.<br />
그러면 sentinel에서 자동으로 redis slave를 master로 승격하는 것을 확인 할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis

<span class="c"># redis master pid를 확인</span>
<span class="nb">kill</span> <span class="nt">-9</span> redis_master_pid
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/15">5분 안에 구축하는 Redis-Sentinel</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 구성 Redis를 다음의 링크를 참조하여 설치합니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis 설치(Centos)</title><link href="http://localhost:4000/cache/install-redis/" rel="alternate" type="text/html" title="Getting Start Redis - Redis 설치(Centos)" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/install%20redis</id><content type="html" xml:base="http://localhost:4000/cache/install-redis/"><![CDATA[<h2 id="redis-설치-준비">Redis 설치 준비</h2>
<p>Redis를 다음의 절차로 설치합니다.</p>
<ul>
  <li>OS 업데이트</li>
  <li>Development Tools 설치</li>
  <li>redis download</li>
  <li>redis build</li>
  <li>redis install</li>
</ul>

<p>Centos7 OS 버전을 최신으로 업그레이드 하고, Development Tools를 설치합니다. Redis <a href="http://download.redis.io/releases/">download</a> site 에 가서 원하는 redis 를 확인하고 address link를 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum update <span class="nt">-y</span>
yum groupinstall <span class="s1">'Development Tools'</span>
<span class="nb">sudo </span>wget http://download.redis.io/releases/redis-7.0.10.tar.gz
<span class="nb">tar </span>xvzf redis-7.0.10.tar.gz
<span class="nb">cd </span>redis-7.0.10
</code></pre></div></div>
<p>Redis 압축파일을 해제한 후 make 명령어를 수행하면 아래처럼 jemalloc No such file or directory 오류가 발생합니다.
이를 해결하기 위해서는 deps 폴더에서 compile을 해야합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
<span class="nb">cd </span>deps
make hiredis jemalloc linenoise lua
<span class="nb">cd</span> ..
</code></pre></div></div>
<p>Redis 압축 해제했던 폴더로 되돌아와서 다시 build합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-7.0.10</span>
make
make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="redis-서버-실행">Redis 서버 실행</h2>
<p>redis 를 install 후 redis 서버를 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis.conf
</code></pre></div></div>

<p>redis를 접속하기 위해 terminal을 1개 열어 redis가 설치된 서버에 접속합니다.
src 폴더에 있는 redis-cli를 이용하여 redis 서버에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli
<span class="nb">set </span>k1 v1
get k1
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://mozi.tistory.com/536">꽁담</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis 설치 준비 Redis를 다음의 절차로 설치합니다. OS 업데이트 Development Tools 설치 redis download redis build redis install]]></summary></entry><entry><title type="html">Getting Start Redis - List</title><link href="http://localhost:4000/cache/list/" rel="alternate" type="text/html" title="Getting Start Redis - List" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/list</id><content type="html" xml:base="http://localhost:4000/cache/list/"><![CDATA[<h2 id="list">List</h2>
<p>List 데이터 유형을 설명하려면 List라는 용어가  정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다.<br />
매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다:<br />
10,20,1,2,3은 목록입니다.<br />
그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다.<br />
Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. <a href="https://redis.io/commands/lpush">LPUSH</a> 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는  1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다.<br />
단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현  된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다.<br />
Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다.<br />
큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.</p>

<p>First steps with Redis Lists
<a href="https://redis.io/commands/lpush">LPUSH</a> 명령은  왼쪽(머리)의 목록에 새 요소를 추가하는 반면, <a href="https://redis.io/commands/rpush">RPUSH</a> 명령은 오른쪽(맨 끝)의 목록에 새 요소를 추가합니다. 마지막으로 <a href="https://redis.io/commands/lrange">LRANGE</a> 명령은 목록에서 요소 범위를 추출합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist A
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> rpush mylist B
<span class="o">(</span>integer<span class="o">)</span> 2
<span class="o">&gt;</span> lpush mylist first
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
</code></pre></div></div>
<p><a href="https://redis.io/commands/lrange">LRANGE</a>는  반환할 범위의 첫 번째 요소와 마지막 요소인 두 개의 인덱스를 사용합니다. 두 인덱스 모두 음수일 수 있으므로 Redis에게 끝에서 계산을 시작하도록 지시합니다. 따라서 -1은 마지막 요소이고 -2는 목록의 끝에서 두 번째 요소입니다.<br />
보시다시피 <a href="https://redis.io/commands/rpush">RPUSH</a>는  목록의 오른쪽에 요소를 추가하고 최종 <a href="https://redis.io/commands/lpush">LPUSH</a>는  왼쪽에 요소를 추가했습니다.<br />
두 명령 모두 가변 명령이므로 한 번의 호출로 여러 요소를 목록으로 자유롭게 푸시 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5 <span class="s2">"foo bar"</span>
<span class="o">(</span>integer<span class="o">)</span> 9
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
4<span class="o">)</span> <span class="s2">"1"</span>
5<span class="o">)</span> <span class="s2">"2"</span>
6<span class="o">)</span> <span class="s2">"3"</span>
7<span class="o">)</span> <span class="s2">"4"</span>
8<span class="o">)</span> <span class="s2">"5"</span>
9<span class="o">)</span> <span class="s2">"foo bar"</span>
</code></pre></div></div>

<p>Redis 목록에 정의된 중요한 작업은 요소를 팝하는 기능입니다. 요소를 팝핑하는 작업은 목록에서 요소를 검색하는 동시에 목록에서 제거하는 작업입니다. 목록의 양쪽에 요소를 푸시하는 방법과 유사하게 왼쪽과 오른쪽에서 요소를 팝 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist a b c
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> rpop mylist
<span class="s2">"c"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"b"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"a"</span>
</code></pre></div></div>

<p>세 개의 요소를 추가하고 세 개의 요소를 팝했으므로 이 명령 시퀀스가 끝나면 목록이 비어 있고 더 이상 팝업할 요소가 없습니다. 또 다른 요소를 터뜨리려고 하면 이것이 우리가 얻는 결과입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p>Redis는 목록에 요소가 없음을 알리기 위해 NULL 값을 반환했습니다.</p>

<p>Common use cases for lists
목록은 여러 작업에 유용하며 두 가지 매우 대표적인 사용 사례는 다음과 같습니다.:<br />
•	사용자가 소셜 네트워크에 게시 한 최신 업데이트 기억.<br />
•	생산자가 항목을 목록으로 푸시하고 소비자(일반적으로 작업자)가 해당 항목을 소비하고 작업을 실행하는 소비자-생산자 패턴을 사용하는 프로세스 간의 통신입니다. Redis에는 이 사용 사례를 보다 안정적이고 효율적으로 만드는 특수 목록 명령이 있습니다.</p>

<p>예를 들어 인기있는 Ruby 라이브러리 resque와 sidekiq는  백그라운드 작업을 구현하기 위해 내부적으로 Redis 목록을 사용합니다.<br />
인기있는 트위터 소셜 네트워크는 사용자가 게시 한 최신 트윗을 Redis 목록으로 가져옵니다.<br />
일반적인 사용 사례를 단계별로 설명하기 위해 홈페이지에 사진 공유 소셜 네트워크에 게시된 최신 사진이 표시되고 액세스 속도를 높이고 싶다고 가정해 보겠습니다.<br />
•	사용자가 새 사진을 게시 할 때마다 LPUSH를 사용하여 ID를 목록에 추가합니다.<br />
•	사용자가 홈페이지를 방문하면 <a href="https://redis.io/commands/lrange">LRANGE</a> 0 9를 사용하여  최신 10 개의 게시 된 항목을 가져옵니다.</p>

<p>Capped lists
많은 사용 사례에서 우리는 목록을 사용하여 소셜 네트워크 업데이트, 로그 또는 기타 무엇이든 최신 항목을 저장하려고합니다.<br />
Redis를 사용하면 목록을 제한 된 컬렉션으로 사용할 수 있으며 최신 N 항목 만 기억하고 <a href="https://redis.io/commands/ltrim">LTRIM</a> 명령을 사용하여 가장 오래된 항목을 모두 삭제할 수 있습니다.<br />
<a href="https://redis.io/commands/ltrim">LTRIM</a> 명령은 <a href="https://redis.io/commands/lrange">LRANGE</a>와 유사하지만 지정된 요소 범위를 표시하는 대신 이 범위를 새 목록 값으로 설정합니다. 주어진 범위를 벗어난 모든 요소가 제거됩니다.<br />
An example will make it more clear:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5
<span class="o">(</span>integer<span class="o">)</span> 5
<span class="o">&gt;</span> ltrim mylist 0 2
OK
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"1"</span>
2<span class="o">)</span> <span class="s2">"2"</span>
3<span class="o">)</span> <span class="s2">"3"</span>
</code></pre></div></div>

<p>위의 <a href="https://redis.io/commands/ltrim">LTRIM</a> 명령은 Redis에게 인덱스 0에서 2까지의 목록 요소 만 가져 오도록 지시하고 다른 모든 것은 삭제됩니다. 이것은 매우 간단하지만 유용한 패턴을 허용합니다 :<br />
목록 푸시 작업 + 목록 트리밍 작업을 함께 수행하여 새 요소를 추가하고 제한을 초과하는 요소를 삭제합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LPUSH mylist &lt;some element&gt;
LTRIM mylist 0 999
</code></pre></div></div>

<p>위의 조합은 새 요소를 추가하고 1000개의 최신 요소만 목록에 가져옵니다. <a href="https://redis.io/commands/lrange">LRANGE</a>를 사용하면 아주 오래된 데이터를 기억할 필요없이 상위 항목에 액세스 할 수 있습니다.<br />
Note: <a href="https://redis.io/commands/lrange">LRANGE</a>는 기술적으로 O (N) 명령이지만 목록의 머리 또는 꼬리쪽으로 작은 범위에 액세스하는 것은 일정한 시간 작업입니다.</p>

<p>Blocking operations on lists<br />
목록에는 대기열을 구현하는 데 적합한 특수 기능이 있으며 일반적으로 프로세스 간 통신 시스템의 빌딩 블록으로 사용됩니다. 차단 작업.
하나의 프로세스가있는 목록으로 항목을 푸시하고 실제로 해당 항목으로 어떤 종류의 작업을 수행하기 위해 다른 프로세스를 사용한다고 가정 해보십시오. 이것은 일반적인 생산자 / 소비자 설정이며 다음과 같은 간단한 방법으로 구현할 수 있습니다.:<br />
•	항목을 목록에 푸시하기 위해 생산자는 <a href="https://redis.io/commands/lpush">LPUSH</a>를 호출합니다.<br />
•	목록에서 항목을 추출/처리하기 위해 소비자는 <a href="https://redis.io/commands/rpop">RPOP</a>를 호출합니다.</p>

<p>그러나 때로는 목록이 비어 있고 처리 할 것이 없으므로 RPOP는  NULL을 반환합니다. 이 경우 소비자는 잠시 기다렸다가 RPOP를 사용하여 다시 시도해야 합니다. 이것을 폴링이라고하며 몇 가지 단점이 있기 때문에이 맥락에서 좋은 생각이 아닙니다.:</p>
<ol>
  <li>Redis와 클라이언트가 쓸모없는 명령을 처리하도록합니다 (목록이 비어있을 때 모든 요청은 실제 작업을 수행하지 않고 NULL을 반환합니다).</li>
  <li>작업자가 NULL을 받은 후 잠시 기다리므로 항목 처리에 지연을 추가합니다. 지연을 줄이기 위해 RPOP에 대한 호출 사이에 더 적은 대기 시간을 할애할 수 있으며, 문제 번호 1, 즉 Redis에 대한 더 쓸모없는 호출을 증폭시키는 효과가 있습니다.</li>
</ol>

<p>따라서 Redis는 목록이 비어 있는 경우 차단할 수 있는 <a href="https://redis.io/commands/rpop">RPOP</a> 및 <a href="https://redis.io/commands/lpop">LPOP</a> 버전인 <a href="https://redis.io/commands/brpop">BRPOP</a> 및 <a href="https://redis.io/commands/blpop">BLPOP</a>라는 명령을 구현합니다. 새  요소가 목록에 추가되거나 사용자 지정 시간 초과에 도달할 때만 호출자에게 반환됩니다.<br />
이것은  작업자에서 사용할 수 있는 <a href="https://redis.io/commands/brpop">BRPOP</a> 호출의 예입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> brpop tasks 5
1<span class="o">)</span> <span class="s2">"tasks"</span>
2<span class="o">)</span> <span class="s2">"do_something"</span>
</code></pre></div></div>
<p>즉, “목록 작업의 요소를 기다리지 만 5 초 후에 사용할 수있는 요소가 없으면 반환합니다.”.<br />
요소를 영원히 기다리는 시간 제한으로 0을 사용할 수 있으며, 동시에 여러 목록에서 대기하고 첫 번째 목록이 요소를 받을 때 알림을 받기 위해 하나가 아닌 여러 목록을 지정할 수도 있습니다.</p>

<p>BRPOP에 대해 주의해야 할 몇 가지 사항:</p>
<ol>
  <li>클라이언트는 정렬된 방식으로 제공됩니다: 목록 대기를 차단한 첫 번째 클라이언트는 다른 클라이언트에 의해 요소가 푸시될 때 먼저 제공됩니다.</li>
  <li>반환 값은 <a href="https://redis.io/commands/rpop">RPOP</a>와 다릅니다 : <a href="https://redis.io/commands/brpop">BRPOP</a> 및 <a href="https://redis.io/commands/blpop">BLPOP</a>이  여러 목록의 요소를 기다리는 것을 차단할 수 있기 때문에 키 이름도 포함하므로 2 요소 배열입니다.</li>
  <li>시간 제한에 도달하면 NULL이 반환됩니다.</li>
</ol>

<p>목록 및 차단 작업에 대해 알아야 할 사항이 더 있습니다. 다음에 대해 자세히 읽어 보시기 바랍니다.:<br />
•	<a href="https://redis.io/commands/lmove">LMOVE</a>를 사용하여 더 안전한 대기열 또는 순환 대기열을 구축할 수 있습니다.<br />
•	<a href="https://redis.io/commands/blmove">BLMOVE</a>라는 명령의 차단 변형도 있습니다.</p>

<p>Automatic creation and removal of keys
지금까지 예제에서는 요소를 푸시하기 전에 빈 목록을 만들거나 더 이상 내부에 요소가 없을 때 빈 목록을 제거 할 필요가 없었습니다. 목록이 비어있을 때 키를 삭제하거나 키가 존재하지 않고 요소를 추가하려는 경우 빈 목록을 만드는 것은 Redis의 책임입니다 
(예 : <a href="https://redis.io/commands/lpush">LPUSH</a>를 사용하여).</p>

<p>이는 목록에만 국한된 것이 아니라 여러 요소(스트림, 집합, 정렬된 집합 및 해시)로 구성된 모든 Redis 데이터 형식에 적용됩니다.
기본적으로 세 가지 규칙으로 행동을 요약 할 수 있습니다.:</p>
<ol>
  <li>집계 데이터 형식에 요소를 추가할 때 대상 키가 없으면 요소를 추가하기 전에 빈 집계 데이터 형식이 만들어집니다.</li>
  <li>집계 데이터 유형에서 요소를 제거할 때 값이 비어 있으면 키가 자동으로 삭제됩니다. Stream 데이터 형식은 이 규칙의 유일한 예외입니다.</li>
  <li><a href="https://redis.io/commands/llen">LLEN</a>(목록의 길이를 반환함)과 같은 읽기 전용 명령 또는 빈 키를 사용하여 요소를 제거하는 쓰기 명령을 호출하면 키가 명령이 찾을 것으로 예상되는 유형의 빈 집계 유형을 보유하고 있는 경우와 항상 동일한 결과가 생성됩니다.</li>
</ol>

<p>Examples of rule 1:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
</code></pre></div></div>
<p>However we can’t perform operations against the wrong type if the key exists:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>foo bar
OK
<span class="o">&gt;</span> lpush foo 1 2 3
</code></pre></div></div>
<p>(error) WRONGTYPE Operation against a key holding the wrong kind of value</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">type </span>foo
string
</code></pre></div></div>
<p>Example of rule 2:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpop mylist
<span class="s2">"3"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"2"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"1"</span>
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p>The key no longer exists after all the elements are popped.<br />
Example of rule 3:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> llen mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> lpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[List List 데이터 유형을 설명하려면 List라는 용어가 정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다. 매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다: 10,20,1,2,3은 목록입니다. 그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다. Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. LPUSH 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는 1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다. 단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현 된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다. Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다. 큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Hashes</title><link href="http://localhost:4000/cache/hashes/" rel="alternate" type="text/html" title="Getting Start Redis - Hashes" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/hashes</id><content type="html" xml:base="http://localhost:4000/cache/hashes/"><![CDATA[<h2 id="hashes">Hashes</h2>
<p>Redis 해시는 필드-값 쌍을 사용하여 “해시”가 어떻게 보이는지 정확히 보여줍니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hset user:1000 username antirez birthyear 1977 verified 1
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> hget user:1000 username
<span class="s2">"antirez"</span>
<span class="o">&gt;</span> hget user:1000 birthyear
<span class="s2">"1977"</span>
<span class="o">&gt;</span> hgetall user:1000
1<span class="o">)</span> <span class="s2">"username"</span>
2<span class="o">)</span> <span class="s2">"antirez"</span>
3<span class="o">)</span> <span class="s2">"birthyear"</span>
4<span class="o">)</span> <span class="s2">"1977"</span>
5<span class="o">)</span> <span class="s2">"verified"</span>
6<span class="o">)</span> <span class="s2">"1"</span>
</code></pre></div></div>
<p>해시는 객체를 나타내는 데 편리하지만 실제로 해시 안에 넣을 수있는 필드 수에는 사용 가능한 메모리 이외의 실질적인 제한이 없으므로 응용 프로그램 내에서 다양한 방법으로 해시를 사용할 수 있습니다.<br />
<a href="https://redis.io/commands/hset">HSET</a> 명령은  해시의 여러 필드를 설정하는 반면 HGET는 단일 필드를 검색합니다.</p>

<p><a href="https://redis.io/commands/hmget">HMGET</a>은 HGET와 유사  하지만 값 배열을 반환합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hmget user:1000 username birthyear no-such-field
1<span class="o">)</span> <span class="s2">"antirez"</span>
2<span class="o">)</span> <span class="s2">"1977"</span>
3<span class="o">)</span> <span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p><a href="https://redis.io/commands/hincrby">HINCRBY</a>와 같이 개별 필드에 대한 작업을 수행 할 수있는 명령도 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hincrby user:1000 birthyear 10
<span class="o">(</span>integer<span class="o">)</span> 1987
<span class="o">&gt;</span> hincrby user:1000 birthyear 10
<span class="o">(</span>integer<span class="o">)</span> 1997
</code></pre></div></div>
<p>설명서에서 해시 명령의 전체 목록을 찾을 수 있습니다.
작은 해시 (즉, 작은 값을 가진 몇 가지 요소)가 메모리에서 특별한 방식으로 인코딩되어 메모리 효율이 매우 높다는 점은 주목할 가치가 있습니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Hashes Redis 해시는 필드-값 쌍을 사용하여 “해시”가 어떻게 보이는지 정확히 보여줍니다.: &gt; hset user:1000 username antirez birthyear 1977 verified 1 (integer) 3 &gt; hget user:1000 username "antirez" &gt; hget user:1000 birthyear "1977" &gt; hgetall user:1000 1) "username" 2) "antirez" 3) "birthyear" 4) "1977" 5) "verified" 6) "1" 해시는 객체를 나타내는 데 편리하지만 실제로 해시 안에 넣을 수있는 필드 수에는 사용 가능한 메모리 이외의 실질적인 제한이 없으므로 응용 프로그램 내에서 다양한 방법으로 해시를 사용할 수 있습니다. HSET 명령은 해시의 여러 필드를 설정하는 반면 HGET는 단일 필드를 검색합니다.]]></summary></entry><entry><title type="html">Getting Start Redis - String</title><link href="http://localhost:4000/cache/string/" rel="alternate" type="text/html" title="Getting Start Redis - String" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/string</id><content type="html" xml:base="http://localhost:4000/cache/string/"><![CDATA[<h2 id="strings">Strings</h2>
<p>Redis 문자열 유형은 Redis 키와 연결할 수 있는 가장 간단한 값 유형입니다. Memcached의 유일한 데이터 유형이므로 신규 사용자가 Redis에서 사용하는 것도 매우 자연스러운 일입니다.
Redis 키는 문자열이므로 문자열 유형도 값으로 사용할 때 문자열을 다른 문자열에 매핑합니다. 문자열 데이터 형식은 HTML 조각 또는 페이지 캐싱과 같은 다양한 사용 사례에 유용합니다.
redis-cli를 사용하여 문자열 유형을 약간 사용해 보겠습니다<br />
(모든 예제는  이 자습서에서 redis-cli를 통해 수행됨).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey somevalue
OK
<span class="o">&gt;</span> get mykey
<span class="s2">"somevalue"</span>
</code></pre></div></div>

<p><a href="https://redis.io/commands/set">SET</a>과 <a href="https://redis.io/commands/get">GET</a> 명령을 사용하여 볼 수 있듯이  문자열 값을 설정하고 검색하는 방법입니다. <a href="https://redis.io/commands/set">SET</a>은 키가  문자열이 아닌 값과 연결된 경우에도 키가 이미 존재하는 경우 키에 이미 저장된 기존 값을 대체합니다. 따라서 <a href="https://redis.io/commands/set">SET</a>은 할당을 수행합니다.<br />
값은 모든 종류의 문자열 (바이너리 데이터 포함) 일 수 있습니다.</p>

<p>(예 : 값 안에 jpeg 이미지를 저장할 수 있음)<br />
값은 <strong>512MB</strong> 보다 클 수 없습니다.</p>

<p><a href="https://redis.io/commands/set">SET</a> 명령에는 추가 인수로 제공되는 흥미로운 옵션이 있습니다. 예를 들어  키가 이미 존재하는 경우 <a href="https://redis.io/commands/set">SET</a>에 실패하도록 요청하거나 그 반대로 키가 이미 존재하는 경우에만 성공하도록 요청할 수 있습니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey newval nx
<span class="o">(</span>nil<span class="o">)</span>
<span class="o">&gt;</span> <span class="nb">set </span>mykey newval xx
OK
</code></pre></div></div>

<p>문자열이 Redis의 기본 값이더라도 문자열로 수행할 수 있는 흥미로운 작업이 있습니다. 예를 들어, 하나는 <a href="https://ko.wikipedia.org/wiki/%EC%9B%90%EC%9E%90%EC%84%B1_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C)">원자성</a> 증분입니다.
원자성(atomicity)은 데이터베이스 시스템에서 ACID 트랜잭션 특성 중의 하나입니다. 하나의 원자 트랜잭션은 모두 성공하거나 또는 실패하는 데이터베이스 운용의 집합이다. 원자성의 보증은 데이터베이스의 부분적인 갱신으로 더 큰 문제가 야기되는 것을 방지합니다.
:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>counter 100
OK
<span class="o">&gt;</span> incr counter
<span class="o">(</span>integer<span class="o">)</span> 101
<span class="o">&gt;</span> incr counter
<span class="o">(</span>integer<span class="o">)</span> 102
<span class="o">&gt;</span> incrby counter 50
<span class="o">(</span>integer<span class="o">)</span> 152
</code></pre></div></div>

<p><a href="https://redis.io/commands/incr">INCR</a> 명령은 문자열 값을 정수로 구문 분석하고 1씩 증가시킨 다음 마지막으로 가져온 값을 새 값으로 설정합니다.<br />
<a href="https://redis.io/commands/incrby">INCRBY</a>, <a href="https://redis.io/commands/decr">DECR</a> 및 <a href="https://redis.io/commands/decrby">DECRBY</a>와 같은 다른 유사한 명령이 있습니다.<br />
내부적으로는 항상 동일한 명령이며 약간 다른 방식으로 작동합니다.<br />
<a href="https://redis.io/commands/incr">INCR</a>이 원자적이라는 것은 무엇을 의미합니까? 동일한 키에 대해 <a href="https://redis.io/commands/incr">INCR</a>을 발행하는 여러 클라이언트라도 경쟁 조건에 빠지지 않습니다. 예를 들어, 클라이언트 1은 “10”을 읽고 클라이언트 2는 동시에 “10”을 읽고 둘 다 11로 증가하고 새 값을 11로 설정하는 경우는 발생하지 않습니다. 최종 값은 항상 12이며 읽기-증분-집합 작업은 다른 모든 클라이언트가 동시에 명령을 실행하지 않는 동안 수행됩니다.<br />
문자열에서 작동하기위한 여러 명령이 있습니다.<br />
예를 들어, <a href="https://redis.io/commands/getset">GETSET</a> 명령은 키를 새 값으로 설정하고 이전 값을 결과로 리턴합니다.<br />
예를 들어 웹 사이트에서 새 방문자를 받을 때마다 <a href="https://redis.io/commands/incr">INCR</a>을 사용하여 Redis 키를 증가시키는 시스템이 있는 경우 이 명령을 사용할 수 있습니다. 이 정보는 한 번에 한 번씩 수집하여 증분을 한 번도 손실하지 않고 수집할 수 있습니다.  키를 <a href="https://redis.io/commands/getset">GETSET</a> 할 수 있으며  새 값 “0”을 할당하고 이전 값을 다시 읽을 수 있습니다.<br />
단일 명령에서 여러 키의 값을 설정하거나 검색하는 기능은 대기 시간을 줄이는 데에도 유용합니다.<br />
이러한 이유로 <a href="https://redis.io/commands/mset">MSET</a> 및 <a href="https://redis.io/commands/mget">MGET</a> 명령이 있습니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> mset a 10 b 20 c 30
OK
<span class="o">&gt;</span> mget a b c
1<span class="o">)</span> <span class="s2">"10"</span>
2<span class="o">)</span> <span class="s2">"20"</span>
3<span class="o">)</span> <span class="s2">"30"</span>
</code></pre></div></div>

<p>단일 명령에서 여러 키의 값을 설정하거나 검색하는 기능은 대기 시간을 줄이는 데에도 유용합니다. 이러한 이유로 MSET 및 MGET 명령이 있습니다.
Altering and querying the key space
특정 유형에 정의되지 않았지만 키 공간과 상호 작용하는 데 유용한 명령이 있으므로 모든 유형의 키와 함께 사용할 수 있습니다..
예를 들어, EXISTS 명령은  주어진 키가 데이터베이스에 존재하는지 여부를 알리기 위해 1 또는 0을 반환하는 반면, DEL 명령은 값이 무엇이든 키 및 관련 값을 삭제합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey hello
OK
<span class="o">&gt;</span> exists mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> del mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> exists mykey
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>

<p>예제에서  DEL 자체가 키가 제거되었는지 (존재했는지) 여부에 따라 1 또는 0을 반환하는 방법을 볼 수 있습니다 (해당 이름의 키가 없음)..
많은 키 공간 관련 명령이 있지만 위의 두 명령은  지정된 키에 저장된 값의 종류를 반환하는 TYPE 명령과 함께 필수적인 명령입니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey x
OK
<span class="o">&gt;</span> <span class="nb">type </span>mykey
string
<span class="o">&gt;</span> del mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> <span class="nb">type </span>mykey
none
</code></pre></div></div>
<p>Key expiration
계속 진행하기 전에 저장하는 값 유형에 관계없이 작동하는 중요한 Redis 기능인 키 만료를 살펴봐야 합니다. 키 만료를 사용하면 “Time to Live” 또는 “TTL”이라고도 하는 키에 대한 시간 제한을 설정할 수 있습니다. 생존 시간이 경과하면 키가 자동으로 파괴됩니다.</p>

<p><strong>키 만료에 대한 몇 가지 중요한 참고 사항:</strong><br />
•	초 또는 밀리초 정밀도를 사용하여 둘 다 설정할 수 있습니다.<br />
•	그러나 만료 시간 해상도는 항상 1밀리초입니다.<br />
•	만료에 대한 정보는 디스크에 복제되고 유지되며, Redis 서버가 중지된 상태로 유지되는 시간은 사실상 경과합니다.<br />
(즉, Redis는 키가 만료되는 날짜를 저장함).</p>

<p>EXPIRE 명령을 사용하여 키의 만료 설정:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>key some-value
OK
<span class="o">&gt;</span> expire key 5
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> get key <span class="o">(</span>immediately<span class="o">)</span>
<span class="s2">"some-value"</span>
<span class="o">&gt;</span> get key <span class="o">(</span>after some <span class="nb">time</span><span class="o">)</span>
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>
<p>두 번째 호출이 5초 이상 지연되었으므로 두 GET 호출 사이에 키가 사라졌습니다. 위의 예에서는  만료를 설정하기 위해 EXPIRE를 사용했습니다 (만료를 제거하고 키를 영원히 지속시키기 위해 PERSIST를 사용할 수있는  것처럼 이미 만료 된 키에 다른 만료를 설정하는 데에도 사용할 수  있습니다). 그러나 다른 Redis 명령을 사용하여 만료 된 키를 만들 수도 있습니다. 예를 들어 SET 옵션 사용:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>key 100 ex 10
OK
<span class="o">&gt;</span> ttl key
<span class="o">(</span>integer<span class="o">)</span> 9
</code></pre></div></div>
<p>위의 예제에서는 문자열 값이 100이고 만료 시간이 10초인 키를 설정합니다. 나중에  TTL 명령이 호출되어 키의 남은 생존 시간을 확인합니다.
밀리초 단위로 만료를 설정하고 확인하려면 <a href="https://redis.io/commands/pexpire">PEXPIRE</a> 및 <a href="https://redis.io/commands/pttl">PTTL</a> 명령과 SET 옵션의 전체 목록을 확인하십시오. .</p>

<h2 id="redis-정보">Redis 정보</h2>
<p><a href="https://sungwookkang.com/category/Redis">Data Science Lab</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Strings Redis 문자열 유형은 Redis 키와 연결할 수 있는 가장 간단한 값 유형입니다. Memcached의 유일한 데이터 유형이므로 신규 사용자가 Redis에서 사용하는 것도 매우 자연스러운 일입니다. Redis 키는 문자열이므로 문자열 유형도 값으로 사용할 때 문자열을 다른 문자열에 매핑합니다. 문자열 데이터 형식은 HTML 조각 또는 페이지 캐싱과 같은 다양한 사용 사례에 유용합니다. redis-cli를 사용하여 문자열 유형을 약간 사용해 보겠습니다 (모든 예제는 이 자습서에서 redis-cli를 통해 수행됨).]]></summary></entry><entry><title type="html">Getting Start Redis - Set</title><link href="http://localhost:4000/cache/set/" rel="alternate" type="text/html" title="Getting Start Redis - Set" /><published>2023-04-06T00:00:00+09:00</published><updated>2023-04-06T00:00:00+09:00</updated><id>http://localhost:4000/cache/set</id><content type="html" xml:base="http://localhost:4000/cache/set/"><![CDATA[<h2 id="sets">Sets</h2>
<p>Redis 집합은 순서가 지정되지 않은 문자열 컬렉션입니다. <a href="https://redis.io/commands/sadd">SADD</a> 명령은 세트에 새 요소를 추가합니다. 주어진 요소가 이미 존재하는지 테스트, 여러 집합 간의 교차, 합집합 또는 차이 수행 등과 같은 집합에 대해 여러 가지 다른 작업을 수행 할 수도 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd myset 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> smembers myset
1. 3
2. 1
3. 2
</code></pre></div></div>
<p>여기에 세 가지 요소를 세트에 추가하고 Redis에게 모든 요소를 반환하도록 지시했습니다. 보시다시피 정렬되지 않았습니다 - Redis는 요소 순서에 대한 사용자와 계약이 없기 때문에 모든 호출에서 임의의 순서로 요소를 반환 할 수 있습니다.
Redis에는 멤버십을 테스트하는 명령이 있습니다. 
예를 들어 요소가 있는지 확인합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sismember myset 3
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sismember myset 30
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p>“3” is a member of the set, while “30” is not.
집합은 개체 간의 관계를 표현하는 데 유용합니다. 예를 들어 태그를 구현하기 위해 집합을 쉽게 사용할 수 있습니다..
이 문제를 모델링하는 간단한 방법은 태그를 지정하려는 모든 객체에 대한 집합을 갖는 것입니다. 집합에는 개체와 연결된 태그의 ID가 포함됩니다.<br />
한 가지 예는 뉴스 기사에 태그를 지정하는 것입니다. 기사 ID 1000에 태그 1, 2, 5 및 77 태그가 지정된 경우 집합은 이러한 태그 ID를 뉴스 항목과 연결할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd news:1000:tags 1 2 5 77
<span class="o">(</span>integer<span class="o">)</span> 4
</code></pre></div></div>
<p>우리는 또한 역관계를 원할 수도 있습니다 : 주어진 태그로 태그 된 모든 뉴스의 목록:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd tag:1:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sadd tag:2:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sadd tag:5:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sadd tag:77:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
</code></pre></div></div>
<p>주어진 객체에 대한 모든 태그를 가져 오는 것은 간단합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> smembers news:1000:tags
1. 5
2. 1
3. 77
4. 2
</code></pre></div></div>
<p>Note: 예제에서는 태그 ID를 태그 이름에 매핑하는 Redis 해시와 같은 다른 데이터 구조가 있다고 가정합니다..
올바른 Redis 명령을 사용하여 구현하기 쉬운 다른 사소한 작업이 있습니다. 예를 들어 태그 1, 2, 10 및 27을 함께 사용하는 모든 객체 목록을 원할 수 있습니다. 서로 다른 세트 간의 교차를 수행하는 <a href="https://redis.io/commands/sinter">SINTER</a> 명령을 사용하여이 작업을 수행 할 수  있습니다. 우리는 사용할 수 있습니다:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sinter tag:1:news tag:2:news tag:10:news tag:27:news
... results here ...
</code></pre></div></div>
<p>교차 외에도 합집합, 차이, 무작위 요소 추출 등을 수행할 수 있습니다..
요소를 추출하는 명령을 <a href="https://redis.io/commands/spop">SPOP</a>라고 하며 특정 문제를 모델링하는 데 편리합니다. 예를 들어 웹 기반 포커 게임을 구현하려면 덱을 세트로 표현할 수 있습니다. (C) lubs, (D) iamonds, (H) earts, (S) pades에 대해 1 자 접두사를 사용한다고 상상해보십시오.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
  D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3
  H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6
  S7 S8 S9 S10 SJ SQ SK
<span class="o">(</span>integer<span class="o">)</span> 52
</code></pre></div></div>
<p>이제 각 플레이어에게 5장의 카드를 제공하고자 합니다. <a href="https://redis.io/commands/spop">SPOP</a> 명령은 임의의 요소를 제거하여 클라이언트로 반환하므로이 경우 완벽한 작업입니다.<br />
그러나 덱에 대해 직접 호출하면 다음 게임 플레이에서 카드 덱을 다시 채워야 하므로 이상적이지 않을 수 있습니다.<br />
먼저 덱 키에 저장된 세트의 복사본을 게임에 만들 수 있습니다 : 
이 작업은 일반적으로 여러 집합 간의 합집합을 수행하고 결과를 다른 집합에 저장하는 <a href="https://redis.io/commands/sunionstore">SUNIONSTORE</a>를 사용하여 수행됩니다.</p>

<p>그러나 단일 세트의 합집합 자체이기 때문에 내 데크를 복사할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sunionstore game:1:deck deck
<span class="o">(</span>integer<span class="o">)</span> 52
</code></pre></div></div>
<p>이제 첫 번째 플레이어에게 5장의 카드를 제공할 준비가 되었습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> spop game:1:deck
<span class="s2">"C6"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"CQ"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"D1"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"CJ"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"SJ"</span>
</code></pre></div></div>
<p>One pair of jacks, not great…
집합 내의 요소 수를 제공하는 set 명령을 소개하기에 좋은 시기입니다. 이것은 종종 집합 이론의 맥락에서 집합의 카디널리티라고 불리  므로 Redis 명령을 SCARD라고합니다..</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> scard game:1:deck
<span class="o">(</span>integer<span class="o">)</span> 47
</code></pre></div></div>
<p>계산: 52 - 5 = 47.
세트에서 제거하지 않고 임의의 요소를 가져와야 하는 경우 작업에 적합한 <a href="https://redis.io/commands/srandmember">SRANDMEMBER</a> 명령이 있습니다. 또한 반복되는 요소와 반복되지 않는 요소를 모두 반환하는 기능이 있습니다..</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Sets Redis 집합은 순서가 지정되지 않은 문자열 컬렉션입니다. SADD 명령은 세트에 새 요소를 추가합니다. 주어진 요소가 이미 존재하는지 테스트, 여러 집합 간의 교차, 합집합 또는 차이 수행 등과 같은 집합에 대해 여러 가지 다른 작업을 수행 할 수도 있습니다. &gt; sadd myset 1 2 3 (integer) 3 &gt; smembers myset 1. 3 2. 1 3. 2 여기에 세 가지 요소를 세트에 추가하고 Redis에게 모든 요소를 반환하도록 지시했습니다. 보시다시피 정렬되지 않았습니다 - Redis는 요소 순서에 대한 사용자와 계약이 없기 때문에 모든 호출에서 임의의 순서로 요소를 반환 할 수 있습니다. Redis에는 멤버십을 테스트하는 명령이 있습니다. 예를 들어 요소가 있는지 확인합니다.: &gt; sismember myset 3 (integer) 1 &gt; sismember myset 30 (integer) 0 “3” is a member of the set, while “30” is not. 집합은 개체 간의 관계를 표현하는 데 유용합니다. 예를 들어 태그를 구현하기 위해 집합을 쉽게 사용할 수 있습니다.. 이 문제를 모델링하는 간단한 방법은 태그를 지정하려는 모든 객체에 대한 집합을 갖는 것입니다. 집합에는 개체와 연결된 태그의 ID가 포함됩니다. 한 가지 예는 뉴스 기사에 태그를 지정하는 것입니다. 기사 ID 1000에 태그 1, 2, 5 및 77 태그가 지정된 경우 집합은 이러한 태그 ID를 뉴스 항목과 연결할 수 있습니다.: &gt; sadd news:1000:tags 1 2 5 77 (integer) 4 우리는 또한 역관계를 원할 수도 있습니다 : 주어진 태그로 태그 된 모든 뉴스의 목록: &gt; sadd tag:1:news 1000 (integer) 1 &gt; sadd tag:2:news 1000 (integer) 1 &gt; sadd tag:5:news 1000 (integer) 1 &gt; sadd tag:77:news 1000 (integer) 1 주어진 객체에 대한 모든 태그를 가져 오는 것은 간단합니다. &gt; smembers news:1000:tags 1. 5 2. 1 3. 77 4. 2 Note: 예제에서는 태그 ID를 태그 이름에 매핑하는 Redis 해시와 같은 다른 데이터 구조가 있다고 가정합니다.. 올바른 Redis 명령을 사용하여 구현하기 쉬운 다른 사소한 작업이 있습니다. 예를 들어 태그 1, 2, 10 및 27을 함께 사용하는 모든 객체 목록을 원할 수 있습니다. 서로 다른 세트 간의 교차를 수행하는 SINTER 명령을 사용하여이 작업을 수행 할 수 있습니다. 우리는 사용할 수 있습니다: &gt; sinter tag:1:news tag:2:news tag:10:news tag:27:news ... results here ... 교차 외에도 합집합, 차이, 무작위 요소 추출 등을 수행할 수 있습니다.. 요소를 추출하는 명령을 SPOP라고 하며 특정 문제를 모델링하는 데 편리합니다. 예를 들어 웹 기반 포커 게임을 구현하려면 덱을 세트로 표현할 수 있습니다. (C) lubs, (D) iamonds, (H) earts, (S) pades에 대해 1 자 접두사를 사용한다고 상상해보십시오.: &gt; sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 SJ SQ SK (integer) 52 이제 각 플레이어에게 5장의 카드를 제공하고자 합니다. SPOP 명령은 임의의 요소를 제거하여 클라이언트로 반환하므로이 경우 완벽한 작업입니다. 그러나 덱에 대해 직접 호출하면 다음 게임 플레이에서 카드 덱을 다시 채워야 하므로 이상적이지 않을 수 있습니다. 먼저 덱 키에 저장된 세트의 복사본을 게임에 만들 수 있습니다 : 이 작업은 일반적으로 여러 집합 간의 합집합을 수행하고 결과를 다른 집합에 저장하는 SUNIONSTORE를 사용하여 수행됩니다.]]></summary></entry></feed>