<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-08T13:13:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Getting Start Redis - String</title><link href="http://localhost:4000/cache/string/" rel="alternate" type="text/html" title="Getting Start Redis - String" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/string</id><content type="html" xml:base="http://localhost:4000/cache/string/"><![CDATA[<h2 id="strings">Strings</h2>
<p>Redis 문자열 유형은 Redis 키와 연결할 수 있는 가장 간단한 값 유형입니다. Memcached의 유일한 데이터 유형이므로 신규 사용자가 Redis에서 사용하는 것도 매우 자연스러운 일입니다.
Redis 키는 문자열이므로 문자열 유형도 값으로 사용할 때 문자열을 다른 문자열에 매핑합니다. 문자열 데이터 형식은 HTML 조각 또는 페이지 캐싱과 같은 다양한 사용 사례에 유용합니다.
redis-cli를 사용하여 문자열 유형을 약간 사용해 보겠습니다<br />
(모든 예제는  이 자습서에서 redis-cli를 통해 수행됨).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey somevalue
OK
<span class="o">&gt;</span> get mykey
<span class="s2">"somevalue"</span>
</code></pre></div></div>

<p><a href="https://redis.io/commands/set">SET</a>과 <a href="https://redis.io/commands/get">GET</a> 명령을 사용하여 볼 수 있듯이  문자열 값을 설정하고 검색하는 방법입니다. <a href="https://redis.io/commands/set">SET</a>은 키가  문자열이 아닌 값과 연결된 경우에도 키가 이미 존재하는 경우 키에 이미 저장된 기존 값을 대체합니다. 따라서 <a href="https://redis.io/commands/set">SET</a>은 할당을 수행합니다.<br />
값은 모든 종류의 문자열 (바이너리 데이터 포함) 일 수 있습니다.</p>

<p>(예 : 값 안에 jpeg 이미지를 저장할 수 있음)<br />
값은 <strong>512MB</strong> 보다 클 수 없습니다.</p>

<p><a href="https://redis.io/commands/set">SET</a> 명령에는 추가 인수로 제공되는 흥미로운 옵션이 있습니다. 예를 들어  키가 이미 존재하는 경우 <a href="https://redis.io/commands/set">SET</a>에 실패하도록 요청하거나 그 반대로 키가 이미 존재하는 경우에만 성공하도록 요청할 수 있습니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey newval nx
<span class="o">(</span>nil<span class="o">)</span>
<span class="o">&gt;</span> <span class="nb">set </span>mykey newval xx
OK
</code></pre></div></div>

<p>문자열이 Redis의 기본 값이더라도 문자열로 수행할 수 있는 흥미로운 작업이 있습니다. 예를 들어, 하나는 <a href="https://ko.wikipedia.org/wiki/%EC%9B%90%EC%9E%90%EC%84%B1_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C)">원자성</a> 증분입니다.
원자성(atomicity)은 데이터베이스 시스템에서 ACID 트랜잭션 특성 중의 하나입니다. 하나의 원자 트랜잭션은 모두 성공하거나 또는 실패하는 데이터베이스 운용의 집합이다. 원자성의 보증은 데이터베이스의 부분적인 갱신으로 더 큰 문제가 야기되는 것을 방지합니다.
:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>counter 100
OK
<span class="o">&gt;</span> incr counter
<span class="o">(</span>integer<span class="o">)</span> 101
<span class="o">&gt;</span> incr counter
<span class="o">(</span>integer<span class="o">)</span> 102
<span class="o">&gt;</span> incrby counter 50
<span class="o">(</span>integer<span class="o">)</span> 152
</code></pre></div></div>

<p><a href="https://redis.io/commands/incr">INCR</a> 명령은 문자열 값을 정수로 구문 분석하고 1씩 증가시킨 다음 마지막으로 가져온 값을 새 값으로 설정합니다.<br />
<a href="https://redis.io/commands/incrby">INCRBY</a>, <a href="https://redis.io/commands/decr">DECR</a> 및 <a href="https://redis.io/commands/decrby">DECRBY</a>와 같은 다른 유사한 명령이 있습니다.<br />
내부적으로는 항상 동일한 명령이며 약간 다른 방식으로 작동합니다.<br />
<a href="https://redis.io/commands/incr">INCR</a>이 원자적이라는 것은 무엇을 의미합니까? 동일한 키에 대해 <a href="https://redis.io/commands/incr">INCR</a>을 발행하는 여러 클라이언트라도 경쟁 조건에 빠지지 않습니다. 예를 들어, 클라이언트 1은 “10”을 읽고 클라이언트 2는 동시에 “10”을 읽고 둘 다 11로 증가하고 새 값을 11로 설정하는 경우는 발생하지 않습니다. 최종 값은 항상 12이며 읽기-증분-집합 작업은 다른 모든 클라이언트가 동시에 명령을 실행하지 않는 동안 수행됩니다.<br />
문자열에서 작동하기위한 여러 명령이 있습니다.<br />
예를 들어, <a href="https://redis.io/commands/getset">GETSET</a> 명령은 키를 새 값으로 설정하고 이전 값을 결과로 리턴합니다.<br />
예를 들어 웹 사이트에서 새 방문자를 받을 때마다 <a href="https://redis.io/commands/incr">INCR</a>을 사용하여 Redis 키를 증가시키는 시스템이 있는 경우 이 명령을 사용할 수 있습니다. 이 정보는 한 번에 한 번씩 수집하여 증분을 한 번도 손실하지 않고 수집할 수 있습니다.  키를 <a href="https://redis.io/commands/getset">GETSET</a> 할 수 있으며  새 값 “0”을 할당하고 이전 값을 다시 읽을 수 있습니다.<br />
단일 명령에서 여러 키의 값을 설정하거나 검색하는 기능은 대기 시간을 줄이는 데에도 유용합니다.<br />
이러한 이유로 <a href="https://redis.io/commands/mset">MSET</a> 및 <a href="https://redis.io/commands/mget">MGET</a> 명령이 있습니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> mset a 10 b 20 c 30
OK
<span class="o">&gt;</span> mget a b c
1<span class="o">)</span> <span class="s2">"10"</span>
2<span class="o">)</span> <span class="s2">"20"</span>
3<span class="o">)</span> <span class="s2">"30"</span>
</code></pre></div></div>

<p>단일 명령에서 여러 키의 값을 설정하거나 검색하는 기능은 대기 시간을 줄이는 데에도 유용합니다. 이러한 이유로 MSET 및 MGET 명령이 있습니다.
Altering and querying the key space
특정 유형에 정의되지 않았지만 키 공간과 상호 작용하는 데 유용한 명령이 있으므로 모든 유형의 키와 함께 사용할 수 있습니다..
예를 들어, EXISTS 명령은  주어진 키가 데이터베이스에 존재하는지 여부를 알리기 위해 1 또는 0을 반환하는 반면, DEL 명령은 값이 무엇이든 키 및 관련 값을 삭제합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey hello
OK
<span class="o">&gt;</span> exists mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> del mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> exists mykey
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>

<p>예제에서  DEL 자체가 키가 제거되었는지 (존재했는지) 여부에 따라 1 또는 0을 반환하는 방법을 볼 수 있습니다 (해당 이름의 키가 없음)..
많은 키 공간 관련 명령이 있지만 위의 두 명령은  지정된 키에 저장된 값의 종류를 반환하는 TYPE 명령과 함께 필수적인 명령입니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey x
OK
<span class="o">&gt;</span> <span class="nb">type </span>mykey
string
<span class="o">&gt;</span> del mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> <span class="nb">type </span>mykey
none
</code></pre></div></div>
<p>Key expiration
계속 진행하기 전에 저장하는 값 유형에 관계없이 작동하는 중요한 Redis 기능인 키 만료를 살펴봐야 합니다. 키 만료를 사용하면 “Time to Live” 또는 “TTL”이라고도 하는 키에 대한 시간 제한을 설정할 수 있습니다. 생존 시간이 경과하면 키가 자동으로 파괴됩니다.</p>

<p><strong>키 만료에 대한 몇 가지 중요한 참고 사항:</strong><br />
•	초 또는 밀리초 정밀도를 사용하여 둘 다 설정할 수 있습니다.<br />
•	그러나 만료 시간 해상도는 항상 1밀리초입니다.<br />
•	만료에 대한 정보는 디스크에 복제되고 유지되며, Redis 서버가 중지된 상태로 유지되는 시간은 사실상 경과합니다.<br />
(즉, Redis는 키가 만료되는 날짜를 저장함).</p>

<p>EXPIRE 명령을 사용하여 키의 만료 설정:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>key some-value
OK
<span class="o">&gt;</span> expire key 5
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> get key <span class="o">(</span>immediately<span class="o">)</span>
<span class="s2">"some-value"</span>
<span class="o">&gt;</span> get key <span class="o">(</span>after some <span class="nb">time</span><span class="o">)</span>
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>
<p>두 번째 호출이 5초 이상 지연되었으므로 두 GET 호출 사이에 키가 사라졌습니다. 위의 예에서는  만료를 설정하기 위해 EXPIRE를 사용했습니다 (만료를 제거하고 키를 영원히 지속시키기 위해 PERSIST를 사용할 수있는  것처럼 이미 만료 된 키에 다른 만료를 설정하는 데에도 사용할 수  있습니다). 그러나 다른 Redis 명령을 사용하여 만료 된 키를 만들 수도 있습니다. 예를 들어 SET 옵션 사용:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>key 100 ex 10
OK
<span class="o">&gt;</span> ttl key
<span class="o">(</span>integer<span class="o">)</span> 9
</code></pre></div></div>
<p>위의 예제에서는 문자열 값이 100이고 만료 시간이 10초인 키를 설정합니다. 나중에  TTL 명령이 호출되어 키의 남은 생존 시간을 확인합니다.
밀리초 단위로 만료를 설정하고 확인하려면 <a href="https://redis.io/commands/pexpire">PEXPIRE</a> 및 <a href="https://redis.io/commands/pttl">PTTL</a> 명령과 SET 옵션의 전체 목록을 확인하십시오. .</p>

<h2 id="redis-정보">Redis 정보</h2>
<p><a href="https://sungwookkang.com/category/Redis">Data Science Lab</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Strings Redis 문자열 유형은 Redis 키와 연결할 수 있는 가장 간단한 값 유형입니다. Memcached의 유일한 데이터 유형이므로 신규 사용자가 Redis에서 사용하는 것도 매우 자연스러운 일입니다. Redis 키는 문자열이므로 문자열 유형도 값으로 사용할 때 문자열을 다른 문자열에 매핑합니다. 문자열 데이터 형식은 HTML 조각 또는 페이지 캐싱과 같은 다양한 사용 사례에 유용합니다. redis-cli를 사용하여 문자열 유형을 약간 사용해 보겠습니다 (모든 예제는 이 자습서에서 redis-cli를 통해 수행됨).]]></summary></entry><entry><title type="html">Getting Start Redis - List</title><link href="http://localhost:4000/cache/list/" rel="alternate" type="text/html" title="Getting Start Redis - List" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/list</id><content type="html" xml:base="http://localhost:4000/cache/list/"><![CDATA[<h2 id="list">List</h2>
<p>List 데이터 유형을 설명하려면 List라는 용어가  정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다.<br />
매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다:<br />
10,20,1,2,3은 목록입니다.<br />
그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다.<br />
Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. LPUSH 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는  1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다.<br />
단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현  된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다.<br />
Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다.<br />
큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.</p>

<p>First steps with Redis Lists
LPUSH 명령은  왼쪽(머리)의 목록에 새 요소를 추가하는 반면, RPUSH 명령은 오른쪽(맨 끝)의 목록에 새 요소를 추가합니다. 마지막으로 LRANGE 명령은 목록에서 요소 범위를 추출합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist A
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> rpush mylist B
<span class="o">(</span>integer<span class="o">)</span> 2
<span class="o">&gt;</span> lpush mylist first
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
</code></pre></div></div>
<p>LRANGE는  반환할 범위의 첫 번째 요소와 마지막 요소인 두 개의 인덱스를 사용합니다. 두 인덱스 모두 음수일 수 있으므로 Redis에게 끝에서 계산을 시작하도록 지시합니다. 따라서 -1은 마지막 요소이고 -2는 목록의 끝에서 두 번째 요소입니다.<br />
보시다시피 RPUSH는  목록의 오른쪽에 요소를 추가하고 최종 LPUSH는  왼쪽에 요소를 추가했습니다.<br />
두 명령 모두 가변 명령이므로 한 번의 호출로 여러 요소를 목록으로 자유롭게 푸시 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5 <span class="s2">"foo bar"</span>
<span class="o">(</span>integer<span class="o">)</span> 9
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
4<span class="o">)</span> <span class="s2">"1"</span>
5<span class="o">)</span> <span class="s2">"2"</span>
6<span class="o">)</span> <span class="s2">"3"</span>
7<span class="o">)</span> <span class="s2">"4"</span>
8<span class="o">)</span> <span class="s2">"5"</span>
9<span class="o">)</span> <span class="s2">"foo bar"</span>
</code></pre></div></div>

<p>Redis 목록에 정의된 중요한 작업은 요소를 팝하는 기능입니다. 요소를 팝핑하는 작업은 목록에서 요소를 검색하는 동시에 목록에서 제거하는 작업입니다. 목록의 양쪽에 요소를 푸시하는 방법과 유사하게 왼쪽과 오른쪽에서 요소를 팝 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist a b c
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> rpop mylist
<span class="s2">"c"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"b"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"a"</span>
</code></pre></div></div>

<p>세 개의 요소를 추가하고 세 개의 요소를 팝했으므로 이 명령 시퀀스가 끝나면 목록이 비어 있고 더 이상 팝업할 요소가 없습니다. 또 다른 요소를 터뜨리려고 하면 이것이 우리가 얻는 결과입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p>Redis는 목록에 요소가 없음을 알리기 위해 NULL 값을 반환했습니다.<br />
Common use cases for lists
목록은 여러 작업에 유용하며 두 가지 매우 대표적인 사용 사례는 다음과 같습니다.:<br />
•	사용자가 소셜 네트워크에 게시 한 최신 업데이트 기억.<br />
•	생산자가 항목을 목록으로 푸시하고 소비자(일반적으로 작업자)가 해당 항목을 소비하고 작업을 실행하는 소비자-생산자 패턴을 사용하는 프로세스 간의 통신입니다. Redis에는 이 사용 사례를 보다 안정적이고 효율적으로 만드는 특수 목록 명령이 있습니다.</p>

<p>예를 들어 인기있는 Ruby 라이브러리 resque와 sidekiq는  백그라운드 작업을 구현하기 위해 내부적으로 Redis 목록을 사용합니다.<br />
인기있는 트위터 소셜 네트워크는 사용자가 게시 한 최신 트윗을 Redis 목록으로 가져옵니다.<br />
일반적인 사용 사례를 단계별로 설명하기 위해 홈페이지에 사진 공유 소셜 네트워크에 게시된 최신 사진이 표시되고 액세스 속도를 높이고 싶다고 가정해 보겠습니다.<br />
•	사용자가 새 사진을 게시 할 때마다 LPUSH를 사용하여 ID를 목록에 추가합니다.<br />
•	사용자가 홈페이지를 방문하면 LRANGE 0 9를 사용하여  최신 10 개의 게시 된 항목을 가져옵니다.</p>

<p>Capped lists
많은 사용 사례에서 우리는 목록을 사용하여 소셜 네트워크 업데이트, 로그 또는 기타 무엇이든 최신 항목을 저장하려고합니다.<br />
Redis를 사용하면 목록을 제한 된 컬렉션으로 사용할 수 있으며 최신 N 항목 만 기억하고 LTRIM 명령을 사용하여 가장 오래된 항목을 모두 삭제할 수 있습니다.<br />
LTRIM 명령은 LRANGE와 유사하지만 지정된 요소 범위를 표시하는 대신 이 범위를 새 목록 값으로 설정합니다. 주어진 범위를 벗어난 모든 요소가 제거됩니다.<br />
An example will make it more clear:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5
<span class="o">(</span>integer<span class="o">)</span> 5
<span class="o">&gt;</span> ltrim mylist 0 2
OK
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"1"</span>
2<span class="o">)</span> <span class="s2">"2"</span>
3<span class="o">)</span> <span class="s2">"3"</span>
</code></pre></div></div>

<p>위의 LTRIM 명령은 Redis에게 인덱스 0에서 2까지의 목록 요소 만 가져 오도록 지시하고 다른 모든 것은 삭제됩니다. 이것은 매우 간단하지만 유용한 패턴을 허용합니다 :<br />
목록 푸시 작업 + 목록 트리밍 작업을 함께 수행하여 새 요소를 추가하고 제한을 초과하는 요소를 삭제합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LPUSH mylist &lt;some element&gt;
LTRIM mylist 0 999
</code></pre></div></div>

<p>위의 조합은 새 요소를 추가하고 1000개의 최신 요소만 목록에 가져옵니다. LRANGE를 사용하면 아주 오래된 데이터를 기억할 필요없이 상위 항목에 액세스 할 수 있습니다.<br />
Note: LRANGE는 기술적으로 O (N) 명령이지만 목록의 머리 또는 꼬리쪽으로 작은 범위에 액세스하는 것은 일정한 시간 작업입니다.</p>

<p>Blocking operations on lists<br />
목록에는 대기열을 구현하는 데 적합한 특수 기능이 있으며 일반적으로 프로세스 간 통신 시스템의 빌딩 블록으로 사용됩니다. 차단 작업.
하나의 프로세스가있는 목록으로 항목을 푸시하고 실제로 해당 항목으로 어떤 종류의 작업을 수행하기 위해 다른 프로세스를 사용한다고 가정 해보십시오. 이것은 일반적인 생산자 / 소비자 설정이며 다음과 같은 간단한 방법으로 구현할 수 있습니다.:<br />
•	항목을 목록에 푸시하기 위해 생산자는 LPUSH를 호출합니다.<br />
•	목록에서 항목을 추출/처리하기 위해 소비자는 RPOP를 호출합니다.</p>

<p>그러나 때로는 목록이 비어 있고 처리 할 것이 없으므로 RPOP는  NULL을 반환합니다. 이 경우 소비자는 잠시 기다렸다가 RPOP를 사용하여 다시 시도해야 합니다. 이것을 폴링이라고하며 몇 가지 단점이 있기 때문에이 맥락에서 좋은 생각이 아닙니다.:</p>
<ol>
  <li>Redis와 클라이언트가 쓸모없는 명령을 처리하도록합니다 (목록이 비어있을 때 모든 요청은 실제 작업을 수행하지 않고 NULL을 반환합니다).</li>
  <li>작업자가 NULL을 받은 후 잠시 기다리므로 항목 처리에 지연을 추가합니다. 지연을 줄이기 위해 RPOP에 대한 호출 사이에 더 적은 대기 시간을 할애할 수 있으며, 문제 번호 1, 즉 Redis에 대한 더 쓸모없는 호출을 증폭시키는 효과가 있습니다.</li>
</ol>

<p>따라서 Redis는 목록이 비어 있는 경우 차단할 수 있는 RPOP 및 LPOP 버전인 BRPOP 및 BLPOP라는 명령을 구현합니다. 새  요소가 목록에 추가되거나 사용자 지정 시간 초과에 도달할 때만 호출자에게 반환됩니다. .
이것은  작업자에서 사용할 수 있는 BRPOP 호출의 예입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> brpop tasks 5
1<span class="o">)</span> <span class="s2">"tasks"</span>
2<span class="o">)</span> <span class="s2">"do_something"</span>
</code></pre></div></div>
<p>즉, “목록 작업의 요소를 기다리지 만 5 초 후에 사용할 수있는 요소가 없으면 반환합니다.”.<br />
요소를 영원히 기다리는 시간 제한으로 0을 사용할 수 있으며, 동시에 여러 목록에서 대기하고 첫 번째 목록이 요소를 받을 때 알림을 받기 위해 하나가 아닌 여러 목록을 지정할 수도 있습니다.<br />
BRPOP에 대해 주의해야 할 몇 가지 사항:</p>
<ol>
  <li>클라이언트는 정렬된 방식으로 제공됩니다: 목록 대기를 차단한 첫 번째 클라이언트는 다른 클라이언트에 의해 요소가 푸시될 때 먼저 제공됩니다.</li>
  <li>반환 값은 RPOP와 다릅니다 : BRPOP 및 BLPOP이  여러 목록의 요소를 기다리는 것을 차단할 수 있기 때문에 키 이름도 포함하므로 2 요소 배열입니다.</li>
  <li>시간 제한에 도달하면 NULL이 반환됩니다.</li>
</ol>

<p>목록 및 차단 작업에 대해 알아야 할 사항이 더 있습니다. 다음에 대해 자세히 읽어 보시기 바랍니다.:<br />
•	LMOVE를 사용하여 더 안전한 대기열 또는 순환 대기열을 구축할 수 있습니다.<br />
•	BLMOVE라는 명령의 차단 변형도 있습니다.</p>

<p>Automatic creation and removal of keys
지금까지 예제에서는 요소를 푸시하기 전에 빈 목록을 만들거나 더 이상 내부에 요소가 없을 때 빈 목록을 제거 할 필요가 없었습니다. 목록이 비어있을 때 키를 삭제하거나 키가 존재하지 않고 요소를 추가하려는 경우 빈 목록을 만드는 것은 Redis의 책임입니다 (예 : LPUSH를 사용하여).</p>

<p>이는 목록에만 국한된 것이 아니라 여러 요소(스트림, 집합, 정렬된 집합 및 해시)로 구성된 모든 Redis 데이터 형식에 적용됩니다.
기본적으로 세 가지 규칙으로 행동을 요약 할 수 있습니다.:</p>
<ol>
  <li>집계 데이터 형식에 요소를 추가할 때 대상 키가 없으면 요소를 추가하기 전에 빈 집계 데이터 형식이 만들어집니다.</li>
  <li>집계 데이터 유형에서 요소를 제거할 때 값이 비어 있으면 키가 자동으로 삭제됩니다. Stream 데이터 형식은 이 규칙의 유일한 예외입니다.</li>
  <li>LLEN(목록의 길이를 반환함)과 같은 읽기 전용 명령 또는 빈 키를 사용하여 요소를 제거하는 쓰기 명령을 호출하면 키가 명령이 찾을 것으로 예상되는 유형의 빈 집계 유형을 보유하고 있는 경우와 항상 동일한 결과가 생성됩니다.</li>
</ol>

<p>Examples of rule 1:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
</code></pre></div></div>
<p>However we can’t perform operations against the wrong type if the key exists:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>foo bar
OK
<span class="o">&gt;</span> lpush foo 1 2 3
</code></pre></div></div>
<p>(error) WRONGTYPE Operation against a key holding the wrong kind of value</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">type </span>foo
string
</code></pre></div></div>
<p>Example of rule 2:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpop mylist
<span class="s2">"3"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"2"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"1"</span>
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p>The key no longer exists after all the elements are popped.<br />
Example of rule 3:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> llen mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> lpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[List List 데이터 유형을 설명하려면 List라는 용어가 정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다. 매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다: 10,20,1,2,3은 목록입니다. 그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다. Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. LPUSH 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는 1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다. 단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현 된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다. Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다. 큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Key 규칙</title><link href="http://localhost:4000/cache/naming-rule/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Key 규칙" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/naming%20rule</id><content type="html" xml:base="http://localhost:4000/cache/naming-rule/"><![CDATA[<h2 id="기본-redis-데이터-형식-및-사용-방법">기본 Redis 데이터 형식 및 사용 방법</h2>
<p>다음은 Redis CLI를 사용하여 핵심 <a href="https://redis.io/docs/data-types/">Redis 데이터 유형</a>을 학습하는 실습 자습서입니다.  데이터 형식에 대한 일반적인 개요는 데이터 형식 소개를 참조하세요.</p>
<h4 id="keys">Keys</h4>
<p>Redis 키는 바이너리로부터 안전하므로 “foo”와 같은 문자열에서 JPEG 파일의 내용에 이르기까지 모든 바이너리 시퀀스를 키로 사용할 수 있습니다. 빈 문자열도 유효한 키입니다.</p>

<p><strong>Redis  Key에 대한 몇 가지 다른 규칙:</strong><br />
•	<em>매우 긴 키는 좋은 생각이 아닙니다</em><br />
예를 들어 1024바이트의 키는 메모리 측면에서 뿐만 아니라 데이터 세트에서 키를 조회하는 데 비용이 많이 드는 여러 키 비교가 필요할 수 있기 때문에 좋지 않습니다. <br />
당면한 작업이 큰 값의 존재와 일치하는 경우에도 특히 메모리 및 대역폭의 관점에서 해시하는 것이 더 좋습니다<br />
(예 : SHA1 사용).</p>

<p>•	<em>매우 짧은 키는 종종 좋은 생각이 아닙니다</em><br />
대신 “user:1000:followers”를 쓸 수 있다면 “u1000flw”를 키로 쓰는 것은 거의 의미가 없습니다. 후자는 더 읽기 쉽고 추가 된 공간은 키 객체 자체와 값 객체에서 사용하는 공간에 비해 작습니다.<br />
짧은 키는 분명히 메모리를 조금 덜 소비하지만 올바른 균형을 찾는 것이 키 설계자의 역량입니다.</p>

<p>•	<em>키를 구분자를 이용하여 그룹으로 분류</em><br />
예를 들어 “object-type:id”는 “user:1000”에서와 같이 <strong>콜론(:)</strong> 을 구분자하여 그룹을 만드는 것은 좋은 생각입니다. 점 또는 대시는 “comment:4321:reply.to” 또는 “comment:4321:reply-to”와 같이 여러 단어로 된 필드에 자주 사용됩니다.</p>

<p>•	<em>허용 된 최대 키 크기는 512MB입니다.</em></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[기본 Redis 데이터 형식 및 사용 방법 다음은 Redis CLI를 사용하여 핵심 Redis 데이터 유형을 학습하는 실습 자습서입니다. 데이터 형식에 대한 일반적인 개요는 데이터 형식 소개를 참조하세요. Keys Redis 키는 바이너리로부터 안전하므로 “foo”와 같은 문자열에서 JPEG 파일의 내용에 이르기까지 모든 바이너리 시퀀스를 키로 사용할 수 있습니다. 빈 문자열도 유효한 키입니다.]]></summary></entry><entry><title type="html">Getting Start Redis using Jupyter Notebook - 설치</title><link href="http://localhost:4000/cache/setup-jupyter/" rel="alternate" type="text/html" title="Getting Start Redis using Jupyter Notebook - 설치" /><published>2023-03-29T00:00:00+09:00</published><updated>2023-03-29T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-jupyter</id><content type="html" xml:base="http://localhost:4000/cache/setup-jupyter/"><![CDATA[<p>Jupyter Notebook을 이용하여 Redis를 실습할 수 있는 환경을 구성합니다.</p>

<h2 id="setup-redis-on-docker">Setup Redis on Docker</h2>
<p>설치형 redis를 하지않고 학습용으로 최적의 환경인 docker를 사용하여 간단히 Redis를 실행합니다.
아래의 docker-compose.yaml 파일을 작성하고 작성된 폴더위치에서 다음과 같이 docker-compose를 실행하여 redis를 실행합니다.
그러면 redis docker image를 pull 받아서 background로 실행합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
    <span class="na">redis</span><span class="pi">:</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">redis:alpine</span>
      <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --port </span><span class="m">6379</span>
      <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">name=redis"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">mode=standalone"</span>
      <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">6379:6379</span>
</code></pre></div></div>
<h4 id="run-redis">Run redis</h4>
<p>docker-compose 를 사용하여 redis를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>

<h2 id="setup-jupyter-using-docker">Setup Jupyter using Docker</h2>
<p>Jupyter notebook을 이용하여 GUI 환경에서 Python을 이용하여 Redis를 실습할 수 있습니다.<br />
아래의 <a href="https://yoonjk.github.io/docker/jupyter/">링크</a>를 통해 Jupyter Notebook을 docker-compose 파일을 작성하고 아래와 같이 실행합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
docker logs <span class="nt">-f</span> jupyter
</code></pre></div></div>

<p>브라우저에서 http://localhost:0000 으로 접속하면 패스워드 변경화면이 나타납니다.<br />
위에서 docker log에서 token 값을 확인 후<br />
<img src="/assets/images/cache/01-cache-jupyter-log.png" alt="Jupyter log" /></p>

<p>아래와 같이 token값을 입력하고 패스워드를 입력하고 Log in and set new password 버튼을 클릭합니다.</p>

<p><img src="/assets/images/cache/02-cache-setup-a-password.png" alt="Jupyter log" /></p>

<p>Jupyter Home 화면이 아래와 같이 출력됩니다.
<img src="/assets/images/cache/03-cache-jupyter-home.png" alt="Jupyter log" /></p>

<p>Notebook category에서 python3를 선택합니다.<br />
<img src="/assets/images/cache/04-cache-python3-notebook.png" alt="Jupyter log" /></p>

<p>python에서 redis를 연결하기 위해 redis-py module을 설치해야 합니다. 다음과 같이 notebook에 입력하고 실행버튼을 클릭하여 redis-py module을 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!</span>pip <span class="nb">install </span>redis
</code></pre></div></div>

<p><img src="/assets/images/cache/05-cache-pip-install-redis.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Jupyter Notebook을 이용하여 Redis를 실습할 수 있는 환경을 구성합니다.]]></summary></entry><entry><title type="html">Getting Start Redis using Jupyter Notebook - get/set</title><link href="http://localhost:4000/cache/getting-starting-jupyter/" rel="alternate" type="text/html" title="Getting Start Redis using Jupyter Notebook - get/set" /><published>2023-03-29T00:00:00+09:00</published><updated>2023-03-29T00:00:00+09:00</updated><id>http://localhost:4000/cache/getting-starting-jupyter</id><content type="html" xml:base="http://localhost:4000/cache/getting-starting-jupyter/"><![CDATA[<p>Jupyter Notebook을 환경에서 Python을 이용하여 Redis를 알아봅니다. redis-py를 이용하여 redis를 연결하고, 다음과 같이 데이터를 set/get을 수행하여 결과를 확인합니다.</p>
<h2 id="connect">Connect</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis</span>

<span class="n">redisClient</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">decode_responses</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">redisClient</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="s">'bar'</span><span class="p">)</span>
<span class="n">redisClient</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'foo'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/cache/06-cache-get-set.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Jupyter Notebook을 환경에서 Python을 이용하여 Redis를 알아봅니다. redis-py를 이용하여 redis를 연결하고, 다음과 같이 데이터를 set/get을 수행하여 결과를 확인합니다. Connect ```python import redis]]></summary></entry><entry><title type="html">DTO에서 null인 항목은 json에서 제거</title><link href="http://localhost:4000/springboot/remove-null-dto/" rel="alternate" type="text/html" title="DTO에서 null인 항목은 json에서 제거" /><published>2023-03-28T00:00:00+09:00</published><updated>2023-03-28T00:00:00+09:00</updated><id>http://localhost:4000/springboot/remove-null-dto</id><content type="html" xml:base="http://localhost:4000/springboot/remove-null-dto/"><![CDATA[<h2 id="dto에서-null인-항목은-json에서-제거">DTO에서 null인 항목은 json에서 제거</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ToString</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CodeDto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">code</span><span class="o">;</span>

    <span class="nd">@JsonInclude</span><span class="o">(</span><span class="nc">Include</span><span class="o">.</span><span class="na">NON_NULL</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">codeName</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="Advice" /><summary type="html"><![CDATA[DTO에서 null인 항목은 json에서 제거 ```java @ToString @Getter @Setter public class CodeDto { private int code;]]></summary></entry><entry><title type="html">Docker을 이용하여 Jupyter 실행</title><link href="http://localhost:4000/docker/jupyter/" rel="alternate" type="text/html" title="Docker을 이용하여 Jupyter 실행" /><published>2023-03-27T00:00:00+09:00</published><updated>2023-03-27T00:00:00+09:00</updated><id>http://localhost:4000/docker/jupyter</id><content type="html" xml:base="http://localhost:4000/docker/jupyter/"><![CDATA[<h2 id="run-jupyter-using-docker">Run Jupyter using docker</h2>

<p>Docker 기반 Jupyter 실행<br />
유형1</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">-p</span> 10000:8888 <span class="nt">-v</span> <span class="s2">"</span><span class="k">${</span><span class="nv">PWD</span><span class="k">}</span><span class="s2">"</span>:/home/jovyan/work jupyter/datascience-notebook
</code></pre></div></div>

<p>유형2</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-p</span> 10000:8888 jupyter/scipy-notebook
</code></pre></div></div>

<h2 id="run-jupyter-using-docker-compose">Run Jupyter using docker-compose</h2>
<p>docker-compose를 사용하여 Jupyter를 실행합니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.9"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">jupyter</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">jupyter</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">jupyter/datascience-notebook</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">10000:8888"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">${PWD}:/home/jovyan/work</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="Jupyter" /><summary type="html"><![CDATA[Run Jupyter using docker]]></summary></entry><entry><title type="html">Controller에서 응답을 암호화하여 내보내기 - ResponseBodyAdvice</title><link href="http://localhost:4000/springboot/responsebodyadvice/" rel="alternate" type="text/html" title="Controller에서 응답을 암호화하여 내보내기 - ResponseBodyAdvice" /><published>2023-03-24T00:00:00+09:00</published><updated>2023-03-24T00:00:00+09:00</updated><id>http://localhost:4000/springboot/responsebodyadvice</id><content type="html" xml:base="http://localhost:4000/springboot/responsebodyadvice/"><![CDATA[<h2 id="responsebodyadvice">ResponseBodyAdvice</h2>
<p>Http Response를 제어 또는 가공(Decrpt)할 수 있는 또 하나의 영역중 하나가 바로를 ReponseBodyAdvice 입니다.
  ReturnValueHandler는 RestController에는 적용할 수 없습니다. RequestBodyAdvice는 그러한 제약사항이 없습니다.
  적용하는 방법은 RequestBodyAdvice와 유사합니다.</p>

<p><img src="/assets/images/springboot/04-spring-filter-interceptor-aop-resolver-advice.png" alt="filter interceptor aop" /></p>

<h2 id="responsebodyadvice를-상속받아-구현">ResponseBodyAdvice를 상속받아 구현</h2>
<p>Http 요청을 했을 때 body 데이터를 제어하고자 할 떄 RequestBodyAdvice를 상속받아 아래와 같이 3개의 Method를 구현해야 합니다.</p>
<ul>
  <li>public boolean supports(…)</li>
  <li>public Object beforeBodyWrite(…)</li>
</ul>

<p>supports에서는 대상 Controller나 대상 Parameter Type에 따라 대상을 선택할 수 있습니다. 
beforeBodyWrite 는 사용자 Controller에서 받은 return 값을 가공할 수 있는 영역입니다.
선택된 converter를 이용하여 json으로 변환하기 직전에 호출되는 것이다.<br />
사용하는 주요 용도로 아래와 같이</p>
<ul>
  <li>로깅</li>
  <li>Decrypt</li>
</ul>

<p>로 사용할 수 있는 영역입니다. 다음 예제는 ResponseBodyAdvice를 Decrypt 로 사용하고 있습니다.</p>

<h2 id="responsebodyadvice를---예시">ResponseBodyAdvice를 - 예시</h2>
<p>아래의 예제는 ResponseBodyAdvice를 구현한 EncryptResponseBodyAdvice입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.core.MethodParameter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.MediaType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.converter.HttpMessageConverter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.server.ServerHttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.server.ServerHttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.lang.Nullable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestControllerAdvice</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.demo.microservices.controller.UserController</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.demo.microservices.util.AESUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.ObjectMapper</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>

<span class="nd">@Slf4j</span>
<span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EncryptAdviceController</span> <span class="kd">implements</span> <span class="nc">ResponseBodyAdvice</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;{</span>
	<span class="cm">/**
	 * Whether this component supports the given controller method return type
	 * and the selected {@code HttpMessageConverter} type.
	 * @param returnType the return type
	 * @param converterType the selected converter type
	 * @return {@code true} if {@link #beforeBodyWrite} should be invoked;
	 * {@code false} otherwise
	 */</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">supports</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">returnType</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">HttpMessageConverter</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">converterType</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"------------ beforeBodyRead ------------ "</span><span class="o">);</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"------------ supports"</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">returnType</span><span class="o">.</span><span class="na">getContainingClass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="nc">UserController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * Invoked after an {@code HttpMessageConverter} is selected and just before
	 * its write method is invoked.
	 * @param body the body to be written
	 * @param returnType the return type of the controller method
	 * @param selectedContentType the content type selected through content negotiation
	 * @param selectedConverterType the converter type selected to write to the response
	 * @param request the current request
	 * @param response the current response
	 * @return the body that was passed in or a modified (possibly new) instance
	 */</span>
	<span class="nd">@Nullable</span>
	<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">beforeBodyWrite</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Object</span> <span class="n">body</span><span class="o">,</span> <span class="nc">MethodParameter</span> <span class="n">returnType</span><span class="o">,</span> <span class="nc">MediaType</span> <span class="n">selectedContentType</span><span class="o">,</span>
			<span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">HttpMessageConverter</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">selectedConverterType</span><span class="o">,</span>
			<span class="nc">ServerHttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">ServerHttpResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
		<span class="nc">String</span> <span class="n">responseMessage</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">AESUtil</span> <span class="n">aesUtil</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AESUtil</span><span class="o">();</span>
        
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">responseMessage</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
	    <span class="kt">byte</span><span class="o">[]</span> <span class="n">encRawData</span> <span class="o">=</span> <span class="n">aesUtil</span><span class="o">.</span><span class="na">encrypt</span><span class="o">(</span><span class="n">responseMessage</span><span class="o">).</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
	    <span class="n">response</span><span class="o">.</span><span class="na">getBody</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">encRawData</span><span class="o">);</span>
	    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"encData:{}"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encRawData</span><span class="o">));</span>
	    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"orgBody:{}"</span><span class="o">,</span><span class="n">body</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
		<span class="o">}</span>
		
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="Advice" /><summary type="html"><![CDATA[ResponseBodyAdvice Http Response를 제어 또는 가공(Decrpt)할 수 있는 또 하나의 영역중 하나가 바로를 ReponseBodyAdvice 입니다. ReturnValueHandler는 RestController에는 적용할 수 없습니다. RequestBodyAdvice는 그러한 제약사항이 없습니다. 적용하는 방법은 RequestBodyAdvice와 유사합니다.]]></summary></entry><entry><title type="html">Http 요청을 복호화하여 Controller에 전달하기 - RequestBodyAdvice</title><link href="http://localhost:4000/springboot/requestbodyadvisor/" rel="alternate" type="text/html" title="Http 요청을 복호화하여 Controller에 전달하기 - RequestBodyAdvice" /><published>2023-03-24T00:00:00+09:00</published><updated>2023-03-24T00:00:00+09:00</updated><id>http://localhost:4000/springboot/requestbodyadvisor</id><content type="html" xml:base="http://localhost:4000/springboot/requestbodyadvisor/"><![CDATA[<p>화</p>
<h2 id="requestbodyadvice">RequestBodyAdvice</h2>
<p>Http Request를 제어 또는 가공(Decrpt)할 수 있는 또 하나의 영역중 하나가 바로 RequestBodyAdvice 입니다.
  ArgumentRoslver는 RestController에는 약간의 제약사항이 있으나 RequestBodyAdvice는 그러한 제약사항이 없습니다.
  적용하는 방법은 ArgumentResolver와 유사하고 점도 섬세한 제어가 가능합니다.</p>

<p><img src="/assets/images/springboot/04-spring-filter-interceptor-aop-resolver-advice.png" alt="filter interceptor aop" /></p>

<h2 id="requestbodyadvice를-상속받아-구현">RequestBodyAdvice를 상속받아 구현</h2>
<p>Http 요청을 했을 때 body 데이터를 제어하고자 할 떄 RequestBodyAdvice를 상속받아 아래와 같이 3개의 Method를 구현해야 합니다.</p>
<ul>
  <li>public boolean supports(…)</li>
  <li>public HttpInputMessage beforeBodyRead(…) throws IOException</li>
  <li>public Object afterBodyRead(…)</li>
</ul>

<p>supports에서는 대상 Controller나 대상 Parameter Type에 따라 대상을 선택할 수 있습니다. 
beforeBodyRead 는 Http Body를 읽기전에 처리하거나 afterBodyRead 는 Http Body를 읽은후에 처리합니다.<br />
beforeBodyRead에서는 inputMessage의 getHeader와 getBody를 읽어서와 원하는 작업을 할 수 있수 있습니다.
afterBodyRead는  Controller의 Input Type을 body로 넘어오며 그것을 가공할 수 있습니다.</p>

<h2 id="requestbodyadvice---예시">RequestBodyAdvice - 예시</h2>
<p>아래의 예제는 RequestBodyAdvice를 구현한 DecryptRequestBodyAdvice입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.ByteArrayInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.core.MethodParameter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.HttpHeaders</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.HttpInputMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.converter.HttpMessageConverter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestControllerAdvice</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.mvc.method.annotation.RequestBodyAdvice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.demo.microservices.controller.UserController</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.demo.microservices.util.AESUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.demo.microservices.util.IOUtils</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>

<span class="nd">@Slf4j</span>
<span class="nd">@RestControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecryptRequestBodyController</span> <span class="kd">implements</span> <span class="nc">RequestBodyAdvice</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">decodingBody</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">rawData</span><span class="o">;</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">supports</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">methodParameter</span><span class="o">,</span> <span class="nc">Type</span> <span class="n">targetType</span><span class="o">,</span>
			<span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">HttpMessageConverter</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">converterType</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"------------ DecryptRequestBodyController ------------ "</span><span class="o">);</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"supports:{}"</span><span class="o">,</span> <span class="n">methodParameter</span><span class="o">.</span><span class="na">getContainingClass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="nc">UserController</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
		<span class="k">return</span> <span class="n">methodParameter</span><span class="o">.</span><span class="na">getContainingClass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="nc">UserController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">HttpInputMessage</span> <span class="nf">beforeBodyRead</span><span class="o">(</span><span class="nc">HttpInputMessage</span> <span class="n">inputMessage</span><span class="o">,</span> <span class="nc">MethodParameter</span> <span class="n">parameter</span><span class="o">,</span> <span class="nc">Type</span> <span class="n">targetType</span><span class="o">,</span>
			<span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">HttpMessageConverter</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">converterType</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"------------ beforeBodyRead ------------ "</span><span class="o">);</span>

		<span class="nc">HttpHeaders</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">inputMessage</span><span class="o">.</span><span class="na">getHeaders</span><span class="o">();</span>
		<span class="nc">AESUtil</span> <span class="n">aesUtil</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AESUtil</span><span class="o">();</span>

		<span class="k">try</span> <span class="o">{</span>
			<span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="n">inputMessage</span><span class="o">.</span><span class="na">getBody</span><span class="o">();</span>
			<span class="n">rawData</span> <span class="o">=</span> <span class="nc">IOUtils</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">(</span><span class="n">inputStream</span><span class="o">);</span>
			<span class="n">decodingBody</span> <span class="o">=</span> <span class="n">aesUtil</span><span class="o">.</span><span class="na">decrypt</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">rawData</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
			<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"decodingBody:{}"</span><span class="o">,</span> <span class="n">decodingBody</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="k">return</span> <span class="k">new</span> <span class="nf">DecodeHttpInputMessage</span><span class="o">(</span><span class="n">headers</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">decodingBody</span><span class="o">.</span><span class="na">getBytes</span><span class="o">()));</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">afterBodyRead</span><span class="o">(</span><span class="nc">Object</span> <span class="n">body</span><span class="o">,</span> <span class="nc">HttpInputMessage</span> <span class="n">inputMessage</span><span class="o">,</span> <span class="nc">MethodParameter</span> <span class="n">parameter</span><span class="o">,</span> <span class="nc">Type</span> <span class="n">targetType</span><span class="o">,</span>
			<span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">HttpMessageConverter</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">converterType</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"------------ afterBodyRead ------------ "</span><span class="o">);</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"body:{}"</span><span class="o">,</span> <span class="n">body</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">body</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">handleEmptyBody</span><span class="o">(</span><span class="nc">Object</span> <span class="n">body</span><span class="o">,</span> <span class="nc">HttpInputMessage</span> <span class="n">inputMessage</span><span class="o">,</span> <span class="nc">MethodParameter</span> <span class="n">parameter</span><span class="o">,</span>
			<span class="nc">Type</span> <span class="n">targetType</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">HttpMessageConverter</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">converterType</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"handleEmptyBody "</span><span class="o">,</span> <span class="n">targetType</span><span class="o">);</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"body:{}"</span><span class="o">,</span> <span class="n">body</span><span class="o">);</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"targetType:{}"</span><span class="o">,</span> <span class="n">targetType</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">body</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>DecodeHttpInputMessage.java 파일입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.http.HttpHeaders</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.http.HttpInputMessage</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecodeHttpInputMessage</span> <span class="kd">implements</span> <span class="nc">HttpInputMessage</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">HttpHeaders</span> <span class="n">headers</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">InputStream</span> <span class="n">body</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">DecodeHttpInputMessage</span><span class="o">(</span><span class="nc">HttpHeaders</span> <span class="n">headers</span><span class="o">,</span> <span class="nc">InputStream</span> <span class="n">body</span><span class="o">)</span> <span class="o">{</span>
		<span class="kd">super</span><span class="o">();</span>
		<span class="k">this</span><span class="o">.</span><span class="na">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">body</span> <span class="o">=</span> <span class="n">body</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">HttpHeaders</span> <span class="nf">getHeaders</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">// TODO Auto-generated method stub</span>
		<span class="k">return</span> <span class="n">headers</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">InputStream</span> <span class="nf">getBody</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
		<span class="c1">// TODO Auto-generated method stub</span>
		<span class="k">return</span> <span class="n">body</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="Advice" /><summary type="html"><![CDATA[화 RequestBodyAdvice Http Request를 제어 또는 가공(Decrpt)할 수 있는 또 하나의 영역중 하나가 바로 RequestBodyAdvice 입니다. ArgumentRoslver는 RestController에는 약간의 제약사항이 있으나 RequestBodyAdvice는 그러한 제약사항이 없습니다. 적용하는 방법은 ArgumentResolver와 유사하고 점도 섬세한 제어가 가능합니다.]]></summary></entry><entry><title type="html">ArgumentResolver</title><link href="http://localhost:4000/springboot/argumentResolver/" rel="alternate" type="text/html" title="ArgumentResolver" /><published>2023-03-13T00:00:00+09:00</published><updated>2023-03-13T00:00:00+09:00</updated><id>http://localhost:4000/springboot/argumentResolver</id><content type="html" xml:base="http://localhost:4000/springboot/argumentResolver/"><![CDATA[<h2 id="argumentresolver">ArgumentResolver</h2>
<p>Http Request를 제어 또는 가공(Decrpt)할 수 있는 또 하나의 영역중 하나가 바로 ArgumentResolver 입니다.
  ArgumentRoslver는 Request 데이터를 가공하여 Constroller에 전달하고 싶을 때 사용합니다.
  제어할 때상으로는 아래와 같은 유형을 대상으로 ArgumentResolver를 적용할 수 있습니다.</p>

<ul>
  <li>적용대상 Controller</li>
  <li>Annotation 이용</li>
  <li>Argument Type 등</li>
</ul>

<p><img src="/assets/images/springboot/04-spring-filter-interceptor-aop-resolver-advice.png" alt="filter interceptor aop" /></p>

<h2 id="handlermethodargumentresolver-상속하여-구현">HandlerMethodArgumentResolver 상속하여 구현</h2>
<p>ArgumentResolver를 이용하여 Http 요청의 데이터를 가공하고 싶을 때는 HandlerMethodArgumentResolver 상속받아 구현하면 됩니다. HandlerMethodArgumentResolver는 아래의 2개의 Method를 구현해야 합니다.</p>

<ul>
  <li>public boolean supportsParameter(MethodParameter parameter)</li>
  <li>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webReq터est, WebDataBinderFactory binderFactory) throws Exception</li>
</ul>

<p>첫번째는 ArgumentResolver를 적용할 대상을 선정하는 부분입니다. 여기에서 대상 Controller나 Annotation인 경우 return 을 true로 반환하면 resolveArgument 가 실행되어 webRequest에서 데이터를 읽어서 원하는 형식의 데이터를 만들어 반환하면 됩니다.</p>

<p>## 예시</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.core.MethodParameter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.support.WebDataBinderFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.context.request.NativeWebRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.method.support.HandlerMethodArgumentResolver</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.method.support.ModelAndViewContainer</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.demo.microservices.annotation.Decrypted</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.demo.microservices.util.AESUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.demo.microservices.util.IOUtils</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.ObjectMapper</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>

<span class="nd">@Slf4j</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecryptArgumentResolver</span> <span class="kd">implements</span> <span class="nc">HandlerMethodArgumentResolver</span> <span class="o">{</span>
	

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">supportsParameter</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">parameter</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"supportsParameter:{}"</span><span class="o">,</span> <span class="n">parameter</span><span class="o">.</span><span class="na">getContainingClass</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">parameter</span><span class="o">.</span><span class="na">hasParameterAnnotation</span><span class="o">(</span><span class="nc">Decrypted</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        		<span class="n">parameter</span><span class="o">.</span><span class="na">getParameterType</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Map</span> <span class="nf">resolveArgument</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">parameter</span><span class="o">,</span> <span class="nc">ModelAndViewContainer</span> <span class="n">mavContainer</span><span class="o">,</span>
			<span class="nc">NativeWebRequest</span> <span class="n">webRequest</span><span class="o">,</span> <span class="nc">WebDataBinderFactory</span> <span class="n">binderFactory</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
		<span class="nc">HttpServletRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpServletRequest</span><span class="o">)</span> <span class="n">webRequest</span><span class="o">.</span><span class="na">getNativeRequest</span><span class="o">();</span>
		<span class="kt">byte</span><span class="o">[]</span> <span class="n">rawData</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="nc">String</span> <span class="n">decodingBody</span><span class="o">;</span>
		<span class="nc">Map</span> <span class="n">reqMap</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		
        <span class="k">try</span> <span class="o">{</span>
        	<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"decodingBody:"</span><span class="o">);</span>
            <span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
            <span class="n">rawData</span> <span class="o">=</span> <span class="nc">IOUtils</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">(</span><span class="n">inputStream</span><span class="o">);</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"rawData:{}"</span><span class="o">,</span> <span class="n">rawData</span><span class="o">);</span>
            <span class="nc">AESUtil</span> <span class="n">aesUtil</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AESUtil</span><span class="o">();</span>
            <span class="n">decodingBody</span> <span class="o">=</span> <span class="n">aesUtil</span><span class="o">.</span><span class="na">decrypt</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">rawData</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="n">reqMap</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">decodingBody</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"decodingBody:{}"</span><span class="o">,</span> <span class="n">decodingBody</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
		<span class="k">return</span> <span class="n">reqMap</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="Resolver" /><summary type="html"><![CDATA[ArgumentResolver Http Request를 제어 또는 가공(Decrpt)할 수 있는 또 하나의 영역중 하나가 바로 ArgumentResolver 입니다. ArgumentRoslver는 Request 데이터를 가공하여 Constroller에 전달하고 싶을 때 사용합니다. 제어할 때상으로는 아래와 같은 유형을 대상으로 ArgumentResolver를 적용할 수 있습니다.]]></summary></entry></feed>