<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-09T00:58:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Redis Sentinel 구성</title><link href="http://localhost:4000/cache/setup-sentinel-redis/" rel="alternate" type="text/html" title="Redis Sentinel 구성" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-sentinel-redis</id><content type="html" xml:base="http://localhost:4000/cache/setup-sentinel-redis/"><![CDATA[<h2 id="redis-sentinel-구성">Redis Sentinel 구성</h2>
<p>Redis를 다음의 <a href="https://yoonjk.github.io/cache/install-redis/">링크</a>를 참조하여 설치합니다.</p>

<p>Redis 를 HA 구성하는 방법은 몇가지 방법은 아래와 같이 구성할 수 있습니다. 첫번째 방법은 Master가 장애가 발생하면 서비스 장애가 발생하는 구성이지만 구성은 간단합니다. 두번째 방법 Sentinel 방법은 Redis Master가 장애가 발생하여도 slave가 master로 승격되어 지속적인 서비스가 가능합니다. 장애가 발생했던 master가 복귀되면 이전의 master는 slave 역할로 서비스를 합니다.
마지막 방법은 Redis 구성은 이전 방법보다는 복잡하지만 좀더 낳은 고가용성을 제공하면서 처리량을 높이는 방법입니다.<br />
이번 글에서는 Redis Sentinel을 구을해 봅니다.</p>

<ul>
  <li>Redis Master and Slave</li>
  <li>Redis Sentinel</li>
  <li>Redis Cluster</li>
</ul>

<h2 id="redis-환경설정">redis 환경설정</h2>
<p>redis sentinel을 구성하기 위해 redis master/slave 를 위한 환경설정을 합니다.</p>
<ul>
  <li>redis config 구성</li>
  <li>sentinel config 구성</li>
</ul>

<p>redis master config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf redis_6382.conf
vi redis_6382.conf

<span class="c"># 포트 설정</span>
port 각자포트
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
logfile logs/redis_6382.log
</code></pre></div></div>

<p>redis slave config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6382.conf redis_6383.conf 
<span class="nb">cp </span>redis_6382.conf redis_6384.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6383/g'</span> redis_6383.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6384/g'</span> redis_6384.conf 

<span class="c"># slave1</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf

<span class="c"># slave2</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
</code></pre></div></div>

<h4 id="redis-sentinel-config-구성">redis sentinel config 구성</h4>
<p>redis sentinel config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>sentinel.conf redis_5000.conf
vi redis_5000.conf

<span class="c"># 포트 설정</span>
port 5000
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
<span class="nb">dir</span> <span class="s2">"./"</span>
logfile <span class="s2">"logs/redis_5000.log"</span>
<span class="c"># 감시할 마스터 정보 및 쿼럼(quorum) 설정</span>
sentinel monitor mymaster 127.0.0.1 6382 2
<span class="c"># 다운 되었다고 인지하는 시간 (3초)</span>
- 마스터 서버에 정기적으로 PING을 보내는데, 이 시간 동안 응답이 없으면 다운된 것으로 판단하고 장애조치<span class="o">(</span>failover<span class="o">)</span> 작업을 시작합니다
sentinel down-after-milliseconds mymaster 3000
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_5000.conf redis_5001.conf
<span class="nb">cp </span>redis_5000.conf redis_5002.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5001/g'</span> redis_5001.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5002/g'</span> redis_5002.conf 
</code></pre></div></div>

<h2 id="redis-실행">redis 실행</h2>
<p>Redis 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis_6382.conf
src/redis-server redis_6383.conf
src/redis-server redis_6384.conf
</code></pre></div></div>

<p>Redis Sentinel 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/sentinel-server redis_5000.conf
src/sentinel-server redis_5001.conf
src/sentinel-server redis_5002.conf
</code></pre></div></div>

<h2 id="redis-failover-테스트">redis failover 테스트</h2>
<p>redis master를 강제 종료시 slave가 master로 승격되는 확인하기 위해, sentinel 서버의 로그를 모니터링 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tail</span> <span class="nt">-f</span> logs/redis_5000.log
</code></pre></div></div>
<p>redis master process를 확인하고 서버를 강제로 종료합니다.<br />
그러면 sentinel에서 자동으로 redis slave를 master로 승격하는 것을 확인 할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis

<span class="c"># redis master pid를 확인</span>
<span class="nb">kill</span> <span class="nt">-9</span> redis_master_pid
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/15">5분 안에 구축하는 Redis-Sentinel</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 구성 Redis를 다음의 링크를 참조하여 설치합니다.]]></summary></entry><entry><title type="html">Redis 설치 - Centos</title><link href="http://localhost:4000/cache/install-redis/" rel="alternate" type="text/html" title="Redis 설치 - Centos" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/install%20redis</id><content type="html" xml:base="http://localhost:4000/cache/install-redis/"><![CDATA[<h2 id="redis-설치-준비">Redis 설치 준비</h2>
<p>Redis를 다음의 절차로 설치합니다.</p>
<ul>
  <li>OS 업데이트</li>
  <li>Development Tools 설치</li>
  <li>redis download</li>
  <li>redis build</li>
  <li>redis install</li>
</ul>

<p>Centos7 OS 버전을 최신으로 업그레이드 하고, Development Tools를 설치합니다. Redis <a href="http://download.redis.io/releases/">download</a> site 에 가서 원하는 redis 를 확인하고 address link를 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum update <span class="nt">-y</span>
yum groupinstall <span class="s1">'Development Tools'</span>
<span class="nb">sudo </span>wget http://download.redis.io/releases/redis-7.0.10.tar.gz
<span class="nb">tar </span>xvzf redis-7.0.10.tar.gz
<span class="nb">cd </span>redis-7.0.10
</code></pre></div></div>
<p>Redis 압축파일을 해제한 후 make 명령어를 수행하면 아래처럼 jemalloc No such file or directory 오류가 발생합니다.
이를 해결하기 위해서는 deps 폴더에서 compile을 해야합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
<span class="nb">cd </span>deps
make hiredis jemalloc linenoise lua
<span class="nb">cd</span> ..
</code></pre></div></div>
<p>Redis 압축 해제했던 폴더로 되돌아와서 다시 build합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-7.0.10</span>
make
make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="redis-서버-실행">Redis 서버 실행</h2>
<p>redis 를 install 후 redis 서버를 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis.conf
</code></pre></div></div>

<p>redis를 접속하기 위해 terminal을 1개 열어 redis가 설치된 서버에 접속합니다.
src 폴더에 있는 redis-cli를 이용하여 redis 서버에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli
<span class="nb">set </span>k1 v1
get k1
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://mozi.tistory.com/536">꽁담</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis 설치 준비 Redis를 다음의 절차로 설치합니다. OS 업데이트 Development Tools 설치 redis download redis build redis install]]></summary></entry><entry><title type="html">Getting Start Redis - String</title><link href="http://localhost:4000/cache/string/" rel="alternate" type="text/html" title="Getting Start Redis - String" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/string</id><content type="html" xml:base="http://localhost:4000/cache/string/"><![CDATA[<h2 id="strings">Strings</h2>
<p>Redis 문자열 유형은 Redis 키와 연결할 수 있는 가장 간단한 값 유형입니다. Memcached의 유일한 데이터 유형이므로 신규 사용자가 Redis에서 사용하는 것도 매우 자연스러운 일입니다.
Redis 키는 문자열이므로 문자열 유형도 값으로 사용할 때 문자열을 다른 문자열에 매핑합니다. 문자열 데이터 형식은 HTML 조각 또는 페이지 캐싱과 같은 다양한 사용 사례에 유용합니다.
redis-cli를 사용하여 문자열 유형을 약간 사용해 보겠습니다<br />
(모든 예제는  이 자습서에서 redis-cli를 통해 수행됨).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey somevalue
OK
<span class="o">&gt;</span> get mykey
<span class="s2">"somevalue"</span>
</code></pre></div></div>

<p><a href="https://redis.io/commands/set">SET</a>과 <a href="https://redis.io/commands/get">GET</a> 명령을 사용하여 볼 수 있듯이  문자열 값을 설정하고 검색하는 방법입니다. <a href="https://redis.io/commands/set">SET</a>은 키가  문자열이 아닌 값과 연결된 경우에도 키가 이미 존재하는 경우 키에 이미 저장된 기존 값을 대체합니다. 따라서 <a href="https://redis.io/commands/set">SET</a>은 할당을 수행합니다.<br />
값은 모든 종류의 문자열 (바이너리 데이터 포함) 일 수 있습니다.</p>

<p>(예 : 값 안에 jpeg 이미지를 저장할 수 있음)<br />
값은 <strong>512MB</strong> 보다 클 수 없습니다.</p>

<p><a href="https://redis.io/commands/set">SET</a> 명령에는 추가 인수로 제공되는 흥미로운 옵션이 있습니다. 예를 들어  키가 이미 존재하는 경우 <a href="https://redis.io/commands/set">SET</a>에 실패하도록 요청하거나 그 반대로 키가 이미 존재하는 경우에만 성공하도록 요청할 수 있습니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey newval nx
<span class="o">(</span>nil<span class="o">)</span>
<span class="o">&gt;</span> <span class="nb">set </span>mykey newval xx
OK
</code></pre></div></div>

<p>문자열이 Redis의 기본 값이더라도 문자열로 수행할 수 있는 흥미로운 작업이 있습니다. 예를 들어, 하나는 <a href="https://ko.wikipedia.org/wiki/%EC%9B%90%EC%9E%90%EC%84%B1_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C)">원자성</a> 증분입니다.
원자성(atomicity)은 데이터베이스 시스템에서 ACID 트랜잭션 특성 중의 하나입니다. 하나의 원자 트랜잭션은 모두 성공하거나 또는 실패하는 데이터베이스 운용의 집합이다. 원자성의 보증은 데이터베이스의 부분적인 갱신으로 더 큰 문제가 야기되는 것을 방지합니다.
:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>counter 100
OK
<span class="o">&gt;</span> incr counter
<span class="o">(</span>integer<span class="o">)</span> 101
<span class="o">&gt;</span> incr counter
<span class="o">(</span>integer<span class="o">)</span> 102
<span class="o">&gt;</span> incrby counter 50
<span class="o">(</span>integer<span class="o">)</span> 152
</code></pre></div></div>

<p><a href="https://redis.io/commands/incr">INCR</a> 명령은 문자열 값을 정수로 구문 분석하고 1씩 증가시킨 다음 마지막으로 가져온 값을 새 값으로 설정합니다.<br />
<a href="https://redis.io/commands/incrby">INCRBY</a>, <a href="https://redis.io/commands/decr">DECR</a> 및 <a href="https://redis.io/commands/decrby">DECRBY</a>와 같은 다른 유사한 명령이 있습니다.<br />
내부적으로는 항상 동일한 명령이며 약간 다른 방식으로 작동합니다.<br />
<a href="https://redis.io/commands/incr">INCR</a>이 원자적이라는 것은 무엇을 의미합니까? 동일한 키에 대해 <a href="https://redis.io/commands/incr">INCR</a>을 발행하는 여러 클라이언트라도 경쟁 조건에 빠지지 않습니다. 예를 들어, 클라이언트 1은 “10”을 읽고 클라이언트 2는 동시에 “10”을 읽고 둘 다 11로 증가하고 새 값을 11로 설정하는 경우는 발생하지 않습니다. 최종 값은 항상 12이며 읽기-증분-집합 작업은 다른 모든 클라이언트가 동시에 명령을 실행하지 않는 동안 수행됩니다.<br />
문자열에서 작동하기위한 여러 명령이 있습니다.<br />
예를 들어, <a href="https://redis.io/commands/getset">GETSET</a> 명령은 키를 새 값으로 설정하고 이전 값을 결과로 리턴합니다.<br />
예를 들어 웹 사이트에서 새 방문자를 받을 때마다 <a href="https://redis.io/commands/incr">INCR</a>을 사용하여 Redis 키를 증가시키는 시스템이 있는 경우 이 명령을 사용할 수 있습니다. 이 정보는 한 번에 한 번씩 수집하여 증분을 한 번도 손실하지 않고 수집할 수 있습니다.  키를 <a href="https://redis.io/commands/getset">GETSET</a> 할 수 있으며  새 값 “0”을 할당하고 이전 값을 다시 읽을 수 있습니다.<br />
단일 명령에서 여러 키의 값을 설정하거나 검색하는 기능은 대기 시간을 줄이는 데에도 유용합니다.<br />
이러한 이유로 <a href="https://redis.io/commands/mset">MSET</a> 및 <a href="https://redis.io/commands/mget">MGET</a> 명령이 있습니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> mset a 10 b 20 c 30
OK
<span class="o">&gt;</span> mget a b c
1<span class="o">)</span> <span class="s2">"10"</span>
2<span class="o">)</span> <span class="s2">"20"</span>
3<span class="o">)</span> <span class="s2">"30"</span>
</code></pre></div></div>

<p>단일 명령에서 여러 키의 값을 설정하거나 검색하는 기능은 대기 시간을 줄이는 데에도 유용합니다. 이러한 이유로 MSET 및 MGET 명령이 있습니다.
Altering and querying the key space
특정 유형에 정의되지 않았지만 키 공간과 상호 작용하는 데 유용한 명령이 있으므로 모든 유형의 키와 함께 사용할 수 있습니다..
예를 들어, EXISTS 명령은  주어진 키가 데이터베이스에 존재하는지 여부를 알리기 위해 1 또는 0을 반환하는 반면, DEL 명령은 값이 무엇이든 키 및 관련 값을 삭제합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey hello
OK
<span class="o">&gt;</span> exists mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> del mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> exists mykey
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>

<p>예제에서  DEL 자체가 키가 제거되었는지 (존재했는지) 여부에 따라 1 또는 0을 반환하는 방법을 볼 수 있습니다 (해당 이름의 키가 없음)..
많은 키 공간 관련 명령이 있지만 위의 두 명령은  지정된 키에 저장된 값의 종류를 반환하는 TYPE 명령과 함께 필수적인 명령입니다.:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>mykey x
OK
<span class="o">&gt;</span> <span class="nb">type </span>mykey
string
<span class="o">&gt;</span> del mykey
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> <span class="nb">type </span>mykey
none
</code></pre></div></div>
<p>Key expiration
계속 진행하기 전에 저장하는 값 유형에 관계없이 작동하는 중요한 Redis 기능인 키 만료를 살펴봐야 합니다. 키 만료를 사용하면 “Time to Live” 또는 “TTL”이라고도 하는 키에 대한 시간 제한을 설정할 수 있습니다. 생존 시간이 경과하면 키가 자동으로 파괴됩니다.</p>

<p><strong>키 만료에 대한 몇 가지 중요한 참고 사항:</strong><br />
•	초 또는 밀리초 정밀도를 사용하여 둘 다 설정할 수 있습니다.<br />
•	그러나 만료 시간 해상도는 항상 1밀리초입니다.<br />
•	만료에 대한 정보는 디스크에 복제되고 유지되며, Redis 서버가 중지된 상태로 유지되는 시간은 사실상 경과합니다.<br />
(즉, Redis는 키가 만료되는 날짜를 저장함).</p>

<p>EXPIRE 명령을 사용하여 키의 만료 설정:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>key some-value
OK
<span class="o">&gt;</span> expire key 5
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> get key <span class="o">(</span>immediately<span class="o">)</span>
<span class="s2">"some-value"</span>
<span class="o">&gt;</span> get key <span class="o">(</span>after some <span class="nb">time</span><span class="o">)</span>
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>
<p>두 번째 호출이 5초 이상 지연되었으므로 두 GET 호출 사이에 키가 사라졌습니다. 위의 예에서는  만료를 설정하기 위해 EXPIRE를 사용했습니다 (만료를 제거하고 키를 영원히 지속시키기 위해 PERSIST를 사용할 수있는  것처럼 이미 만료 된 키에 다른 만료를 설정하는 데에도 사용할 수  있습니다). 그러나 다른 Redis 명령을 사용하여 만료 된 키를 만들 수도 있습니다. 예를 들어 SET 옵션 사용:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>key 100 ex 10
OK
<span class="o">&gt;</span> ttl key
<span class="o">(</span>integer<span class="o">)</span> 9
</code></pre></div></div>
<p>위의 예제에서는 문자열 값이 100이고 만료 시간이 10초인 키를 설정합니다. 나중에  TTL 명령이 호출되어 키의 남은 생존 시간을 확인합니다.
밀리초 단위로 만료를 설정하고 확인하려면 <a href="https://redis.io/commands/pexpire">PEXPIRE</a> 및 <a href="https://redis.io/commands/pttl">PTTL</a> 명령과 SET 옵션의 전체 목록을 확인하십시오. .</p>

<h2 id="redis-정보">Redis 정보</h2>
<p><a href="https://sungwookkang.com/category/Redis">Data Science Lab</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Strings Redis 문자열 유형은 Redis 키와 연결할 수 있는 가장 간단한 값 유형입니다. Memcached의 유일한 데이터 유형이므로 신규 사용자가 Redis에서 사용하는 것도 매우 자연스러운 일입니다. Redis 키는 문자열이므로 문자열 유형도 값으로 사용할 때 문자열을 다른 문자열에 매핑합니다. 문자열 데이터 형식은 HTML 조각 또는 페이지 캐싱과 같은 다양한 사용 사례에 유용합니다. redis-cli를 사용하여 문자열 유형을 약간 사용해 보겠습니다 (모든 예제는 이 자습서에서 redis-cli를 통해 수행됨).]]></summary></entry><entry><title type="html">Getting Start Redis - Hashes</title><link href="http://localhost:4000/cache/hashes/" rel="alternate" type="text/html" title="Getting Start Redis - Hashes" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/hashes</id><content type="html" xml:base="http://localhost:4000/cache/hashes/"><![CDATA[<h2 id="hashes">Hashes</h2>
<p>Redis 해시는 필드-값 쌍을 사용하여 “해시”가 어떻게 보이는지 정확히 보여줍니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hset user:1000 username antirez birthyear 1977 verified 1
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> hget user:1000 username
<span class="s2">"antirez"</span>
<span class="o">&gt;</span> hget user:1000 birthyear
<span class="s2">"1977"</span>
<span class="o">&gt;</span> hgetall user:1000
1<span class="o">)</span> <span class="s2">"username"</span>
2<span class="o">)</span> <span class="s2">"antirez"</span>
3<span class="o">)</span> <span class="s2">"birthyear"</span>
4<span class="o">)</span> <span class="s2">"1977"</span>
5<span class="o">)</span> <span class="s2">"verified"</span>
6<span class="o">)</span> <span class="s2">"1"</span>
</code></pre></div></div>
<p>해시는 객체를 나타내는 데 편리하지만 실제로 해시 안에 넣을 수있는 필드 수에는 사용 가능한 메모리 이외의 실질적인 제한이 없으므로 응용 프로그램 내에서 다양한 방법으로 해시를 사용할 수 있습니다.<br />
<a href="https://redis.io/commands/hset">HSET</a> 명령은  해시의 여러 필드를 설정하는 반면 HGET는 단일 필드를 검색합니다.</p>

<p><a href="https://redis.io/commands/hmget">HMGET</a>은 HGET와 유사  하지만 값 배열을 반환합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hmget user:1000 username birthyear no-such-field
1<span class="o">)</span> <span class="s2">"antirez"</span>
2<span class="o">)</span> <span class="s2">"1977"</span>
3<span class="o">)</span> <span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p><a href="https://redis.io/commands/hincrby">HINCRBY</a>와 같이 개별 필드에 대한 작업을 수행 할 수있는 명령도 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hincrby user:1000 birthyear 10
<span class="o">(</span>integer<span class="o">)</span> 1987
<span class="o">&gt;</span> hincrby user:1000 birthyear 10
<span class="o">(</span>integer<span class="o">)</span> 1997
</code></pre></div></div>
<p>설명서에서 해시 명령의 전체 목록을 찾을 수 있습니다.
작은 해시 (즉, 작은 값을 가진 몇 가지 요소)가 메모리에서 특별한 방식으로 인코딩되어 메모리 효율이 매우 높다는 점은 주목할 가치가 있습니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Hashes Redis 해시는 필드-값 쌍을 사용하여 “해시”가 어떻게 보이는지 정확히 보여줍니다.: &gt; hset user:1000 username antirez birthyear 1977 verified 1 (integer) 3 &gt; hget user:1000 username "antirez" &gt; hget user:1000 birthyear "1977" &gt; hgetall user:1000 1) "username" 2) "antirez" 3) "birthyear" 4) "1977" 5) "verified" 6) "1" 해시는 객체를 나타내는 데 편리하지만 실제로 해시 안에 넣을 수있는 필드 수에는 사용 가능한 메모리 이외의 실질적인 제한이 없으므로 응용 프로그램 내에서 다양한 방법으로 해시를 사용할 수 있습니다. HSET 명령은 해시의 여러 필드를 설정하는 반면 HGET는 단일 필드를 검색합니다.]]></summary></entry><entry><title type="html">Getting Start Redis - List</title><link href="http://localhost:4000/cache/list/" rel="alternate" type="text/html" title="Getting Start Redis - List" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/list</id><content type="html" xml:base="http://localhost:4000/cache/list/"><![CDATA[<h2 id="list">List</h2>
<p>List 데이터 유형을 설명하려면 List라는 용어가  정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다.<br />
매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다:<br />
10,20,1,2,3은 목록입니다.<br />
그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다.<br />
Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. <a href="https://redis.io/commands/lpush">LPUSH</a> 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는  1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다.<br />
단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현  된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다.<br />
Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다.<br />
큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.</p>

<p>First steps with Redis Lists
<a href="https://redis.io/commands/lpush">LPUSH</a> 명령은  왼쪽(머리)의 목록에 새 요소를 추가하는 반면, <a href="https://redis.io/commands/rpush">RPUSH</a> 명령은 오른쪽(맨 끝)의 목록에 새 요소를 추가합니다. 마지막으로 <a href="https://redis.io/commands/lrange">LRANGE</a> 명령은 목록에서 요소 범위를 추출합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist A
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> rpush mylist B
<span class="o">(</span>integer<span class="o">)</span> 2
<span class="o">&gt;</span> lpush mylist first
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
</code></pre></div></div>
<p><a href="https://redis.io/commands/lrange">LRANGE</a>는  반환할 범위의 첫 번째 요소와 마지막 요소인 두 개의 인덱스를 사용합니다. 두 인덱스 모두 음수일 수 있으므로 Redis에게 끝에서 계산을 시작하도록 지시합니다. 따라서 -1은 마지막 요소이고 -2는 목록의 끝에서 두 번째 요소입니다.<br />
보시다시피 <a href="https://redis.io/commands/rpush">RPUSH</a>는  목록의 오른쪽에 요소를 추가하고 최종 <a href="https://redis.io/commands/lpush">LPUSH</a>는  왼쪽에 요소를 추가했습니다.<br />
두 명령 모두 가변 명령이므로 한 번의 호출로 여러 요소를 목록으로 자유롭게 푸시 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5 <span class="s2">"foo bar"</span>
<span class="o">(</span>integer<span class="o">)</span> 9
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
4<span class="o">)</span> <span class="s2">"1"</span>
5<span class="o">)</span> <span class="s2">"2"</span>
6<span class="o">)</span> <span class="s2">"3"</span>
7<span class="o">)</span> <span class="s2">"4"</span>
8<span class="o">)</span> <span class="s2">"5"</span>
9<span class="o">)</span> <span class="s2">"foo bar"</span>
</code></pre></div></div>

<p>Redis 목록에 정의된 중요한 작업은 요소를 팝하는 기능입니다. 요소를 팝핑하는 작업은 목록에서 요소를 검색하는 동시에 목록에서 제거하는 작업입니다. 목록의 양쪽에 요소를 푸시하는 방법과 유사하게 왼쪽과 오른쪽에서 요소를 팝 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist a b c
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> rpop mylist
<span class="s2">"c"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"b"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"a"</span>
</code></pre></div></div>

<p>세 개의 요소를 추가하고 세 개의 요소를 팝했으므로 이 명령 시퀀스가 끝나면 목록이 비어 있고 더 이상 팝업할 요소가 없습니다. 또 다른 요소를 터뜨리려고 하면 이것이 우리가 얻는 결과입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p>Redis는 목록에 요소가 없음을 알리기 위해 NULL 값을 반환했습니다.</p>

<p>Common use cases for lists
목록은 여러 작업에 유용하며 두 가지 매우 대표적인 사용 사례는 다음과 같습니다.:<br />
•	사용자가 소셜 네트워크에 게시 한 최신 업데이트 기억.<br />
•	생산자가 항목을 목록으로 푸시하고 소비자(일반적으로 작업자)가 해당 항목을 소비하고 작업을 실행하는 소비자-생산자 패턴을 사용하는 프로세스 간의 통신입니다. Redis에는 이 사용 사례를 보다 안정적이고 효율적으로 만드는 특수 목록 명령이 있습니다.</p>

<p>예를 들어 인기있는 Ruby 라이브러리 resque와 sidekiq는  백그라운드 작업을 구현하기 위해 내부적으로 Redis 목록을 사용합니다.<br />
인기있는 트위터 소셜 네트워크는 사용자가 게시 한 최신 트윗을 Redis 목록으로 가져옵니다.<br />
일반적인 사용 사례를 단계별로 설명하기 위해 홈페이지에 사진 공유 소셜 네트워크에 게시된 최신 사진이 표시되고 액세스 속도를 높이고 싶다고 가정해 보겠습니다.<br />
•	사용자가 새 사진을 게시 할 때마다 LPUSH를 사용하여 ID를 목록에 추가합니다.<br />
•	사용자가 홈페이지를 방문하면 <a href="https://redis.io/commands/lrange">LRANGE</a> 0 9를 사용하여  최신 10 개의 게시 된 항목을 가져옵니다.</p>

<p>Capped lists
많은 사용 사례에서 우리는 목록을 사용하여 소셜 네트워크 업데이트, 로그 또는 기타 무엇이든 최신 항목을 저장하려고합니다.<br />
Redis를 사용하면 목록을 제한 된 컬렉션으로 사용할 수 있으며 최신 N 항목 만 기억하고 <a href="https://redis.io/commands/ltrim">LTRIM</a> 명령을 사용하여 가장 오래된 항목을 모두 삭제할 수 있습니다.<br />
<a href="https://redis.io/commands/ltrim">LTRIM</a> 명령은 <a href="https://redis.io/commands/lrange">LRANGE</a>와 유사하지만 지정된 요소 범위를 표시하는 대신 이 범위를 새 목록 값으로 설정합니다. 주어진 범위를 벗어난 모든 요소가 제거됩니다.<br />
An example will make it more clear:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5
<span class="o">(</span>integer<span class="o">)</span> 5
<span class="o">&gt;</span> ltrim mylist 0 2
OK
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"1"</span>
2<span class="o">)</span> <span class="s2">"2"</span>
3<span class="o">)</span> <span class="s2">"3"</span>
</code></pre></div></div>

<p>위의 <a href="https://redis.io/commands/ltrim">LTRIM</a> 명령은 Redis에게 인덱스 0에서 2까지의 목록 요소 만 가져 오도록 지시하고 다른 모든 것은 삭제됩니다. 이것은 매우 간단하지만 유용한 패턴을 허용합니다 :<br />
목록 푸시 작업 + 목록 트리밍 작업을 함께 수행하여 새 요소를 추가하고 제한을 초과하는 요소를 삭제합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LPUSH mylist &lt;some element&gt;
LTRIM mylist 0 999
</code></pre></div></div>

<p>위의 조합은 새 요소를 추가하고 1000개의 최신 요소만 목록에 가져옵니다. <a href="https://redis.io/commands/lrange">LRANGE</a>를 사용하면 아주 오래된 데이터를 기억할 필요없이 상위 항목에 액세스 할 수 있습니다.<br />
Note: <a href="https://redis.io/commands/lrange">LRANGE</a>는 기술적으로 O (N) 명령이지만 목록의 머리 또는 꼬리쪽으로 작은 범위에 액세스하는 것은 일정한 시간 작업입니다.</p>

<p>Blocking operations on lists<br />
목록에는 대기열을 구현하는 데 적합한 특수 기능이 있으며 일반적으로 프로세스 간 통신 시스템의 빌딩 블록으로 사용됩니다. 차단 작업.
하나의 프로세스가있는 목록으로 항목을 푸시하고 실제로 해당 항목으로 어떤 종류의 작업을 수행하기 위해 다른 프로세스를 사용한다고 가정 해보십시오. 이것은 일반적인 생산자 / 소비자 설정이며 다음과 같은 간단한 방법으로 구현할 수 있습니다.:<br />
•	항목을 목록에 푸시하기 위해 생산자는 <a href="https://redis.io/commands/lpush">LPUSH</a>를 호출합니다.<br />
•	목록에서 항목을 추출/처리하기 위해 소비자는 <a href="https://redis.io/commands/rpop">RPOP</a>를 호출합니다.</p>

<p>그러나 때로는 목록이 비어 있고 처리 할 것이 없으므로 RPOP는  NULL을 반환합니다. 이 경우 소비자는 잠시 기다렸다가 RPOP를 사용하여 다시 시도해야 합니다. 이것을 폴링이라고하며 몇 가지 단점이 있기 때문에이 맥락에서 좋은 생각이 아닙니다.:</p>
<ol>
  <li>Redis와 클라이언트가 쓸모없는 명령을 처리하도록합니다 (목록이 비어있을 때 모든 요청은 실제 작업을 수행하지 않고 NULL을 반환합니다).</li>
  <li>작업자가 NULL을 받은 후 잠시 기다리므로 항목 처리에 지연을 추가합니다. 지연을 줄이기 위해 RPOP에 대한 호출 사이에 더 적은 대기 시간을 할애할 수 있으며, 문제 번호 1, 즉 Redis에 대한 더 쓸모없는 호출을 증폭시키는 효과가 있습니다.</li>
</ol>

<p>따라서 Redis는 목록이 비어 있는 경우 차단할 수 있는 <a href="https://redis.io/commands/rpop">RPOP</a> 및 <a href="https://redis.io/commands/lpop">LPOP</a> 버전인 <a href="https://redis.io/commands/brpop">BRPOP</a> 및 <a href="https://redis.io/commands/blpop">BLPOP</a>라는 명령을 구현합니다. 새  요소가 목록에 추가되거나 사용자 지정 시간 초과에 도달할 때만 호출자에게 반환됩니다.<br />
이것은  작업자에서 사용할 수 있는 <a href="https://redis.io/commands/brpop">BRPOP</a> 호출의 예입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> brpop tasks 5
1<span class="o">)</span> <span class="s2">"tasks"</span>
2<span class="o">)</span> <span class="s2">"do_something"</span>
</code></pre></div></div>
<p>즉, “목록 작업의 요소를 기다리지 만 5 초 후에 사용할 수있는 요소가 없으면 반환합니다.”.<br />
요소를 영원히 기다리는 시간 제한으로 0을 사용할 수 있으며, 동시에 여러 목록에서 대기하고 첫 번째 목록이 요소를 받을 때 알림을 받기 위해 하나가 아닌 여러 목록을 지정할 수도 있습니다.</p>

<p>BRPOP에 대해 주의해야 할 몇 가지 사항:</p>
<ol>
  <li>클라이언트는 정렬된 방식으로 제공됩니다: 목록 대기를 차단한 첫 번째 클라이언트는 다른 클라이언트에 의해 요소가 푸시될 때 먼저 제공됩니다.</li>
  <li>반환 값은 <a href="https://redis.io/commands/rpop">RPOP</a>와 다릅니다 : <a href="https://redis.io/commands/brpop">BRPOP</a> 및 <a href="https://redis.io/commands/blpop">BLPOP</a>이  여러 목록의 요소를 기다리는 것을 차단할 수 있기 때문에 키 이름도 포함하므로 2 요소 배열입니다.</li>
  <li>시간 제한에 도달하면 NULL이 반환됩니다.</li>
</ol>

<p>목록 및 차단 작업에 대해 알아야 할 사항이 더 있습니다. 다음에 대해 자세히 읽어 보시기 바랍니다.:<br />
•	<a href="https://redis.io/commands/lmove">LMOVE</a>를 사용하여 더 안전한 대기열 또는 순환 대기열을 구축할 수 있습니다.<br />
•	<a href="https://redis.io/commands/blmove">BLMOVE</a>라는 명령의 차단 변형도 있습니다.</p>

<p>Automatic creation and removal of keys
지금까지 예제에서는 요소를 푸시하기 전에 빈 목록을 만들거나 더 이상 내부에 요소가 없을 때 빈 목록을 제거 할 필요가 없었습니다. 목록이 비어있을 때 키를 삭제하거나 키가 존재하지 않고 요소를 추가하려는 경우 빈 목록을 만드는 것은 Redis의 책임입니다 
(예 : <a href="https://redis.io/commands/lpush">LPUSH</a>를 사용하여).</p>

<p>이는 목록에만 국한된 것이 아니라 여러 요소(스트림, 집합, 정렬된 집합 및 해시)로 구성된 모든 Redis 데이터 형식에 적용됩니다.
기본적으로 세 가지 규칙으로 행동을 요약 할 수 있습니다.:</p>
<ol>
  <li>집계 데이터 형식에 요소를 추가할 때 대상 키가 없으면 요소를 추가하기 전에 빈 집계 데이터 형식이 만들어집니다.</li>
  <li>집계 데이터 유형에서 요소를 제거할 때 값이 비어 있으면 키가 자동으로 삭제됩니다. Stream 데이터 형식은 이 규칙의 유일한 예외입니다.</li>
  <li><a href="https://redis.io/commands/llen">LLEN</a>(목록의 길이를 반환함)과 같은 읽기 전용 명령 또는 빈 키를 사용하여 요소를 제거하는 쓰기 명령을 호출하면 키가 명령이 찾을 것으로 예상되는 유형의 빈 집계 유형을 보유하고 있는 경우와 항상 동일한 결과가 생성됩니다.</li>
</ol>

<p>Examples of rule 1:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
</code></pre></div></div>
<p>However we can’t perform operations against the wrong type if the key exists:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>foo bar
OK
<span class="o">&gt;</span> lpush foo 1 2 3
</code></pre></div></div>
<p>(error) WRONGTYPE Operation against a key holding the wrong kind of value</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">type </span>foo
string
</code></pre></div></div>
<p>Example of rule 2:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpop mylist
<span class="s2">"3"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"2"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"1"</span>
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p>The key no longer exists after all the elements are popped.<br />
Example of rule 3:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> llen mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> lpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[List List 데이터 유형을 설명하려면 List라는 용어가 정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다. 매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다: 10,20,1,2,3은 목록입니다. 그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다. Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. LPUSH 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는 1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다. 단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현 된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다. Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다. 큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Set</title><link href="http://localhost:4000/cache/set/" rel="alternate" type="text/html" title="Getting Start Redis - Set" /><published>2023-04-06T00:00:00+09:00</published><updated>2023-04-06T00:00:00+09:00</updated><id>http://localhost:4000/cache/set</id><content type="html" xml:base="http://localhost:4000/cache/set/"><![CDATA[<h2 id="sets">Sets</h2>
<p>Redis 집합은 순서가 지정되지 않은 문자열 컬렉션입니다. <a href="https://redis.io/commands/sadd">SADD</a> 명령은 세트에 새 요소를 추가합니다. 주어진 요소가 이미 존재하는지 테스트, 여러 집합 간의 교차, 합집합 또는 차이 수행 등과 같은 집합에 대해 여러 가지 다른 작업을 수행 할 수도 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd myset 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> smembers myset
1. 3
2. 1
3. 2
</code></pre></div></div>
<p>여기에 세 가지 요소를 세트에 추가하고 Redis에게 모든 요소를 반환하도록 지시했습니다. 보시다시피 정렬되지 않았습니다 - Redis는 요소 순서에 대한 사용자와 계약이 없기 때문에 모든 호출에서 임의의 순서로 요소를 반환 할 수 있습니다.
Redis에는 멤버십을 테스트하는 명령이 있습니다. 
예를 들어 요소가 있는지 확인합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sismember myset 3
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sismember myset 30
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p>“3” is a member of the set, while “30” is not.
집합은 개체 간의 관계를 표현하는 데 유용합니다. 예를 들어 태그를 구현하기 위해 집합을 쉽게 사용할 수 있습니다..
이 문제를 모델링하는 간단한 방법은 태그를 지정하려는 모든 객체에 대한 집합을 갖는 것입니다. 집합에는 개체와 연결된 태그의 ID가 포함됩니다.<br />
한 가지 예는 뉴스 기사에 태그를 지정하는 것입니다. 기사 ID 1000에 태그 1, 2, 5 및 77 태그가 지정된 경우 집합은 이러한 태그 ID를 뉴스 항목과 연결할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd news:1000:tags 1 2 5 77
<span class="o">(</span>integer<span class="o">)</span> 4
</code></pre></div></div>
<p>우리는 또한 역관계를 원할 수도 있습니다 : 주어진 태그로 태그 된 모든 뉴스의 목록:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd tag:1:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sadd tag:2:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sadd tag:5:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> sadd tag:77:news 1000
<span class="o">(</span>integer<span class="o">)</span> 1
</code></pre></div></div>
<p>주어진 객체에 대한 모든 태그를 가져 오는 것은 간단합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> smembers news:1000:tags
1. 5
2. 1
3. 77
4. 2
</code></pre></div></div>
<p>Note: 예제에서는 태그 ID를 태그 이름에 매핑하는 Redis 해시와 같은 다른 데이터 구조가 있다고 가정합니다..
올바른 Redis 명령을 사용하여 구현하기 쉬운 다른 사소한 작업이 있습니다. 예를 들어 태그 1, 2, 10 및 27을 함께 사용하는 모든 객체 목록을 원할 수 있습니다. 서로 다른 세트 간의 교차를 수행하는 <a href="https://redis.io/commands/sinter">SINTER</a> 명령을 사용하여이 작업을 수행 할 수  있습니다. 우리는 사용할 수 있습니다:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sinter tag:1:news tag:2:news tag:10:news tag:27:news
... results here ...
</code></pre></div></div>
<p>교차 외에도 합집합, 차이, 무작위 요소 추출 등을 수행할 수 있습니다..
요소를 추출하는 명령을 <a href="https://redis.io/commands/spop">SPOP</a>라고 하며 특정 문제를 모델링하는 데 편리합니다. 예를 들어 웹 기반 포커 게임을 구현하려면 덱을 세트로 표현할 수 있습니다. (C) lubs, (D) iamonds, (H) earts, (S) pades에 대해 1 자 접두사를 사용한다고 상상해보십시오.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
  D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3
  H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6
  S7 S8 S9 S10 SJ SQ SK
<span class="o">(</span>integer<span class="o">)</span> 52
</code></pre></div></div>
<p>이제 각 플레이어에게 5장의 카드를 제공하고자 합니다. <a href="https://redis.io/commands/spop">SPOP</a> 명령은 임의의 요소를 제거하여 클라이언트로 반환하므로이 경우 완벽한 작업입니다.<br />
그러나 덱에 대해 직접 호출하면 다음 게임 플레이에서 카드 덱을 다시 채워야 하므로 이상적이지 않을 수 있습니다.<br />
먼저 덱 키에 저장된 세트의 복사본을 게임에 만들 수 있습니다 : 
이 작업은 일반적으로 여러 집합 간의 합집합을 수행하고 결과를 다른 집합에 저장하는 <a href="https://redis.io/commands/sunionstore">SUNIONSTORE</a>를 사용하여 수행됩니다.</p>

<p>그러나 단일 세트의 합집합 자체이기 때문에 내 데크를 복사할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sunionstore game:1:deck deck
<span class="o">(</span>integer<span class="o">)</span> 52
</code></pre></div></div>
<p>이제 첫 번째 플레이어에게 5장의 카드를 제공할 준비가 되었습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> spop game:1:deck
<span class="s2">"C6"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"CQ"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"D1"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"CJ"</span>
<span class="o">&gt;</span> spop game:1:deck
<span class="s2">"SJ"</span>
</code></pre></div></div>
<p>One pair of jacks, not great…
집합 내의 요소 수를 제공하는 set 명령을 소개하기에 좋은 시기입니다. 이것은 종종 집합 이론의 맥락에서 집합의 카디널리티라고 불리  므로 Redis 명령을 SCARD라고합니다..</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> scard game:1:deck
<span class="o">(</span>integer<span class="o">)</span> 47
</code></pre></div></div>
<p>계산: 52 - 5 = 47.
세트에서 제거하지 않고 임의의 요소를 가져와야 하는 경우 작업에 적합한 <a href="https://redis.io/commands/srandmember">SRANDMEMBER</a> 명령이 있습니다. 또한 반복되는 요소와 반복되지 않는 요소를 모두 반환하는 기능이 있습니다..</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Sets Redis 집합은 순서가 지정되지 않은 문자열 컬렉션입니다. SADD 명령은 세트에 새 요소를 추가합니다. 주어진 요소가 이미 존재하는지 테스트, 여러 집합 간의 교차, 합집합 또는 차이 수행 등과 같은 집합에 대해 여러 가지 다른 작업을 수행 할 수도 있습니다. &gt; sadd myset 1 2 3 (integer) 3 &gt; smembers myset 1. 3 2. 1 3. 2 여기에 세 가지 요소를 세트에 추가하고 Redis에게 모든 요소를 반환하도록 지시했습니다. 보시다시피 정렬되지 않았습니다 - Redis는 요소 순서에 대한 사용자와 계약이 없기 때문에 모든 호출에서 임의의 순서로 요소를 반환 할 수 있습니다. Redis에는 멤버십을 테스트하는 명령이 있습니다. 예를 들어 요소가 있는지 확인합니다.: &gt; sismember myset 3 (integer) 1 &gt; sismember myset 30 (integer) 0 “3” is a member of the set, while “30” is not. 집합은 개체 간의 관계를 표현하는 데 유용합니다. 예를 들어 태그를 구현하기 위해 집합을 쉽게 사용할 수 있습니다.. 이 문제를 모델링하는 간단한 방법은 태그를 지정하려는 모든 객체에 대한 집합을 갖는 것입니다. 집합에는 개체와 연결된 태그의 ID가 포함됩니다. 한 가지 예는 뉴스 기사에 태그를 지정하는 것입니다. 기사 ID 1000에 태그 1, 2, 5 및 77 태그가 지정된 경우 집합은 이러한 태그 ID를 뉴스 항목과 연결할 수 있습니다.: &gt; sadd news:1000:tags 1 2 5 77 (integer) 4 우리는 또한 역관계를 원할 수도 있습니다 : 주어진 태그로 태그 된 모든 뉴스의 목록: &gt; sadd tag:1:news 1000 (integer) 1 &gt; sadd tag:2:news 1000 (integer) 1 &gt; sadd tag:5:news 1000 (integer) 1 &gt; sadd tag:77:news 1000 (integer) 1 주어진 객체에 대한 모든 태그를 가져 오는 것은 간단합니다. &gt; smembers news:1000:tags 1. 5 2. 1 3. 77 4. 2 Note: 예제에서는 태그 ID를 태그 이름에 매핑하는 Redis 해시와 같은 다른 데이터 구조가 있다고 가정합니다.. 올바른 Redis 명령을 사용하여 구현하기 쉬운 다른 사소한 작업이 있습니다. 예를 들어 태그 1, 2, 10 및 27을 함께 사용하는 모든 객체 목록을 원할 수 있습니다. 서로 다른 세트 간의 교차를 수행하는 SINTER 명령을 사용하여이 작업을 수행 할 수 있습니다. 우리는 사용할 수 있습니다: &gt; sinter tag:1:news tag:2:news tag:10:news tag:27:news ... results here ... 교차 외에도 합집합, 차이, 무작위 요소 추출 등을 수행할 수 있습니다.. 요소를 추출하는 명령을 SPOP라고 하며 특정 문제를 모델링하는 데 편리합니다. 예를 들어 웹 기반 포커 게임을 구현하려면 덱을 세트로 표현할 수 있습니다. (C) lubs, (D) iamonds, (H) earts, (S) pades에 대해 1 자 접두사를 사용한다고 상상해보십시오.: &gt; sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 SJ SQ SK (integer) 52 이제 각 플레이어에게 5장의 카드를 제공하고자 합니다. SPOP 명령은 임의의 요소를 제거하여 클라이언트로 반환하므로이 경우 완벽한 작업입니다. 그러나 덱에 대해 직접 호출하면 다음 게임 플레이에서 카드 덱을 다시 채워야 하므로 이상적이지 않을 수 있습니다. 먼저 덱 키에 저장된 세트의 복사본을 게임에 만들 수 있습니다 : 이 작업은 일반적으로 여러 집합 간의 합집합을 수행하고 결과를 다른 집합에 저장하는 SUNIONSTORE를 사용하여 수행됩니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Sorted Sets</title><link href="http://localhost:4000/cache/sorted-sets/" rel="alternate" type="text/html" title="Getting Start Redis - Sorted Sets" /><published>2023-04-05T00:00:00+09:00</published><updated>2023-04-05T00:00:00+09:00</updated><id>http://localhost:4000/cache/sorted%20sets</id><content type="html" xml:base="http://localhost:4000/cache/sorted-sets/"><![CDATA[<h2 id="sorted-sets">Sorted Sets</h2>
<p>정렬된 집합은 Set과 해시 간의 혼합과 유사한 데이터 유형입니다. 집합과 마찬가지로 정렬된 집합은 반복되지 않는 고유한 문자열 요소로 구성되므로 어떤 의미에서는 정렬된 집합도 집합입니다.<br />
그러나 집합 내의 요소는 정렬되지 않지만 정렬 된 집합의 모든 요소는 score라고하는 부동 소수점 값과 연결됩니다  (모든 요소가 값에 매핑되기 때문에 유형이 해시와 유사한 이유입니다).<br />
또한 정렬 된 집합의 요소는 순서대로 취해집니다 (따라서 요청시 정렬되지 않으므로 순서는 정렬 된 집합을 나타내는 데 사용되는 데이터 구조의 특성입니다). 다음 규칙에 따라 정렬됩니다.:<br />
•	B와 A가 점수가 다른 두 요소인 경우 A.점수가 B.점수&gt;이면 A는 B&gt;.<br />
•	B와 A의 점수가 정확히 같으면 A 문자열이 B 문자열보다 사전적으로 크면 A가 B&gt; B입니다. B와 A 문자열은 정렬된 집합에만 고유한 요소만 있으므로 같을 수 없습니다.</p>

<p>몇 가지 선택된 해커 이름을 정렬 된 집합 요소로 추가하고 출생 연도를 “점수”로 추가하는 간단한 예부터 시작하겠습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zadd hackers 1940 <span class="s2">"Alan Kay"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1957 <span class="s2">"Sophie Wilson"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1953 <span class="s2">"Richard Stallman"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1949 <span class="s2">"Anita Borg"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1965 <span class="s2">"Yukihiro Matsumoto"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1914 <span class="s2">"Hedy Lamarr"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1916 <span class="s2">"Claude Shannon"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1969 <span class="s2">"Linus Torvalds"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> zadd hackers 1912 <span class="s2">"Alan Turing"</span>
<span class="o">(</span>integer<span class="o">)</span> 1
</code></pre></div></div>
<p>보시다시피 <a href="https://redis.io/commands/zadd">ZADD</a>는 <a href="https://redis.io/commands/sadd">SADD</a>와 유사하지만 점수 인 하나의 추가 인수 (추가 할 요소 앞에 배치)를 사용합니다.<br />
<a href="https://redis.io/commands/zadd">ZADD</a>는 또한 가변적이므로 위의 예에서 사용되지 않더라도 여러 점수-값 쌍을 자유롭게 지정할 수 있습니다..
정렬 된 세트를 사용하면 실제로 이미 정렬되어 있기 때문에 출생 연도별로 정렬 된 해커 목록을 반환하는 것은 간단합니다..
구현 참고 사항 : 정렬 된 세트는 건너 뛰기 목록과 해시 테이블을 모두 포함하는 이중 포트 데이터 구조를 통해 구현되므로 요소를 추가 할 때마다 Redis는 O (log (N)) 작업을 수행합니다. 좋지만 정렬 된 요소를 요청하면 Redis는 작업을 전혀 수행 할 필요가 없으며 이미 모두 정렬되어 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrange hackers 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"Alan Turing"</span>
2<span class="o">)</span> <span class="s2">"Hedy Lamarr"</span>
3<span class="o">)</span> <span class="s2">"Claude Shannon"</span>
4<span class="o">)</span> <span class="s2">"Alan Kay"</span>
5<span class="o">)</span> <span class="s2">"Anita Borg"</span>
6<span class="o">)</span> <span class="s2">"Richard Stallman"</span>
7<span class="o">)</span> <span class="s2">"Sophie Wilson"</span>
8<span class="o">)</span> <span class="s2">"Yukihiro Matsumoto"</span>
9<span class="o">)</span> <span class="s2">"Linus Torvalds"</span>
</code></pre></div></div>
<p>Note: 0 및 -1은 요소 인덱스 0에서 마지막 요소까지를 의미합니다(-1은 <a href="https://redis.io/commands/lrange">LRANGE</a> 명령의 경우와 마찬가지로 여기에서 작동  함).
가장 최신것부터 가장 오래된 것까지 반대 방향으로 주문하려면 어떻게해야합니까? <a href="https://redis.io/commands/zrange">ZRANGE</a> 대신 <a href="https://redis.io/commands/zrevrange">ZREVRANGE</a>를 사용하십시오. :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrevrange hackers 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"Linus Torvalds"</span>
2<span class="o">)</span> <span class="s2">"Yukihiro Matsumoto"</span>
3<span class="o">)</span> <span class="s2">"Sophie Wilson"</span>
4<span class="o">)</span> <span class="s2">"Richard Stallman"</span>
5<span class="o">)</span> <span class="s2">"Anita Borg"</span>
6<span class="o">)</span> <span class="s2">"Alan Kay"</span>
7<span class="o">)</span> <span class="s2">"Claude Shannon"</span>
8<span class="o">)</span> <span class="s2">"Hedy Lamarr"</span>
9<span class="o">)</span> <span class="s2">"Alan Turing"</span>
</code></pre></div></div>
<p>It는 WITHSCORES 인수를 사용하여 점수를 반환 할 수도 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrange hackers 0 <span class="nt">-1</span> withscores
1<span class="o">)</span> <span class="s2">"Alan Turing"</span>
2<span class="o">)</span> <span class="s2">"1912"</span>
3<span class="o">)</span> <span class="s2">"Hedy Lamarr"</span>
4<span class="o">)</span> <span class="s2">"1914"</span>
5<span class="o">)</span> <span class="s2">"Claude Shannon"</span>
6<span class="o">)</span> <span class="s2">"1916"</span>
7<span class="o">)</span> <span class="s2">"Alan Kay"</span>
8<span class="o">)</span> <span class="s2">"1940"</span>
9<span class="o">)</span> <span class="s2">"Anita Borg"</span>
10<span class="o">)</span> <span class="s2">"1949"</span>
11<span class="o">)</span> <span class="s2">"Richard Stallman"</span>
12<span class="o">)</span> <span class="s2">"1953"</span>
13<span class="o">)</span> <span class="s2">"Sophie Wilson"</span>
14<span class="o">)</span> <span class="s2">"1957"</span>
15<span class="o">)</span> <span class="s2">"Yukihiro Matsumoto"</span>
16<span class="o">)</span> <span class="s2">"1965"</span>
17<span class="o">)</span> <span class="s2">"Linus Torvalds"</span>
18<span class="o">)</span> <span class="s2">"1969"</span>
</code></pre></div></div>
<p>Operating on ranges
Sorted Set는 이보다 더 강력합니다. 범위에서 작동 할 수 있습니다. 1950 년까지 태어난 모든 개인을 모아 봅시다. <a href="https://redis.io/commands/zrangebyscore">ZRANGEBYSCORE</a> 명령을 사용하여이를 수행합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrangebyscore hackers <span class="nt">-inf</span> 1950
1<span class="o">)</span> <span class="s2">"Alan Turing"</span>
2<span class="o">)</span> <span class="s2">"Hedy Lamarr"</span>
3<span class="o">)</span> <span class="s2">"Claude Shannon"</span>
4<span class="o">)</span> <span class="s2">"Alan Kay"</span>
5<span class="o">)</span> <span class="s2">"Anita Borg"</span>
</code></pre></div></div>
<p>Redis에 음의 무한대와 1950 사이의 점수로 모든 요소를 반환하도록 요청했습니다. (both extremes are included).
요소 범위를 제거할 수도 있습니다. Sorted Set에서 1940 년에서 1960 년 사이에 태어난 모든 해커를 제거합시다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zremrangebyscore hackers 1940 1960
<span class="o">(</span>integer<span class="o">)</span> 4
</code></pre></div></div>
<p><a href="https://redis.io/commands/zremrangebyscore">ZREMRANGEBYSCORE</a>는 아마도 최고의 명령 이름은 아니지만 매우 유용 할 수 있으며 제거 된 요소의 수를 반환합니다..
정렬된 집합 요소에 대해 정의된 또 다른 매우 유용한 작업은 get-rank 작업입니다. 정렬 된 요소 집합에서 요소의 위치가 무엇인지 물어볼 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrank hackers <span class="s2">"Anita Borg"</span>
<span class="o">(</span>integer<span class="o">)</span> 4
</code></pre></div></div>
<p><a href="https://redis.io/commands/zrevrank">ZREVRANK</a> 명령은 요소가 내림차순으로 정렬된 것을 고려하여 순위를 가져오기 위해서도 사용할 수 있습니다.</p>

<p>Lexicographical scores
최신 버전의 Redis 2.8에서는 정렬된 집합의 요소가 모두 동일한 동일한 점수로 삽입된다고 가정하고 사전순으로 범위를 가져올 수 있는 새로운 기능이 도입되었습니다(요소는 C memcmp 함수와 비교  되므로 데이터 정렬이 없고 모든 Redis 인스턴스가 동일한 출력으로 응답함).</p>

<p>사전 범위로 작동하는 주요 명령은</p>
<ul>
  <li><a href="https://redis.io/commands/zrangebylex">ZRANGEBYLEX</a></li>
  <li><a href="https://redis.io/commands/zrevrangebylex">ZREVRANGEBYLEX</a></li>
  <li><a href="https://redis.io/commands/zremrangebylex">ZREMRANGEBYLEX</a></li>
  <li><a href="https://redis.io/commands/zlexcount">ZLEXCOUNT</a></li>
</ul>

<p>예를 들어 유명한 해커 목록을 다시 추가하지만 이번에는 모든 요소에 대해 0점을 사용합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zadd hackers 0 <span class="s2">"Alan Kay"</span> 0 <span class="s2">"Sophie Wilson"</span> 0 <span class="s2">"Richard Stallman"</span> 0
  <span class="s2">"Anita Borg"</span> 0 <span class="s2">"Yukihiro Matsumoto"</span> 0 <span class="s2">"Hedy Lamarr"</span> 0 <span class="s2">"Claude Shannon"</span>
  0 <span class="s2">"Linus Torvalds"</span> 0 <span class="s2">"Alan Turing"</span>
</code></pre></div></div>
<p>정렬된 집합 순서 규칙으로 인해 이미 사전순으로 정렬되어 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrange hackers 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"Alan Kay"</span>
2<span class="o">)</span> <span class="s2">"Alan Turing"</span>
3<span class="o">)</span> <span class="s2">"Anita Borg"</span>
4<span class="o">)</span> <span class="s2">"Claude Shannon"</span>
5<span class="o">)</span> <span class="s2">"Hedy Lamarr"</span>
6<span class="o">)</span> <span class="s2">"Linus Torvalds"</span>
7<span class="o">)</span> <span class="s2">"Richard Stallman"</span>
8<span class="o">)</span> <span class="s2">"Sophie Wilson"</span>
9<span class="o">)</span> <span class="s2">"Yukihiro Matsumoto"</span>
</code></pre></div></div>
<p><a href="https://redis.io/commands/zrangebylex">ZRANGEBYLEX</a> 를 사용하여  사전 범위를 요청할 수 있습니다:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> zrangebylex hackers <span class="o">[</span>B <span class="o">[</span>P
1<span class="o">)</span> <span class="s2">"Claude Shannon"</span>
2<span class="o">)</span> <span class="s2">"Hedy Lamarr"</span>
3<span class="o">)</span> <span class="s2">"Linus Torvalds"</span>
</code></pre></div></div>
<p>범위는 포괄적이거나 배타적일 수 있으며(첫 번째 문자에 따라 다름), 문자열 무한 및 빼기 무한대도 + 및 - 문자열로 각각 지정됩니다  . 자세한 내용은 설명서를 참조하십시오..
이 기능은 정렬 된 집합을 일반 인덱스로 사용할 수 있기 때문에 중요합니다. 예를 들어 128비트 부호 없는 정수 인수로 요소를 인덱싱하려면 점수는 같지만(예: 0) 빅 엔디안의 128비트 숫자로 구성된 16바이트 접두사를 사용하여 정렬된 집합에 요소를 추가하기만 하면 됩니다. 빅 엔디안의 숫자는 사전순으로 (원시 바이트 순서로) 정렬 될 때 실제로 숫자로 정렬되므로 128 비트 공간의 범위를 요청하고 접두사를 버리는 요소의 값을 가져올 수 있습니다.</p>

<p>점수 업데이트: 리더 보드
다음 주제로 전환하기 전에 정렬 된 세트에 대한 마지막 참고 사항입니다. 정렬된 세트의 점수는 언제든지 업데이트할 수 있습니다.  정렬 된 집합에 이미 포함 된 요소에 대해 <a href="https://redis.io/commands/zadd">ZADD</a>를 호출하면 O (log (N)) 시간 복잡성으로 점수 (및 위치)가 업데이트됩니다. 따라서 정렬 된 세트는 업데이트가 많을 때 적합합니다..
이러한 특성 때문에 일반적인 사용 사례는 리더 보드입니다. 일반적인 응용 프로그램은 상위 N 명의 사용자와 리더 보드의 사용자 순위를 표시하기 위해 사용자를 최고 점수별로 정렬하는 기능과 get-rank 작업을 결합하는 Facebook 게임입니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Sorted Sets 정렬된 집합은 Set과 해시 간의 혼합과 유사한 데이터 유형입니다. 집합과 마찬가지로 정렬된 집합은 반복되지 않는 고유한 문자열 요소로 구성되므로 어떤 의미에서는 정렬된 집합도 집합입니다. 그러나 집합 내의 요소는 정렬되지 않지만 정렬 된 집합의 모든 요소는 score라고하는 부동 소수점 값과 연결됩니다 (모든 요소가 값에 매핑되기 때문에 유형이 해시와 유사한 이유입니다). 또한 정렬 된 집합의 요소는 순서대로 취해집니다 (따라서 요청시 정렬되지 않으므로 순서는 정렬 된 집합을 나타내는 데 사용되는 데이터 구조의 특성입니다). 다음 규칙에 따라 정렬됩니다.: • B와 A가 점수가 다른 두 요소인 경우 A.점수가 B.점수&gt;이면 A는 B&gt;. • B와 A의 점수가 정확히 같으면 A 문자열이 B 문자열보다 사전적으로 크면 A가 B&gt; B입니다. B와 A 문자열은 정렬된 집합에만 고유한 요소만 있으므로 같을 수 없습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Bitmap</title><link href="http://localhost:4000/cache/bitmap/" rel="alternate" type="text/html" title="Getting Start Redis - Bitmap" /><published>2023-04-04T00:00:00+09:00</published><updated>2023-04-04T00:00:00+09:00</updated><id>http://localhost:4000/cache/bitmap</id><content type="html" xml:base="http://localhost:4000/cache/bitmap/"><![CDATA[<h2 id="bitmaps">Bitmaps</h2>
<p>비트맵은 실제 데이터 형식이 아니라 String 형식에 정의된 비트 지향 작업 집합입니다. 문자열은 이진 안전 Blob이고 최대 길이는 512MB이므로 최대 2^32비트를 설정하는 데 적합합니다.<br />
비트 연산은 두 그룹으로 나뉩니다: 비트를 1 또는 0으로 설정하거나 값을 가져오는 것과 같은 상수 시간 단일 비트 연산과 비트 그룹에 대한 연산(예: 지정된 비트 범위에서 설정된 비트 수 계산)(예: 인구 계산).<br />
비트맵의 가장 큰 장점 중 하나는 정보를 저장할 때 공간을 크게 절약할 수 있다는 것입니다. 예를 들어, 서로 다른 사용자가 증분 사용자 ID로 표시되는 시스템에서는 512MB의 메모리만 사용하여 40억 명의 사용자에 대한 단일 비트 정보(예: 사용자가 뉴스레터를 수신하기를 원하는지 여부를 아는 것)를 기억할 수 있습니다.<br />
비트는 <a href="https://redis.io/commands/setbit">SETBIT</a> 및 <a href="https://redis.io/commands/getbit">GETBIT</a> 명령을 사용하여 설정되고 검색됩니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> setbit key 10 1
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> getbit key 10
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> getbit key 11
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p><a href="https://redis.io/commands/setbit">SETBIT</a> 명령은 첫 번째 인수로 비트  번호를 사용하고 두 번째 인수로 비트를 설정할 값(1 또는 0)을 사용합니다. 이 명령은 주소가 지정된 비트가 현재 문자열 길이를 벗어나는 경우 문자열을 자동으로 확대합니다.<br />
<a href="https://redis.io/commands/gettit">GETTIT</a>은 지정된 인덱스에서 비트 값을 반환합니다. 범위를 벗어난 비트(대상 키에 저장된 문자열의 길이를 벗어나는 비트 주소 지정)는 항상 0으로 간주됩니다.<br />
비트 그룹에서 작동하는 세 가지 명령이 있습니다.:</p>
<ol>
  <li><a href="https://redis.io/commands/bitop">BITOP</a>은 서로 다른 문자열 간에 비트 단위 연산을 수행합니다. 제공된 작업은 AND, OR, XOR 및 NOT입니다.</li>
  <li><a href="https://redis.io/commands/bitcount">BITCOUNT</a>는 인구 계수를 수행하여 1로 설정된 비트 수를 보고합니다.</li>
  <li><a href="https://redis.io/commands/bitops">BITPOS</a>는 지정된 값이 0 또는 1인 첫 번째 비트를 찾습니다.</li>
</ol>

<p><a href="https://redis.io/commands/bitpos">BITPOS</a>  와 <a href="https://redis.io/commands/bitcount">BITCOUNT</a>는 모두 문자열의  전체 길이에 대해 실행되는 대신 문자열의 바이트 범위로 작동할 수 있습니다. 다음은 <a href="https://redis.io/commands/bitcount">BITCOUNT</a> 호출의 간단한 예입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> setbit key 0 1
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> setbit key 100 1
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> bitcount key
<span class="o">(</span>integer<span class="o">)</span> 2
</code></pre></div></div>
<p>비트맵의 일반적인 사용 사례는 다음과 같습니다.:<br />
•	모든 종류의 실시간 분석.<br />
•	공간 효율적이지만 개체 ID와 연결된 고성능 부울 정보 저장.<br />
예를 들어 웹 사이트 사용자의 일일 방문의 가장 긴 행진을 알고 싶다고 상상해보십시오.<br />
웹 사이트를 공개한 날인 0부터 시작하는 날짜를 계산하기 시작하고  사용자가 웹 사이트를 방문할 때마다 <a href="https://redis.io/commands/setbit">SETBIT</a>으로 약간 설정합니다. 비트 인덱스로 현재 유닉스 시간을 취하고 초기 오프셋을 빼고 하루의 초 수로 나눕니다 (일반적으로 3600 * 24).<br />
이렇게 하면 각 사용자에 대해 각 날짜의 방문 정보가 포함된 작은 문자열이 생성됩니다.<br />
<a href="https://redis.io/commands/bitcount">BITCOUNT</a>를 사용하면  주어진 사용자가 웹 사이트를 방문한 일 수를 쉽게 얻을 수 있으며 몇 번의 BITPOS 호출을 사용하거나  단순히 비트맵 클라이언트 측을 가져오고 분석하면 가장 긴 행진을 쉽게 계산할 수 있습니다.<br />
비트맵은 예를 들어 데이터 세트를 분할하기 위해 그리고 일반적으로 거대한 키로 작업하지 않는 것이 더 낫기 때문에 여러 키로 분할하는 것이 간단합니다.<br />
모든 비트를 키로 설정하는 대신 비트 맵을 서로 다른 키로 분할하려면 간단한 전략은 키 당 M 비트를 저장하고 비트 번호 / M으로 키 이름을 얻고 비트 번호 MOD M으로 키 내부의 주소를 지정하는 N 번째 비트 를 얻는 것입니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Bitmaps 비트맵은 실제 데이터 형식이 아니라 String 형식에 정의된 비트 지향 작업 집합입니다. 문자열은 이진 안전 Blob이고 최대 길이는 512MB이므로 최대 2^32비트를 설정하는 데 적합합니다. 비트 연산은 두 그룹으로 나뉩니다: 비트를 1 또는 0으로 설정하거나 값을 가져오는 것과 같은 상수 시간 단일 비트 연산과 비트 그룹에 대한 연산(예: 지정된 비트 범위에서 설정된 비트 수 계산)(예: 인구 계산). 비트맵의 가장 큰 장점 중 하나는 정보를 저장할 때 공간을 크게 절약할 수 있다는 것입니다. 예를 들어, 서로 다른 사용자가 증분 사용자 ID로 표시되는 시스템에서는 512MB의 메모리만 사용하여 40억 명의 사용자에 대한 단일 비트 정보(예: 사용자가 뉴스레터를 수신하기를 원하는지 여부를 아는 것)를 기억할 수 있습니다. 비트는 SETBIT 및 GETBIT 명령을 사용하여 설정되고 검색됩니다.: &gt; setbit key 10 1 (integer) 0 &gt; getbit key 10 (integer) 1 &gt; getbit key 11 (integer) 0 SETBIT 명령은 첫 번째 인수로 비트 번호를 사용하고 두 번째 인수로 비트를 설정할 값(1 또는 0)을 사용합니다. 이 명령은 주소가 지정된 비트가 현재 문자열 길이를 벗어나는 경우 문자열을 자동으로 확대합니다. GETTIT은 지정된 인덱스에서 비트 값을 반환합니다. 범위를 벗어난 비트(대상 키에 저장된 문자열의 길이를 벗어나는 비트 주소 지정)는 항상 0으로 간주됩니다. 비트 그룹에서 작동하는 세 가지 명령이 있습니다.: BITOP은 서로 다른 문자열 간에 비트 단위 연산을 수행합니다. 제공된 작업은 AND, OR, XOR 및 NOT입니다. BITCOUNT는 인구 계수를 수행하여 1로 설정된 비트 수를 보고합니다. BITPOS는 지정된 값이 0 또는 1인 첫 번째 비트를 찾습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Key 규칙</title><link href="http://localhost:4000/cache/naming-rule/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Key 규칙" /><published>2023-03-30T00:00:00+09:00</published><updated>2023-03-30T00:00:00+09:00</updated><id>http://localhost:4000/cache/naming%20rule</id><content type="html" xml:base="http://localhost:4000/cache/naming-rule/"><![CDATA[<h2 id="기본-redis-데이터-형식-및-사용-방법">기본 Redis 데이터 형식 및 사용 방법</h2>
<p>다음은 Redis CLI를 사용하여 핵심 <a href="https://redis.io/docs/data-types/">Redis 데이터 유형</a>을 학습하는 실습 자습서입니다.  데이터 형식에 대한 일반적인 개요는 데이터 형식 소개를 참조하세요.</p>
<h4 id="keys">Keys</h4>
<p>Redis 키는 바이너리로부터 안전하므로 “foo”와 같은 문자열에서 JPEG 파일의 내용에 이르기까지 모든 바이너리 시퀀스를 키로 사용할 수 있습니다. 빈 문자열도 유효한 키입니다.</p>

<p><strong>Redis  Key에 대한 몇 가지 다른 규칙:</strong><br />
•	<em>매우 긴 키는 좋은 생각이 아닙니다</em><br />
예를 들어 1024바이트의 키는 메모리 측면에서 뿐만 아니라 데이터 세트에서 키를 조회하는 데 비용이 많이 드는 여러 키 비교가 필요할 수 있기 때문에 좋지 않습니다. <br />
당면한 작업이 큰 값의 존재와 일치하는 경우에도 특히 메모리 및 대역폭의 관점에서 해시하는 것이 더 좋습니다<br />
(예 : SHA1 사용).</p>

<p>•	<em>매우 짧은 키는 종종 좋은 생각이 아닙니다</em><br />
대신 “user:1000:followers”를 쓸 수 있다면 “u1000flw”를 키로 쓰는 것은 거의 의미가 없습니다. 후자는 더 읽기 쉽고 추가 된 공간은 키 객체 자체와 값 객체에서 사용하는 공간에 비해 작습니다.<br />
짧은 키는 분명히 메모리를 조금 덜 소비하지만 올바른 균형을 찾는 것이 키 설계자의 역량입니다.</p>

<p>•	<em>키를 구분자를 이용하여 그룹으로 분류</em><br />
예를 들어 “object-type:id”는 “user:1000”에서와 같이 <strong>콜론(:)</strong> 을 구분자하여 그룹을 만드는 것은 좋은 생각입니다. 점 또는 대시는 “comment:4321:reply.to” 또는 “comment:4321:reply-to”와 같이 여러 단어로 된 필드에 자주 사용됩니다.</p>

<p>•	<em>허용 된 최대 키 크기는 512MB입니다.</em></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[기본 Redis 데이터 형식 및 사용 방법 다음은 Redis CLI를 사용하여 핵심 Redis 데이터 유형을 학습하는 실습 자습서입니다. 데이터 형식에 대한 일반적인 개요는 데이터 형식 소개를 참조하세요. Keys Redis 키는 바이너리로부터 안전하므로 “foo”와 같은 문자열에서 JPEG 파일의 내용에 이르기까지 모든 바이너리 시퀀스를 키로 사용할 수 있습니다. 빈 문자열도 유효한 키입니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Jupyter Notebook</title><link href="http://localhost:4000/cache/getting-starting-jupyter/" rel="alternate" type="text/html" title="Getting Start Redis - Jupyter Notebook" /><published>2023-03-29T00:00:00+09:00</published><updated>2023-03-29T00:00:00+09:00</updated><id>http://localhost:4000/cache/getting-starting-jupyter</id><content type="html" xml:base="http://localhost:4000/cache/getting-starting-jupyter/"><![CDATA[<p>Jupyter Notebook을 환경에서 Python을 이용하여 Redis를 알아봅니다. redis-py를 이용하여 redis를 연결하고, 다음과 같이 데이터를 set/get을 수행하여 결과를 확인합니다.</p>
<h2 id="connect">Connect</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis</span>

<span class="n">redisClient</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">decode_responses</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">redisClient</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="s">'foo'</span><span class="p">,</span> <span class="s">'bar'</span><span class="p">)</span>
<span class="n">redisClient</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'foo'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/cache/06-cache-get-set.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Jupyter Notebook을 환경에서 Python을 이용하여 Redis를 알아봅니다. redis-py를 이용하여 redis를 연결하고, 다음과 같이 데이터를 set/get을 수행하여 결과를 확인합니다. Connect ```python import redis]]></summary></entry></feed>