<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-04T20:06:57+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Nexus를 docker container repository로 사용하기</title><link href="http://localhost:4000/devops/push-container-image-to-nexus/" rel="alternate" type="text/html" title="Nexus를 docker container repository로 사용하기" /><published>2023-02-04T00:00:00+09:00</published><updated>2023-02-04T00:00:00+09:00</updated><id>http://localhost:4000/devops/push%20container%20image%20to%20nexus</id><content type="html" xml:base="http://localhost:4000/devops/push-container-image-to-nexus/"><![CDATA[<h2 id="nexus를-docker-container-repository로-사용하기">Nexus를 docker container repository로 사용하기</h2>
<p>Nexus를 docker container image의 repository로 사용하는 위한 설정입니다.
Harbor 같은 전용 Docker container Registry로 사용하는 Open Source 솔루션도 있으나
애플리케이션 수가 몇개 되지 않는 것은 Nexus를 Container Image Repository로 사용할 수 있습니다.</p>

<p>Nexus 설치는 블로그 목록을 참고해 주시고, 설정이 끝나고 추가적으로 container Image Repository를 추가하는 부분만 소개합니다.</p>

<h2 id="step-1--docker-유형-repository-생성">Step 1 : docker 유형 Repository 생성</h2>
<p>create repository를 선택합니다.<br />
<img src="/assets/images/nexus/06-jenkins-nexus-create-repository.png" alt="nexus docker repository" /></p>

<p>Repository 유형중에 docker(hosted) repository를 선택합니다.<br />
<img src="/assets/images/nexus/07-jenkins-nexus-select-docker-repository.png" alt="nexus docker repository" /></p>

<p>docker-repo 이름으로 다음과 같이 정보를 선택하고 repository를 생성합니다.<br />
<img src="/assets/images/nexus/08-jenkins-nexus-docker-repository.png" alt="nexus docker repository" /></p>

<h2 id="step-2-add-docker-bearer-token-to-realms">Step 2: Add docker bearer token to Realms</h2>

<p>Realms 에 Docker Bearer token을 추가하고, 저장합니다.</p>

<p><img src="/assets/images/nexus/08-jenkins-nexus-realms-docker-bearer-token.png" alt="add realm" /></p>

<h2 id="step-2-podman-을-사용하여-nexus에-로그인">Step 2: podman 을 사용하여 nexus에 로그인</h2>

<p>Podman을 사용하여 http로 login 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nexus-server-ip : remote server ip 또는 localhost</span>
podman login <span class="nt">-u</span> deploy-user <span class="nt">-p</span> Passw0rd@ <span class="nt">--tls-verify</span><span class="o">=</span><span class="nb">false </span>nexus-server-ip:5000
</code></pre></div></div>

<p>Nexus 가 local에 있는 경우 nexus-server-id를 localhost로 지정합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>podman login <span class="nt">-u</span> deploy-user <span class="nt">-p</span> Passw0rd@ <span class="nt">--tls-verify</span><span class="o">=</span><span class="nb">false </span>localhost:5000
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="nexus" /><category term="podman" /><summary type="html"><![CDATA[Nexus를 docker container repository로 사용하기 Nexus를 docker container image의 repository로 사용하는 위한 설정입니다. Harbor 같은 전용 Docker container Registry로 사용하는 Open Source 솔루션도 있으나 애플리케이션 수가 몇개 되지 않는 것은 Nexus를 Container Image Repository로 사용할 수 있습니다.]]></summary></entry><entry><title type="html">Harbor로 Docker Private Registry 구축하기</title><link href="http://localhost:4000/docker/Harbor%EB%A1%9C-Private-Registry-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Harbor로 Docker Private Registry 구축하기" /><published>2023-01-30T00:00:00+09:00</published><updated>2023-01-30T00:00:00+09:00</updated><id>http://localhost:4000/docker/Harbor%EB%A1%9C%20Private%20Registry%20%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/docker/Harbor%EB%A1%9C-Private-Registry-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="harbor-로-docker-private-registry-구축하기">Harbor 로 Docker Private Registry 구축하기</h2>

<p>Harbor는 Offline Install과 Online Install 두 가지 방식으로 설치를 지원하고 있습니다. 이 실습에서는 Offline Install 을 기준으로 설치하도록 합니다. Harbor는 아래 github 사이트에 릴리즈 정보를 확인하고 download 받습니다.</p>

<p><a href="https://github.com/goharbor/harbor/releases/">Harbor 설치</a></p>

<h2 id="step-1-root-ca-certificates--생성">Step 1: Root CA Certificates  생성</h2>

<p>Docker Engine 설치는 아래 링크를 따라 설치과정을 참고해주세요</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/certs
openssl genrsa <span class="nt">-out</span> ca.key 4096
openssl req <span class="nt">-x509</span> <span class="nt">-new</span> <span class="nt">-nodes</span> <span class="nt">-sha512</span> <span class="nt">-days</span> 365 <span class="nt">-key</span> ca.key <span class="nt">-subj</span> <span class="s2">"/CN=*.example.com"</span> <span class="nt">-out</span> ca.crt
</code></pre></div></div>

<h2 id="step-2--server-private-key-생성">Step 2 : Server Private Key 생성</h2>

<p>Harbor 서버의 인증서를 생성합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Server의 비밀키 생성</span>
openssl genrsa <span class="nt">-out</span> server.key 4096
</code></pre></div></div>

<h2 id="step-3--harbor-서버의-csr-생성">Step 3 : Harbor 서버의 CSR 생성</h2>
<p>Server의 CSR 파일 생성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-sha512</span> <span class="nt">-new</span> <span class="nt">-key</span> server.key <span class="nt">-out</span> server.crt <span class="nt">-subj</span> <span class="s2">"/CN=server1.example.com"</span>
</code></pre></div></div>

<h2 id="step-4-san-등록">Step 4: SAN 등록</h2>

<p>Harbor 서버의 IP : 169.56.100.106</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"subjectAltName = IP:169.56.100.106,IP:127.0.0.1,DNS:server.example.com"</span> <span class="o">&gt;</span> v3ext.cnf
</code></pre></div></div>

<h2 id="step-5-server-인증서-생성">Step 5: Server 인증서 생성</h2>
<p>Harbor Domain 이 server1.example.com 이라고 가정하고,<br />
로그인 사용자가 user01로 생성되어 있다면 다음과 같이 수행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 <span class="nt">-req</span> <span class="nt">-sha512</span> <span class="nt">-days</span> 365  <span class="nt">-CA</span> ca.crt <span class="nt">-CAkey</span> ca.key <span class="nt">-CAcreateserial</span> <span class="nt">-in</span> server.csr <span class="nt">-out</span> server.crt <span class="nt">-extfile</span> v3ext.cnf
</code></pre></div></div>
<p>Server 인증서 변환</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 <span class="nt">-inform</span> PEM <span class="nt">-in</span> server.crt <span class="nt">-out</span> server.cert
</code></pre></div></div>

<h2 id="step-6-인증서-업데이트">Step 6: 인증서 업데이트</h2>
<p>certificates 업데이트 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># server.example.com</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /etc/docker/certs.d/server1.example.com
<span class="nb">mkdir</span> <span class="nt">-p</span> /etc/pki/ca-trust/source/anchors/

<span class="nb">cp</span> <span class="nt">-u</span> server.cert /etc/docker/certs.d/server1.example.com
<span class="nb">cp</span> <span class="nt">-u</span> server.key  /etc/docker/certs.d/server1.example.com
<span class="nb">cp</span> <span class="nt">-u</span> ca.crt      /etc/docker/certs.d/server1.example.com
<span class="nb">cp</span> <span class="nt">-u</span> ca.crt      /etc/pki/ca-trust/source/anchors/
<span class="nb">cp</span> <span class="nt">-u</span> server.crt  /etc/pki/ca-trust/source/anchors/

update-ca-trust
</code></pre></div></div>

<h2 id="step-7-호스트에-도메인-등록">Step 7: 호스트에 도메인 등록</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"119.81.103.68 server1.example.com"</span> <span class="o">&gt;&gt;</span> /etc/hosts
</code></pre></div></div>

<h2 id="step-8-download-harbor">Step 8: Download Harbor</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/goharbor/harbor/releases/download/v2.7.0/harbor-offline-installer-v2.7.0.tgz
<span class="nb">tar </span>xzvf harbor-offline-installer-v2.7.0.tgz
</code></pre></div></div>

<h2 id="step-9-configure-harbor-in-harboryml">Step 9: Configure harbor in harbor.yml</h2>
<p>Harbor 폴더로 이동하고 harbor.yml 을 수정합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># harbor.yml 작성</span>
<span class="nb">cd </span>harbor
<span class="nb">cp </span>harbor.yml.tmpl harbor.yml

<span class="c"># harbor.yml 편집</span>
vi harbor.yml
<span class="c"># ---------------------</span>
by external clients.
<span class="nb">hostname</span>: server1.example.com

<span class="c"># http related config</span>
http:
  <span class="c"># port for http, default is 80. If https enabled, this port will redirect to https port</span>
  port: 80

<span class="c"># https related config</span>
https:
  <span class="c"># https port for harbor, default is 443</span>
  port: 443
  <span class="c"># The path of cert and key files for nginx</span>
  certificate: /etc/docker/certs.d/server1.example.com/server.cert
  private_key: /etc/docker/certs.d/server1.example.com/server.key
</code></pre></div></div>

<h2 id="step-10-install-harbor">Step 10: Install Harbor</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./prepare
./install.sh

<span class="c"># 수행결과</span>
<span class="o">[</span>Step 0]: checking <span class="k">if </span>docker is installed ...

Note: docker version: 20.10.23

<span class="o">[</span>Step 1]: checking docker-compose is installed ...

Note: Docker Compose version v2.14.2

<span class="o">[</span>Step 2]: loading Harbor images ...
Loaded image: goharbor/prepare:v2.7.0
716575e41c45: Loading layer  145.8MB/145.8MB

<span class="o">[</span>Step 3]: preparing environment ...

<span class="o">[</span>Step 4]: preparing harbor configs ...
prepare base <span class="nb">dir </span>is <span class="nb">set </span>to /root/harbor
Clearing the configuration file: /config/registry/passwd
Clearing the configuration file: /config/registry/config.yml

<span class="o">[</span>Step 5]: starting Harbor ...
<span class="o">[</span>+] Running 10/10
 ⠿ Network harbor_harbor        Created       0.1s
 ⠿ Container harbor-log         Started                                         0.8s
 ⠿ Container harbor-db          Started                                         2.2s
 ⠿ Container registry           Started                                         2.2s
 ⠿ Container registryctl        Started                                         1.7s
 ⠿ Container redis              Started                                         1.8s
 ⠿ Container harbor-portal      Started                                         2.2s
 ⠿ Container harbor-core        Started                                         2.7s
 ⠿ Container harbor-jobservice  Started                                         3.8s
 ⠿ Container nginx              Started                                         3.9s

<span class="nt">----Harbor</span> has been installed and started successfully.----
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="Harbor" /><summary type="html"><![CDATA[Harbor 로 Docker Private Registry 구축하기]]></summary></entry><entry><title type="html">Docker 기반 JFrog 설치</title><link href="http://localhost:4000/docker/jfrog/" rel="alternate" type="text/html" title="Docker 기반 JFrog 설치" /><published>2023-01-29T00:00:00+09:00</published><updated>2023-01-29T00:00:00+09:00</updated><id>http://localhost:4000/docker/jfrog</id><content type="html" xml:base="http://localhost:4000/docker/jfrog/"><![CDATA[<h2 id="jfrog-on-docker">JFrog on Docker</h2>
<p>Docker 기반 JFrog를 설치합니다.</p>

<h2 id="step-1-install-docker-engine-on-centos7">Step 1: Install Docker Engine on Centos7</h2>

<p><a href="https://docs.docker.com/engine/install/">Docker</a> 설치 방법은 다음을 참고하세요.</p>

<p><a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p>

<h2 id="step-2--jfrog-artifactory-docker-image-를-download">Step 2 : JFrog Artifactory Docker Image 를 download</h2>

<p>For CE edition:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull docker.bintray.io/jfrog/artifactory-cpp-ce


docker images

docker images <span class="s2">"*/jfrog/*"</span>
<span class="nt">-------------------------------------------------------------------------------------------</span>
REPOSITORY                                   TAG       IMAGE ID       CREATED      SIZE
docker.bintray.io/jfrog/artifactory-cpp-ce   latest    82ca33a84e75   5 days ago   1.55GB

</code></pre></div></div>
<h2 id="step-3--create-data-directory">Step 3 : Create Data Directory</h2>
<p>컨테이너에서 사용되는 데이터가 영구적으로 저장하기 위해 시스템에 데이터 디렉토리를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /jfrog/artifactory
<span class="nb">sudo chown</span> <span class="nt">-R</span> 1030 /jfrog/
</code></pre></div></div>

<h2 id="step-4-start-jfrog-artifactory-container">Step 4: Start JFrog Artifactory container</h2>
<p>Artifactory 컨테이너를 시작하려면 다음 명령을 사용하십시오.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> artifactory <span class="nt">-d</span> <span class="nt">-p</span> 8081:8081 <span class="nt">-p</span> 8082:8082 <span class="se">\</span>
<span class="nt">-v</span> /jfrog/artifactory:/var/opt/jfrog/artifactory <span class="se">\</span>
docker.bintray.io/jfrog/artifactory-cpp-ce


docker ps
<span class="nt">---------------------------------------------------------------------------</span>
CONTAINER ID   IMAGE                                            COMMAND                  CREATED         STATUS         PORTS                                                           NAMES
29c549fecd50   docker.bintray.io/jfrog/artifactory-cpp-ce:latest   <span class="s2">"/entrypoint-artifac…"</span>   9 minutes ago   Up 9 minutes   0.0.0.0:8081-8082-&gt;8081-8082/tcp, :::8081-8082-&gt;8081-8082/tcp   artifactory
</code></pre></div></div>

<h2 id="step-5--running-jfrog-artifactory-container-with-systemd">Step 5 : Running JFrog Artifactory container with Systemd</h2>

<p>Systemd는 CentOS 7의 기본 초기화 시스템입니다. 이를 사용하여 JFrog Artifactory 컨테이너를 시스템 시작시 
시작할 수 있도록 관리할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /etc/systemd/system/artifactory.service
</code></pre></div></div>

<p>아래 내용을 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>Setup Systemd script <span class="k">for </span>Artifactory Container
<span class="nv">After</span><span class="o">=</span>network.target

<span class="o">[</span>Service]
<span class="nv">Restart</span><span class="o">=</span>always
<span class="nv">ExecStartPre</span><span class="o">=</span>-/usr/bin/docker <span class="nb">kill </span>artifactory
<span class="nv">ExecStartPre</span><span class="o">=</span>-/usr/bin/docker <span class="nb">rm </span>artifactory
<span class="nv">ExecStart</span><span class="o">=</span>/usr/bin/docker run <span class="nt">--name</span> artifactory <span class="nt">-p</span> 8081:8081 <span class="nt">-p</span> 8082:8082 <span class="se">\</span>
  <span class="nt">-v</span> /jfrog/artifactory:/var/opt/jfrog/artifactory <span class="se">\</span>
  docker.bintray.io/jfrog/artifactory-oss:latest
<span class="nv">ExecStop</span><span class="o">=</span>-/usr/bin/docker <span class="nb">kill </span>artifactory
<span class="nv">ExecStop</span><span class="o">=</span>-/usr/bin/docker <span class="nb">rm </span>artifactory

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target

</code></pre></div></div>

<p>Reload systemd.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl daemon-reload
</code></pre></div></div>

<p>systemd를 이용하여 Artifactory Container를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start artifactory
</code></pre></div></div>

<p>시스템이 재시작될 때 JFrog를 시작할 수 있도록 활성화합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">enable </span>artifactory
</code></pre></div></div>

<p>JFrog 서비스가 실행중인지 상태를 확인합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl status artifactory
</code></pre></div></div>

<p>서비스의 포트 binding 을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss <span class="nt">-tunelp</span> | <span class="nb">grep </span>8081
</code></pre></div></div>

<h2 id="step-6-web-ui에서-artifactory-서버에-접근">Step 6: WEB UI에서 Artifactory 서버에 접근</h2>

<p>JFrog Artifactory에 접근하기 위해 브라우저 URL에서 8081 포트로 접근합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://자신의 서버 IP 또는 localhost:8081/artifactory
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="JFrog" /><summary type="html"><![CDATA[JFrog on Docker Docker 기반 JFrog를 설치합니다.]]></summary></entry><entry><title type="html">Docker Engine 설치 on Centos7</title><link href="http://localhost:4000/docker/docker/" rel="alternate" type="text/html" title="Docker Engine 설치 on Centos7" /><published>2023-01-29T00:00:00+09:00</published><updated>2023-01-29T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker</id><content type="html" xml:base="http://localhost:4000/docker/docker/"><![CDATA[<h2 id="jfrog-on-docker">JFrog on Docker</h2>
<p>Centos7 기반 Docker Engine을 설치합니다.</p>

<h2 id="step-1-upgrade-os-package">Step 1: Upgrade OS package</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dnf upgrade <span class="nt">-y</span>
</code></pre></div></div>

<h2 id="step-2--install-docker-engine">Step 2 : Install Docker engine</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> yum-utils

</code></pre></div></div>
<p>Docker CE repsoitory정보를 download 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum-config-manager <span class="nt">--add-repo</span> https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></div></div>
<p>For Docker CE edition:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull docker.bintray.io/jfrog/artifactory-cpp-ce

yum <span class="nb">install</span> <span class="nt">-y</span> docker-ce docker-ce-cli containerd
</code></pre></div></div>

<p>Docker 를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start docker
</code></pre></div></div>

<p>Docker가 정상 설치되었는지 확인하기 위해 hello-world docker image를 download 받습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull hello-world
</code></pre></div></div>

<h2 id="step-3--install-docker-compose">Step 3 : Install docker-compose</h2>
<p>Docker compose를 download 받아서 설정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DOCKER_CONFIG</span><span class="o">=</span>/usr/local/lib/docker 
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$DOCKER_CONFIG</span>/cli-plugins

curl <span class="nt">-SL</span> https://github.com/docker/compose/releases/download/v2.14.2/docker-compose-linux-x86_64 <span class="nt">-o</span> <span class="nv">$DOCKER_CONFIG</span>/cli-plugins/docker-compose

<span class="nb">chmod</span> +x <span class="nv">$DOCKER_CONFIG</span>/cli-plugins/docker-compose
</code></pre></div></div>

<p>~/.bash_profile에  DOCER_CONFIG 환경변수를 추가하고 path에 DOCKER_CONFIG를 추가하고 저장합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.bash_profile 

<span class="nv">DOCKER_CONFIG</span><span class="o">=</span>/usr/local/lib/docker
<span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$HOME</span>/bin:<span class="nv">$DOCKER_CONFIG</span>/cli-plugins
</code></pre></div></div>

<p>docker-compose가  정상적으로 설치되었는지 docker-compose 명령어를 실행해 봅니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose version
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="docker" /><category term="docker-compose" /><summary type="html"><![CDATA[JFrog on Docker Centos7 기반 Docker Engine을 설치합니다.]]></summary></entry><entry><title type="html">리모트 서버에서 Harbor 서버에 docker login</title><link href="http://localhost:4000/docker/%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-Harbor-%EC%97%90-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="리모트 서버에서 Harbor 서버에 docker login" /><published>2023-01-29T00:00:00+09:00</published><updated>2023-01-29T00:00:00+09:00</updated><id>http://localhost:4000/docker/%EB%A6%AC%EB%AA%A8%ED%8A%B8%20%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C%20Harbor%20%EC%97%90%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/docker/%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-Harbor-%EC%97%90-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="리모트-서버에서-harbor-서버에-docker-login">리모트 서버에서 Harbor 서버에 docker login</h2>

<p>리모트 서버는 Centos7을 기준으로 합니다.</p>

<p>Harbor Container Registry를 구축하고 리모트 서버에서 docker login 하기 위해 환경을 설정합니다.</p>

<h2 id="step-1-setup-docker-engine">Step 1: Setup Docker Engine</h2>

<p>Docker Engine 설치는 아래 링크를 따라 설치과정을 참고해주세요</p>

<p><a href="https://yoonjk.github.io/docker/docker/">Docker Engine 설치</a></p>

<h2 id="step-2--jfrog-artifactory-docker-image-를-download">Step 2 : JFrog Artifactory Docker Image 를 download</h2>

<p>hosts file 파일에 domain을 등록합니다.</p>

<p>Harbor 설치서버의 사설 도메인 서버 이름이 server1.example.com 라고 가정하고 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"119.81.103.68 server1.example.com"</span> <span class="o">&gt;&gt;</span> /etc/hosts
</code></pre></div></div>

<h2 id="step-3--harbor-에서-제공하는-ca-인증서를-복사">Step 3 : Harbor 에서 제공하는 CA 인증서를 복사</h2>

<p>Harbor 에서 제공하는 CA 인증서를 복사하고, 인증서 참조 디렉토리에 복사합니다.<br />
ca 인증서가 /root/certs 폴더에 있다고 가정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>scp root@119.81.103.68:/root/certs/ca.crt <span class="nb">.</span>

<span class="nb">sudo cp </span>ca.crt /etc/pki/ca-trust/source/anchors/

update-ca-trust extract
</code></pre></div></div>

<h2 id="step-4-restart-docker-engine-및-로그인">Step 4: Restart Docker Engine 및 로그인</h2>
<p>Docker Engine을 재시작합니다.</p>

<p>Harbor Domain 이 server1.example.com 이라고 가정하고,<br />
로그인 사용자가 user01로 생성되어 있다면 다음과 같이 수행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart docker
docker login <span class="nt">-u</span> user01 <span class="nt">-p</span> XXXX server1.example.com

WARNING! Using <span class="nt">--password</span> via the CLI is insecure. Use <span class="nt">--password-stdin</span><span class="nb">.</span>
WARNING! Your password will be stored unencrypted <span class="k">in</span> /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="Harbor" /><summary type="html"><![CDATA[리모트 서버에서 Harbor 서버에 docker login]]></summary></entry><entry><title type="html">Nexus 설치 using docker</title><link href="http://localhost:4000/docker/nexus/" rel="alternate" type="text/html" title="Nexus 설치 using docker" /><published>2023-01-29T00:00:00+09:00</published><updated>2023-01-29T00:00:00+09:00</updated><id>http://localhost:4000/docker/nexus</id><content type="html" xml:base="http://localhost:4000/docker/nexus/"><![CDATA[<h2 id="sonartype-nexus-on-docker">Sonartype Nexus on Docker</h2>
<p>Centos7 기반 Docker Engine을 설치합니다.<br />
성</p>
<h2 id="step-1-docker-compose-파일-작성">Step 1: docker-compose 파일 작성</h2>
<p>nexus container 의 데이터를 저장할 폴더를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ./nexus-data
</code></pre></div></div>

<p>vi editor 로 docker-compose.yaml 파일을 아래와 같이 작성합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi docker-compose.yaml

version: <span class="s1">'3.7'</span>
services:
   nexus3:
      image: sonatype/nexus3
      restart: unless-stopped
      container_name: nexus3
      <span class="c"># privileged: true</span>
      user: root
      volumes:
         - ./nexus-data:/nexus-data
      healthcheck:
         <span class="nb">test</span>: <span class="o">[</span><span class="s2">"CMD"</span>, <span class="s2">"nc"</span>, <span class="s2">"-zv"</span>, <span class="s2">"localhost"</span>, <span class="s2">"8000"</span> <span class="o">]</span>
         interval: 5s
         <span class="nb">timeout</span>: 2s
         retries: 3
      ports:
         - 8081:8081
         - 5000:5000
</code></pre></div></div>

<h2 id="step-2--docker-compose-실행">Step 2 : docker-compose 실행</h2>
<p>docker-compose up 을 background 로 실행합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>

<h2 id="step-3--nexus-admin-로그인">step 3 : nexus admin 로그인</h2>
<p>브라우저에서 nexus 8081 포트를 접속하여 오른쪽 상단위 로그인(signin) 버튼을 클릭하여 admin으로 접속합니다.</p>

<p><img src="/assets/images/nexus/01-jenkins-nexus-home.png" alt="nexus home" /></p>

<p>Setup 화면에서 Next 버튼을 클릭합니다.</p>

<p><img src="/assets/images/nexus/02-jenkins-nexus-admin-1.png" alt="nexus admin" /></p>

<p>admin 사용자의 비밀번호를 입력하고, Next 버튼을 클릭합니다.</p>

<p><img src="/assets/images/nexus/02-jenkins-nexus-admin-2.png" alt="nexus admin" /></p>

<p>admin 사용자의 새로운 비밀번호를 입력하고, Next 버튼을 클릭합니다.</p>

<p><img src="/assets/images/nexus/02-jenkins-nexus-admin-3.png" alt="nexus admin" /></p>

<p>Anonymous 접근을 허용하지 않기 위해 Disable anonymous access 를 선택하고, Next 버튼을 클릭합니다.</p>

<p><img src="/assets/images/nexus/02-jenkins-nexus-admin-anonymous.png" alt="nexus admin" /></p>

<p>Complete 화면에서 finish 버튼을 클릭합니다.</p>

<h2 id="step-4--create-role-and-user">step 4 : Create Role and User</h2>

<p><img src="/assets/images/nexus/02-jenkins-nexus-admin-4.png" alt="nexus admin" /></p>

<p>Create Role 을 클릭합니다.</p>

<p><img src="/assets/images/nexus/03-jenkins-nexus-create-role.png" alt="nexus admin" /></p>

<p>Create Role을 생성합니다.</p>

<p><img src="/assets/images/nexus/03-jenkins-nexus-role.png" alt="nexus admin" /></p>

<p>Role 생성 결과입니다.</p>

<p><img src="/assets/images/nexus/03-jenkins-nexus-role-2.png" alt="nexus admin" /></p>

<p>Create Local User를 클릭하고 Create Local User를 생성합니다.</p>

<p><img src="/assets/images/nexus/03-jenkins-nexus-create-user.png" alt="nexus admin" /></p>

<p>Create Local User를 생성 결과입니다.</p>

<p><img src="/assets/images/nexus/03-jenkins-nexus-create-user-1.png" alt="nexus admin" /></p>
<h2 id="step-4--pomxml-에-nexus-정보를-추가">step 4 : pom.xml 에 nexus 정보를 추가</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://gitlab.com/nexweb/sample-service <span class="nt">-b</span> hello 

<span class="nb">cd </span>sample-service

vi pom.xml
</code></pre></div></div>

<p><img src="/assets/images/nexus/04-jenkins-nexus-pom.png" alt="nexus admin" /></p>

<h2 id="step-5--settingsxml-에-nexus-정보를-추가">step 5 : settings.xml 에 nexus 정보를 추가</h2>

<p>settings.xml에 nexus 정보를 추가합니다. id 값은 위의 pom.xml 파일에 있는 id값과 동일하게 설정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.m2/settings.xml
</code></pre></div></div>

<p><img src="/assets/images/nexus/05-jenkins-nexus-settings.png" alt="nexus admin" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="nexus" /><summary type="html"><![CDATA[Sonartype Nexus on Docker Centos7 기반 Docker Engine을 설치합니다. 성 Step 1: docker-compose 파일 작성 nexus container 의 데이터를 저장할 폴더를 생성합니다. mkdir ./nexus-data]]></summary></entry><entry><title type="html">Install MiniKube for Jenkins</title><link href="http://localhost:4000/kubernetes/install-minikube/" rel="alternate" type="text/html" title="Install MiniKube for Jenkins" /><published>2023-01-24T00:00:00+09:00</published><updated>2023-01-24T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/install-minikube</id><content type="html" xml:base="http://localhost:4000/kubernetes/install-minikube/"><![CDATA[<h2 id="pre-requisites---install-docker">Pre-requisites - Install Docker</h2>

<p>yum utils을 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> yum-utils
</code></pre></div></div>

<p>Docker repository 정보를 download 받습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum-config-manager <span class="se">\</span>
<span class="nt">--add-repo</span> <span class="se">\</span>
https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></div></div>

<p>최신 버전의 Docker Engine, containerd를 설치하거나 다음 단계로 이동하여 특정 버전을 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> docker-ce docker-ce-cli containerd.io
</code></pre></div></div>

<p>docker를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start docker
</code></pre></div></div>

<p>docker daemon이 정상 설치되었는지 hello-world docker image를 pull하기 위해 다음 명령어를 수행하여 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull hello-world 
</code></pre></div></div>

<p>[수행결과]
<img src="/assets/images/jenkins/07-jenkins-docker-hello-world.png" alt="docker pull hello-world" /></p>

<p>docker images를 수행하여 아래와 같이 출력되는 확인합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker images
</code></pre></div></div>

<p>[수행결과]
<img src="/assets/images/jenkins/08-jenkins-docker-images.png" alt="docker pull hello-world" /></p>

<h2 id="install-minikube">Install MiniKube</h2>

<p>minikube를 download 하고 minikube를 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-LO</span> https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
<span class="nb">sudo mv </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="nb">chmod</span> +x /usr/local/bin/minikube
</code></pre></div></div>

<p>minikube를 다음과 같이 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube start <span class="nt">--driver</span><span class="o">=</span>docker <span class="nt">--force</span>
</code></pre></div></div>

<p>kubectl CLI download 합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-L</span> <span class="s2">"https://dl.k8s.io/release/</span><span class="si">$(</span>curl <span class="nt">-L</span> <span class="nt">-s</span> https://dl.k8s.io/release/stable.txt<span class="si">)</span><span class="s2">/bin/linux/amd64/kubectl"</span> <span class="nt">-o</span> /usr/local/bin/kubectl

<span class="nb">chmod</span> +x /usr/local/bin/kubectl

kubectl get po <span class="nt">-A</span>
</code></pre></div></div>

<h2 id="configure-for-connecting-jenkins">Configure for connecting Jenkins</h2>

<p>jenkins에서 minikube에 접속하기 위해  Kubernetes 의 credentials 정보가 있는 $HOME/.kube/config 파일을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>less ~/.kube/config
</code></pre></div></div>

<p><img src="/assets/images/jenkins/09-jenkins-kube-config.png" alt="kube-config" /></p>

<p>위의 cluster CA 정보의 client 인증서 파일 경로를 데이터의 내용으로 변경 합니다
<img src="/assets/images/jenkins/10-jenkins-kube-config-2.png" alt="kube-config" /></p>

<p>아래의 명령어로 ca.crt, client.crt, client.key 파일의 내용을 다음의 명령어로 변환합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /root/.minikube/ca.crt|base64 <span class="nt">-w0</span><span class="p">;</span><span class="nb">echo
cat</span> /root/.minikube/profiles/minikube/client.crt|base64 <span class="nt">-w0</span><span class="p">;</span><span class="nb">echo
cat</span> /root/.minikube/profiles/minikube/client.key|base64 <span class="nt">-w0</span><span class="p">;</span><span class="nb">echo</span>
</code></pre></div></div>

<p>certificate-authority =&gt; certificate-authority-data로 변경
client-certificate =&gt; client-certificate-data 로 변경
client-key =&gt; client-key-data 로 변경</p>

<p><img src="/assets/images/jenkins/11-jenkins-change-kube-config.png" alt="kube-config" /></p>

<p>default namespace의 pod 목록이 조회되는지 다음과 같이 확인합니다.</p>

<p>kubectl get pods</p>

<p>[수행결과]
No resources found in default namespace.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="minikube" /><summary type="html"><![CDATA[Pre-requisites - Install Docker]]></summary></entry><entry><title type="html">Docker 기반 Jira 설치</title><link href="http://localhost:4000/docker/altassian-jira/" rel="alternate" type="text/html" title="Docker 기반 Jira 설치" /><published>2023-01-24T00:00:00+09:00</published><updated>2023-01-24T00:00:00+09:00</updated><id>http://localhost:4000/docker/altassian-jira</id><content type="html" xml:base="http://localhost:4000/docker/altassian-jira/"><![CDATA[<h2 id="jira-on-docker">Jira on Docker</h2>
<p>Docker 기반 Jira 입니다.</p>

<pre><code class="language-YAML">version: '3'
networks:
 jenkins-net:
    driver: bridge

services:
  jira:
    container_name: jira
    image: atlassian/jira-software:latest
    networks:
      - jenkins-net
    ports:
      - "9010:8080"

  postgres:
    container_name: postgres
    image: postgres:latest
    volumes:
      - ./data:/var/lib/postgresql/data
    environment:
      - 'POSTGRES_USER=postgres'
      # CHANGE THE PASSWORD!
      - 'POSTGRES_PASSWORD=admin1234'
      - 'POSTGRES_DB=jira'
      - 'POSTGRES_ENCODING=UTF8'
    networks:
      - jenkins-net
    ports:
      - "5432:5432"
</code></pre>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="jira" /><summary type="html"><![CDATA[Jira on Docker Docker 기반 Jira 입니다.]]></summary></entry><entry><title type="html">Docker 기반 Bitbucket 설치</title><link href="http://localhost:4000/docker/altassian-bitbucket-jira/" rel="alternate" type="text/html" title="Docker 기반 Bitbucket 설치" /><published>2023-01-24T00:00:00+09:00</published><updated>2023-01-24T00:00:00+09:00</updated><id>http://localhost:4000/docker/altassian-bitbucket-jira</id><content type="html" xml:base="http://localhost:4000/docker/altassian-bitbucket-jira/"><![CDATA[<h2 id="bitbucket-on-docker">Bitbucket on Docker</h2>
<p>Docker 기반 Bitbucket 입니다.</p>

<pre><code class="language-YAML">version: '3'
networks:
 jenkins-net:
    driver: bridge

services:
  bitbucket:
    container_name: bitbucket
    image: atlassian/bitbucket-server:latest
    environment:
      - 'BITBUCKET_PROXY_PORT='
      - 'BITBUCKET_PROXY_SCHEME='
      - 'BITBUCKET_DELAYED_START='
      - 'DOCKER_WAIT_HOST=postgres'
      - 'DOCKER_WAIT_PORT=5432'
    networks:
      - jenkins-net
    ports:
      - "8990:7990"

  postgres:
    container_name: postgres
    image: postgres:latest
    volumes:
      - ./data:/var/lib/postgresql/data
    environment:
      - 'POSTGRES_USER=postgres'
      # CHANGE THE PASSWORD!
      - 'POSTGRES_PASSWORD=admin1234'
      - 'POSTGRES_DB=bitbucket'
      - 'POSTGRES_ENCODING=UTF8'
    networks:
      - jenkins-net
    ports:
      - "5432:5432"
</code></pre>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="bitbucket" /><summary type="html"><![CDATA[Bitbucket on Docker Docker 기반 Bitbucket 입니다.]]></summary></entry><entry><title type="html">Jenkins 설치 따라하기</title><link href="http://localhost:4000/devops/setup-jenkins/" rel="alternate" type="text/html" title="Jenkins 설치 따라하기" /><published>2023-01-24T00:00:00+09:00</published><updated>2023-01-24T00:00:00+09:00</updated><id>http://localhost:4000/devops/setup%20jenkins</id><content type="html" xml:base="http://localhost:4000/devops/setup-jenkins/"><![CDATA[<h2 id="jenkins-pipeline-이란">Jenkins Pipeline 이란?</h2>
<p>Jenkins Pipeline은 지속적인 업데이트 파이프라인을 구현하고 Jenkins에 통합하는 것을 지원하는 플러그인의 집합이다. 이 과정에서 소프트웨어를 빌드하고 여러 단계의 테스트, 배포를 진행한다. 
Pipeline은 Pipeline Domain Specific Language라는 문법을 통해 마치 코드를 작성하는 것과 같이 Pipeline을 통해 간단한 배포 파이프라인부터 복잡한 배포  파이프라인을 코드로 모델링하기 위한 확장 가능한 도구 집합을 제공합니다.
. 
Jenkins 파이프 라인의 정의는 프로젝트의 소스 제어 저장소에 commit될 수 있는 텍스트 파일 (Jenkinsfile이라고 함)에 저장합니다.</p>

<ul>
  <li><strong>Install Jenkins on Linux(Centos)</strong></li>
</ul>

<p>Jenkins를 설치하기 전에 사전에 JDK와 Maven을 설치합니다. 
상세한 설치 정보는 다음의 링크를 참조합니다.</p>

<p>https://www.jenkins.io/doc/book/installing/linux/</p>

<p>java-11-openjdk을 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf upgrade <span class="nt">-y</span>
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> java-11-openjdk
</code></pre></div></div>

<p>다음의 링크를 접속하여 Maven 설치합니다.
https://maven.apache.org/download.cgi 에서 최근  maven 링크를 복사합니다</p>

<figure style="width: 100%" class="align-left">
  <img src="http://localhost:4000/assets/images/jenkins/01-jenkins-install-maven.png" alt="" />
  <figcaption></figcaption>
</figure>

<p>설치하고자 하는 경로에 압축파일을 다운 받아 압축을 해제한 후, 해당 폴더가 위치한 곳을 MAVEN_HOME으로 설정합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://dlcdn.apache.org/maven/maven-3/3.8.7/binaries/apache-maven-3.8.7-bin.tar.gz

<span class="nb">tar </span>xvzf apache-maven-3.8.7-bin.tar.gz <span class="nt">-C</span> /usr/local
</code></pre></div></div>

<p>~/.bash_profile을 vi editor로 열어MAVEN_HOME 환경정보를 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">MAVEN_HOME</span><span class="o">=</span>/usr/local/apache-maven-3.8.7 
<span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$MAVEN_HOME</span>/bin 
</code></pre></div></div>

<p>bash profile을 설정하고 저장하고, bash_profile을 최신으로 적용합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.bash_profile 
</code></pre></div></div>

<p>maven 설정되었는지 다음의 명령어로 수행하여 아래의 내용이 출력되는지 확인합니다.</p>

<p>mvn</p>

<p>[수행결과]
<img src="/assets/images/jenkins/02-jenkins-mvn.png" alt="transparent black overlay" /></p>

<p>다음과 같이Git 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> git
</code></pre></div></div>

<p>레포지터리에 젠킨스 레드햇 안정화 버전 레포지터리를 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://pkg.jenkins.io/redhat-stable/jenkins.repo <span class="nt">-O</span> /etc/yum.repos.d/jenkins.repo 
</code></pre></div></div>

<p>rpm에 젠킨스를 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>rpm <span class="nt">--import</span> https://pkg.jenkins.io/redhat-stable/jenkins.io.key
</code></pre></div></div>

<p>Jenkins 를 다음과 같이 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> jenkins
</code></pre></div></div>

<p>OS 부팅 시 Jenkins 서비스가 시작되도록 설정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">enable </span>jenkins
</code></pre></div></div>

<p>다음 명령을 사용하여 Jenkins 서비스를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start jenkins
</code></pre></div></div>

<p>다음 명령을 사용하여 Jenkins 서비스의 상태를 확인할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl status jenkins
</code></pre></div></div>

<p>docker container image 빌드를 위해 빌드 툴인 Podman을 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> podman 
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><summary type="html"><![CDATA[Jenkins Pipeline 이란? Jenkins Pipeline은 지속적인 업데이트 파이프라인을 구현하고 Jenkins에 통합하는 것을 지원하는 플러그인의 집합이다. 이 과정에서 소프트웨어를 빌드하고 여러 단계의 테스트, 배포를 진행한다. Pipeline은 Pipeline Domain Specific Language라는 문법을 통해 마치 코드를 작성하는 것과 같이 Pipeline을 통해 간단한 배포 파이프라인부터 복잡한 배포 파이프라인을 코드로 모델링하기 위한 확장 가능한 도구 집합을 제공합니다. . Jenkins 파이프 라인의 정의는 프로젝트의 소스 제어 저장소에 commit될 수 있는 텍스트 파일 (Jenkinsfile이라고 함)에 저장합니다.]]></summary></entry></feed>