<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-16T06:44:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Getting Start Redis - Docker를 이용하여 모니터링</title><link href="http://localhost:4000/cache/redis-stat-docker/" rel="alternate" type="text/html" title="Getting Start Redis - Docker를 이용하여 모니터링" /><published>2023-04-15T00:00:00+09:00</published><updated>2023-04-15T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-stat-docker</id><content type="html" xml:base="http://localhost:4000/cache/redis-stat-docker/"><![CDATA[<h2 id="redis-sentinel-을-docker-를-사용하여-구성---사전준비">Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비</h2>
<p>Redis Sentinel과 Cluster를 redis-stat로 모니터링하는 것을 docker 기반으로 구성합니다.
myIP는 자신의 환경에 맞는 VM Server의 IP를 설정합니다.</p>

<h2 id="redis-모니터링---docker-compose">Redis 모니터링 - docker-compose</h2>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis-stat</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis-stat</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">insready/redis-stat</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span>
        <span class="s1">'</span><span class="s">--verbose'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">--server'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">redis-master:6379'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">redis-replica1:6383'</span><span class="pi">,</span>
        <span class="s1">'</span><span class="s">redis-replica2:6384'</span>
        <span class="pi">]</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIP"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIP</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-replica2:myIP"</span>
  
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">9999:63790"</span>
</code></pre></div></div>
<h2 id="참조-">참조 :</h2>
<p><a href="https://hyos-dev-log.tistory.com/m/22">Hyo’s Dev Log</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비 Redis Sentinel과 Cluster를 redis-stat로 모니터링하는 것을 docker 기반으로 구성합니다. myIP는 자신의 환경에 맞는 VM Server의 IP를 설정합니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Docker를 이용하여 Redis Sentinel 구성</title><link href="http://localhost:4000/cache/setup-sentinel-docker/" rel="alternate" type="text/html" title="Getting Start Redis - Docker를 이용하여 Redis Sentinel 구성" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-14T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-sentinel-docker</id><content type="html" xml:base="http://localhost:4000/cache/setup-sentinel-docker/"><![CDATA[<h2 id="redis-sentinel-을-docker-를-사용하여-구성---사전준비">Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비</h2>
<p>Redis Sentinel 을 docker기반으로 구성하기 위해서는 docker, docker-compose를 설치하여야 합니다.</p>

<p>docker engine 설치방법은 아래의 <a href="https://yoonjk.github.io/docker/docker/">링크</a>를 참조하세요.</p>

<h2 id="redis-sentinel---docker-compose">Redis Sentinel - docker-compose</h2>
<ul>
  <li>port 설정</li>
  <li>extra_hosts설정</li>
  <li>redis master/replica1/2는 netowrk_mode를 host로 설정</li>
  <li>sentinel은 client에서 접근하기 위해 port를 expose (5000,5001,5002)</li>
  <li>sentinel 구성은 QUORUM으로 구성합니다.</li>
</ul>

<p>redis master 의 port 는 default port 6379로 설정합니다.
replica의 port는 6383, 6384로 설정합니다.</p>

<p>extra_hosts에  myIP대신 VM 서버의 IP로 변경합니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>

<span class="na">services</span><span class="pi">:</span>

  <span class="na">redis-master</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">master</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --port </span><span class="m">6379</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">./master:/data"</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="na">redis-replica1</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">replica1</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --slaveof redis-master 6379  --replicaof redis-master 6379 --port </span><span class="m">6383</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">./replica1:/data"</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="na">redis-replica2</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">replica2</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --slaveof redis-master 6379  --replicaof redis-master 6379 --port </span><span class="m">6384</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">./replica2:/data"</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s">host</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="c1"># Instance 1</span>
  <span class="na">redis-sentinel1</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">sentinel1</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./sentinel</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000:26379"</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="c1"># Instance 2</span>
  <span class="na">redis-sentinel2</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">sentinel2</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./sentinel</span>
    <span class="na">links</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis-master</span>
      <span class="pi">-</span> <span class="s">redis-replica1</span>
      <span class="pi">-</span> <span class="s">redis-replica2</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5001:26379"</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>

  <span class="c1"># Instance 3</span>
  <span class="na">redis-sentinel3</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">sentinel3</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./sentinel</span>
    <span class="na">links</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis-master</span>
      <span class="pi">-</span> <span class="s">redis-replica1</span>
      <span class="pi">-</span> <span class="s">redis-replica2</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5002:26379"</span>
    <span class="na">extra_hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-master:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica1:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-replica2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel1:myIp</span>
      <span class="s">-</span><span class="nv"> </span><span class="s">"redis-sentinel2:myIp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">redis-sentinel3:myIp"</span>
</code></pre></div></div>

<p>sentinel.conf 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port 26379

<span class="nb">dir</span> /tmp

sentinel resolve-hostnames <span class="nb">yes
</span>sentinel monitor redismaster redis-master 6379 <span class="nv">$SENTINEL_QUORUM</span>
sentinel down-after-milliseconds redismaster <span class="nv">$SENTINEL_DOWN_AFTER</span>
sentinel parallel-syncs redismaster 1
sentinel failover-timeout redismaster <span class="nv">$SENTINEL_FAILOVER</span>
</code></pre></div></div>
<p>entrypoint.sh 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/</span><span class="se">\$</span><span class="s2">SENTINEL_QUORUM/</span><span class="nv">$SENTINEL_QUORUM</span><span class="s2">/g"</span> /redis/sentinel.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/</span><span class="se">\$</span><span class="s2">SENTINEL_DOWN_AFTER/</span><span class="nv">$SENTINEL_DOWN_AFTER</span><span class="s2">/g"</span> /redis/sentinel.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/</span><span class="se">\$</span><span class="s2">SENTINEL_FAILOVER/</span><span class="nv">$SENTINEL_FAILOVER</span><span class="s2">/g"</span> /redis/sentinel.conf

redis-server /redis/sentinel.conf <span class="nt">--sentinel</span>
</code></pre></div></div>

<p>Dockerfile</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> redis</span>

<span class="k">ENV</span><span class="s"> SENTINEL_QUORUM 2</span>
<span class="k">ENV</span><span class="s"> SENTINEL_DOWN_AFTER 1000</span>
<span class="k">ENV</span><span class="s"> SENTINEL_FAILOVER 1000</span>

<span class="k">RUN </span><span class="nb">mkdir</span> <span class="nt">-p</span> /redis

<span class="k">WORKDIR</span><span class="s"> /redis</span>

<span class="k">COPY</span><span class="s"> sentinel.conf .</span>
<span class="k">COPY</span><span class="s"> sentinel-entrypoint.sh /usr/local/bin/</span>

<span class="k">RUN </span><span class="nb">chown </span>redis:redis /redis/<span class="k">*</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">chmod</span> +x /usr/local/bin/sentinel-entrypoint.sh

<span class="k">EXPOSE</span><span class="s"> 26379</span>

<span class="k">ENTRYPOINT</span><span class="s"> ["sentinel-entrypoint.sh"]</span>
</code></pre></div></div>

<h2 id="참조-">참조 :</h2>
<p><a href="https://github.com/Developers-Notebook/Redis-Sentinel-Docker-Compose">Redis-Sentinel-Docker-Compose</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 을 docker 를 사용하여 구성 - 사전준비 Redis Sentinel 을 docker기반으로 구성하기 위해서는 docker, docker-compose를 설치하여야 합니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Cluster Failover 설정</title><link href="http://localhost:4000/cache/failover-redis-cluster/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Cluster Failover 설정" /><published>2023-04-12T00:00:00+09:00</published><updated>2023-04-12T00:00:00+09:00</updated><id>http://localhost:4000/cache/failover-redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/failover-redis-cluster/"><![CDATA[<h2 id="redis-cluster-configuration-설정">Redis Cluster Configuration 설정</h2>
<p>Redis Cluster를 구성하고 failover 하기 위해서는 application config 이외에 추가적으로  Redis cluster Confugration이 필요합니다.
Redis Cluster를 구성하고 Master를 강제로 종료시키면 Replica중 1개가 Master로 승격되어 지속적인 서비스를 이어갈 수 있습니다.<br />
그리고 Lettuce를 사용하면 이를 자동으로 감지하여 서비스를 지속할 수 있습니다. 
그러나 쓰기작업이 필요한 서비스는 약간의 delay를 요구하며, Redis Cluster 상태가 refresh되면 정상적인 쓰기 작업이 가능해집니다.
물론 일기작업은 다음의 설정으로 변함없이 지속적으로 서비스가 가능합니다.</p>
<h4 id="지속적인-읽기-작업">지속적인 읽기 작업</h4>
<p>Replica중 1개 또는 모두 종료되더라도 지속적으로 일기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.</p>

<p><strong>REPLICA_PREFERRED</strong></p>

<h4 id="지속적인-쓰기-작업">지속적인 쓰기 작업</h4>
<p>Redis Cluster Master중 1개가 종료되더라도 지속적으로 쓰기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.
아래의 설정값이 default 값이 false로 되어 있기 때문에 true로 설정을 변경해야 master가 종료되고 replica중 1개가 master로 승격되어 서비스를 계속할 수 있게되고, 이를 Lettuce가 감지하여 애플리케이션에서도 서비스를 지속하기 위해 아래의 설정을 하여야 합니다.</p>

<p><strong>enablePeriodicRefresh</strong></p>

<p>그리고 Refresh time을 설정하여 Lettuce가 이를 빠르게 감지하도록 설정합니다.
<strong>refreshPeriod</strong></p>

<p>다음의 코드는 Redis Cluster를 구성하고 replica가 종료되거나 cluster의 master가 종료되더라도 읽기 작업과 쓰기 작업을 지속할 수 있도록 하기 위한 설정정보입니다.</p>

<p>전체 소스는 아래의 <a href="https://github.com/yoonjk/redis-cluster.git">github 링크</a>에 있습니다.
<a href="https://github.com/yoonjk/redis-cluster.git">https://github.com/yoonjk/redis-cluster.git</a></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.time.Duration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.RedisClusterConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.RedisConnectionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">io.lettuce.core.ReadFrom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.lettuce.core.cluster.ClusterClientOptions</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.lettuce.core.cluster.ClusterTopologyRefreshOptions</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="o">{</span>
	<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.cluster.nodes}"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clusterNodes</span><span class="o">;</span>
    <span class="c1">// lettuce 사용시</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisConnectionFactory</span> <span class="nf">redisConnectionFactory</span><span class="o">(){</span>
        <span class="nc">LettuceClientConfiguration</span> <span class="n">clientConfiguration</span> <span class="o">=</span> <span class="nc">LettuceClientConfiguration</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        		<span class="o">.</span><span class="na">clientOptions</span><span class="o">(</span><span class="nc">ClusterClientOptions</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        				<span class="o">.</span><span class="na">topologyRefreshOptions</span><span class="o">(</span><span class="nc">ClusterTopologyRefreshOptions</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        						<span class="o">.</span><span class="na">refreshPeriod</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
        						<span class="o">.</span><span class="na">enableAdaptiveRefreshTrigger</span><span class="o">()</span>
        						<span class="o">.</span><span class="na">enablePeriodicRefresh</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>    <span class="c1">// Default 가 False</span>
        						<span class="o">.</span><span class="na">build</span><span class="o">())</span>
        				<span class="o">.</span><span class="na">build</span><span class="o">())</span>
        		
                <span class="o">.</span><span class="na">readFrom</span><span class="o">(</span><span class="nc">ReadFrom</span><span class="o">.</span><span class="na">REPLICA_PREFERRED</span><span class="o">)</span> <span class="c1">// 복제본 노드에서 읽지 만 사용할 수없는 경우 마스터에서 읽습니다.</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
        

        <span class="c1">// 모든 클러스터(master, slave) 정보를 적는다. (해당 서버중 접속되는 서버에서 cluster nodes 명령어를 통해 모든 클러스터 정보를 읽어오기에 다운 됐을 경우를 대비하여 모든 노드 정보를 적어두는편이 좋다.)</span>
        <span class="nc">RedisClusterConfiguration</span> <span class="n">redisClusterConfiguration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisClusterConfiguration</span><span class="o">(</span><span class="n">clusterNodes</span><span class="o">);</span>
        
        <span class="nc">LettuceConnectionFactory</span> <span class="n">lettuceConnectionFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LettuceConnectionFactory</span><span class="o">(</span><span class="n">redisClusterConfiguration</span><span class="o">,</span> <span class="n">clientConfiguration</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">lettuceConnectionFactory</span><span class="o">;</span>
    <span class="o">}</span>
        
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis Cluster Configuration 설정 Redis Cluster를 구성하고 failover 하기 위해서는 application config 이외에 추가적으로 Redis cluster Confugration이 필요합니다. Redis Cluster를 구성하고 Master를 강제로 종료시키면 Replica중 1개가 Master로 승격되어 지속적인 서비스를 이어갈 수 있습니다. 그리고 Lettuce를 사용하면 이를 자동으로 감지하여 서비스를 지속할 수 있습니다. 그러나 쓰기작업이 필요한 서비스는 약간의 delay를 요구하며, Redis Cluster 상태가 refresh되면 정상적인 쓰기 작업이 가능해집니다. 물론 일기작업은 다음의 설정으로 변함없이 지속적으로 서비스가 가능합니다. 지속적인 읽기 작업 Replica중 1개 또는 모두 종료되더라도 지속적으로 일기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Docker를 이용한 클러스터링 구성</title><link href="http://localhost:4000/cache/redis-cluster-using-docker/" rel="alternate" type="text/html" title="Getting Start Redis - Docker를 이용한 클러스터링 구성" /><published>2023-04-12T00:00:00+09:00</published><updated>2023-04-12T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster-using-docker</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster-using-docker/"><![CDATA[<h2 id="redisconf-편집">redis.conf 편집</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> 6300 6301 6302 6400 6401 6402
</code></pre></div></div>
<p>redis config 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## redis.conf 편집</span>
vi redis.conf
port 6379
cluster-enabled <span class="nb">yes
</span>cluster-config-file nodes.conf
cluster-node-timeout 3000
appendonly <span class="nb">yes</span>
</code></pre></div></div>
<p>redis.conf를 각 폴더에 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf 6300/
<span class="nb">cp </span>redis.conf 6301/
<span class="nb">cp </span>redis.conf 6302/
<span class="nb">cp </span>redis.conf 6400/
<span class="nb">cp </span>redis.conf 6401/
<span class="nb">cp </span>redis.conf 6402/
</code></pre></div></div>

<p>redis.conf를 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6300/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6301/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6302/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6400/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6401/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6402/g'</span> 6300/redis.conf
</code></pre></div></div>

<h2 id="master-redis-작성">Master Redis 작성</h2>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis1</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis1</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis1</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./6300/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">6300:6300</span>
    <span class="pi">-</span> <span class="s">16300:16300</span>

  <span class="na">redis2</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis2</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis2</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6301/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6301:6301</span>
      <span class="pi">-</span> <span class="s">16301:16301</span>

  <span class="na">redis3</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis3</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis3</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6302/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6302:6302</span>
      <span class="pi">-</span> <span class="s">16302:16302</span>

  <span class="na">redis4</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis4</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis4</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6400/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6400:6400</span>
      <span class="pi">-</span> <span class="s">16400:16400</span>

  <span class="na">redis5</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis5</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis5</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6401/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6401:6401</span>
      <span class="pi">-</span> <span class="s">16401:16401</span>

  <span class="na">redis6</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis6</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis6</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6402/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6402:6402</span>
      <span class="pi">-</span> <span class="s">16402:16402</span>
</code></pre></div></div>
<h2 id="redis-cluster-시작">Redis cluster 시작</h2>
<p>docker-compose 이용하여 Redis Cluster를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
docker ps
</code></pre></div></div>

<h4 id="클러스터-구성">클러스터 구성</h4>
<p>6개의 docker container redis가 실행중인 것을 확인하고 redis1에 접속하여 다음과 같이 클러스터를 구성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> redis1 bash
redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
<span class="nb">exit</span>
</code></pre></div></div>
<p>redis1 container의 로그를 다음과 같이 확인합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs -f redis1
</code></pre></div></div>
<h4 id="replicas-구성">Replicas 구성</h4>
<p>Redis Master에 각각 1개의 Replica를 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># master1에 replica 1 추가</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> redis1 bash
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>

<span class="c"># master2에 replica 2 추가</span>
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>

<span class="c"># master3에 replica 3 추가</span>
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<p><img src="/assets/images/cache/13-cache-add-slave-docker.png" alt="Create Admin" /></p>
<h2 id="참고">참고</h2>
<p><a href="https://uchupura.tistory.com/56">우쭈뿌라 개발노트</a><br />
<a href="https://pinggoopark.tistory.com/268">과거의 나를 위해</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="docker" /><summary type="html"><![CDATA[redis.conf 편집]]></summary></entry><entry><title type="html">@Inject과 @Autowired의 차이점</title><link href="http://localhost:4000/springboot/difference-autowired-inject/" rel="alternate" type="text/html" title="@Inject과 @Autowired의 차이점" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T00:00:00+09:00</updated><id>http://localhost:4000/springboot/difference-autowired-inject</id><content type="html" xml:base="http://localhost:4000/springboot/difference-autowired-inject/"><![CDATA[<h2 id="inject-vs-autowired">@Inject vs @Autowired</h2>
<p>@Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다.
@Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.</p>

<table>
  <thead>
    <tr>
      <th>Sr. No.	Key</th>
      <th>@Inject</th>
      <th>@Autowired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1	Basic</td>
      <td>그것은 자바 CDI의 일부입니다</td>
      <td>스프링 프레임 워크의 일부입니다.</td>
    </tr>
    <tr>
      <td>2	Required</td>
      <td>required 속성이 없습니다.</td>
      <td>required속성이 있습니다.</td>
    </tr>
    <tr>
      <td>3	Default Scope	autowire</td>
      <td>기본 범위는 싱글톤입니다.</td>
      <td>주입 빈의 기본 범위는 prototype입니다.</td>
    </tr>
    <tr>
      <td>4	Ambiguity</td>
      <td>주입을 위해 빈에 모호성이있는 경우 코드에 @Named해야합니다</td>
      <td>주입을 위해 Bean에 모호한 경우 코드에 @Qualifer 추가해야합니다.</td>
    </tr>
    <tr>
      <td>5	Advantage</td>
      <td>Java CDI의 일부이므로 DI 프레임워크에 의존하지 않습니다.</td>
      <td>시스템을 느슨하게 결합합니다.</td>
    </tr>
  </tbody>
</table>

<p>응용 프로그램을 Spring 프레임워크와 밀접하게 결합시킵니다. 나중에 다른 DI 프레임워크로 이동하려면 응용 프로그램을 다시 구성해야합니다.</p>

<p>@Injection 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InjectionExample</span> <span class="o">{</span>
   <span class="nd">@Inject</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@Autowired 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutowiredExample</span> <span class="o">{</span>
   <span class="nd">@Autowired</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="springboot" /><summary type="html"><![CDATA[@Inject vs @Autowired @Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다. @Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Cluster</title><link href="http://localhost:4000/cache/redis-cluster/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Cluster" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster/"><![CDATA[<h2 id="redis-cluster-환경구성">Redis Cluster 환경구성</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port <span class="o">[</span>각자포트]
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-[각자포트].conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_[각자포트].aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_[각자포트].pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_[각자포트].log
</code></pre></div></div>
<p>redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-server 6300</span>
<span class="nb">cp </span>redis.conf redis_6300.conf
vi redis_6300.conf
</code></pre></div></div>
<p>redis_6300.conf 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port 6300
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-6300.conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_6300.aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_6300.pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_6300.log
</code></pre></div></div>
<p>나머지 redis server의 환경파일을 복사하고 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6300.conf redis_6301.conf
<span class="nb">cp </span>redis_6300.conf redis_6302.conf
<span class="nb">cp </span>redis_6300.conf redis_6400.conf
<span class="nb">cp </span>redis_6300.conf redis_6401.conf
<span class="nb">cp </span>redis_6300.conf redis_6402.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6301/g'</span> redis_6301.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6302/g'</span> redis_6302.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6400/g'</span> redis_6400.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6401/g'</span> redis_6401.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6402/g'</span> redis_6402.conf
</code></pre></div></div>

<h2 id="redis-cluster-실행">Redis Cluster 실행</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./src/redis-server redis_6300.conf
./src/redis-server redis_6301.conf
./src/redis-server redis_6302.conf
./src/redis-server redis_6400.conf
./src/redis-server redis_6401.conf
./src/redis-server redis_6402.conf

redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
</code></pre></div></div>
<h4 id="redis-cluster-실행로그">redis cluster 실행로그</h4>
<p><img src="/assets/images/cache/08-cache-create-redis-cluster.png" alt="Jupyter log" /></p>

<h4 id="master-노드-로그">Master 노드 로그</h4>
<p><img src="/assets/images/cache/09-cache-log-redis-cluster.png" alt="Jupyter log" /></p>

<h2 id="slave1-등록">Slave1 등록</h2>
<p>Master1(6300)에 Slave1(6400) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>
</code></pre></div></div>
<h4 id="slave-등록-로그">Slave 등록 로그</h4>
<p><img src="/assets/images/cache/10-cache-add-slave-node.png" alt="Jupyter log" /></p>

<h4 id="master-로그">Master 로그</h4>
<p><img src="/assets/images/cache/11-cache-log-redis-master.png" alt="Jupyter log" /></p>

<h4 id="slave2-등록">Slave2 등록</h4>
<p>Master2(6301)에 Slave1(6401) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h4 id="slave3-등록">Slave3 등록</h4>
<p>Master3(6302)에 Slave1(6402) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h2 id="클러스터-정보확인">클러스터 정보확인</h2>
<p>redis 클러스터 정보를 다음과 같이 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> info 127.0.0.1:6300
</code></pre></div></div>
<h4 id="redis-cluster-failover">Redis Cluster Failover</h4>
<p>Redis Master를 강제로 종료했을 떄 어떻게 failover되는지 확인하기 위해 master1(6300)을 강제로 종료하여 redis stat로 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis
<span class="nb">kill</span> <span class="nt">-9</span> pid
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Cluster 환경구성 port [각자포트] # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-[각자포트].conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_[각자포트].aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_[각자포트].pid # 로그 파일 저장 경로 지정 logfile logs/redis_[각자포트].log redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다. # redis-server 6300 cp redis.conf redis_6300.conf vi redis_6300.conf redis_6300.conf 파일을 다음과 같이 수정합니다. port 6300 # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-6300.conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_6300.aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_6300.pid # 로그 파일 저장 경로 지정 logfile logs/redis_6300.log 나머지 redis server의 환경파일을 복사하고 수정합니다. ```bash cp redis_6300.conf redis_6301.conf cp redis_6300.conf redis_6302.conf cp redis_6300.conf redis_6400.conf cp redis_6300.conf redis_6401.conf cp redis_6300.conf redis_6402.conf]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Sentinel &amp;amp; HAProxy</title><link href="http://localhost:4000/cache/haproxy/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Sentinel &amp;amp; HAProxy" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/haproxy</id><content type="html" xml:base="http://localhost:4000/cache/haproxy/"><![CDATA[<p>Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.</p>

<h2 id="haproxy-환경-구성">Haproxy 환경 구성</h2>

<h4 id="haproxy-설치를-위한-의존성-패키지-설치">HAProxy 설치를 위한 의존성 패키지 설치</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># HAProxy 설치를 위한 의존성 패키지 설치</span>
yum <span class="nb">install</span> <span class="nt">-y</span> gcc openssl openssl-devel pcre-static pcre-devel systemd-devel
</code></pre></div></div>

<h4 id="haproxy-설치">Haproxy 설치</h4>
<p>haproxy를 구성하기 위해 haproxy 최근 버전을 <a href="http://www.haproxy.org/download/2.8/src/devel/">download</a>하여 build 및 install합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://www.haproxy.org/download/2.8/src/devel/haproxy-2.8-dev7.tar.gz
<span class="nb">tar </span>xvzf haproxy-2.8-dev7.tar.gz
<span class="nb">cd </span>haproxy-2.8-dev7 
make <span class="nv">TARGET</span><span class="o">=</span>linux-glibc <span class="nv">USE_OPENSSL</span><span class="o">=</span>1 <span class="nv">USE_PCRE</span><span class="o">=</span>1 <span class="nv">USE_ZLIB</span><span class="o">=</span>1 <span class="nv">USE_SYSTEMD</span><span class="o">=</span>1

<span class="c">## Install haproxy</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>아래의 명령어를 입력하여 설치된 HAProxy 버전을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/sbin/haproxy <span class="nt">-v</span>
</code></pre></div></div>
<p>OS가 reboot되어도 재시작하도록 service 파일을 작서합니다. 아래의 명령어를 입력하여 HAProxy 서비스 예제 파일을 다운로드합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"http://git.haproxy.org/?p=haproxy-2.3.git;a=blob_plain;f=contrib/systemd/haproxy.service.in"</span> <span class="nt">-o</span> /etc/systemd/system/haproxy.service

<span class="c"># 서비스파일 편집</span>
vi /etc/systemd/system/haproxy.service
</code></pre></div></div>
<p>아래와 같이 서비스 파일에서 아래의 3개의 내용을 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
</code></pre></div></div>

<p>서비프파일 전체 내용</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>HAProxy Load Balancer
<span class="nv">After</span><span class="o">=</span>network-online.target
<span class="nv">Wants</span><span class="o">=</span>network-online.target

<span class="o">[</span>Service]
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/default/haproxy
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/sysconfig/haproxy
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"CONFIG=/etc/haproxy/haproxy.cfg"</span> <span class="s2">"PIDFILE=/run/haproxy.pid"</span> <span class="s2">"EXTRAOPTS=-S /run/haproxy-master.sock"</span>
<span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
<span class="nv">ExecReload</span><span class="o">=</span>/bin/kill <span class="nt">-USR2</span> <span class="nv">$MAINPID</span>
<span class="nv">KillMode</span><span class="o">=</span>mixed
<span class="nv">Restart</span><span class="o">=</span>always
<span class="nv">SuccessExitStatus</span><span class="o">=</span>143
<span class="nv">Type</span><span class="o">=</span>notify

<span class="c"># The following lines leverage SystemD's sandboxing options to provide</span>
<span class="c"># defense in depth protection at the expense of restricting some flexibility</span>
<span class="c"># in your setup (e.g. placement of your configuration files) or possibly</span>
<span class="c"># reduced performance. See systemd.service(5) and systemd.exec(5) for further</span>
<span class="c"># information.</span>

<span class="c"># NoNewPrivileges=true</span>
<span class="c"># ProtectHome=true</span>
<span class="c"># If you want to use 'ProtectSystem=strict' you should whitelist the PIDFILE,</span>
<span class="c"># any state files and any other files written using 'ReadWritePaths' or</span>
<span class="c"># 'RuntimeDirectory'.</span>
<span class="c"># ProtectSystem=true</span>
<span class="c"># ProtectKernelTunables=true</span>
<span class="c"># ProtectKernelModules=true</span>
<span class="c"># ProtectControlGroups=true</span>
<span class="c"># If your SystemD version supports them, you can add: @reboot, @swap, @sync</span>
<span class="c"># SystemCallFilter=~@cpu-emulation @keyring @module @obsolete @raw-io</span>

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div></div>
<h2 id="haproxy-설정파일-수정">haproxy 설정파일 수정</h2>
<p>아래의 명령어를 입력하여 HAProxy 폴더를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/log/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/certs
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/errors/
</code></pre></div></div>
<p>HAProxy 설정 파일에 아래와 같이 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------------------------------------------------------------------</span>
<span class="c"># common defaults that all the 'listen' and 'backend' sections will</span>
<span class="c"># use if not designated in their block</span>
<span class="c">#---------------------------------------------------------------------</span>
defaults
    mode                    tcp
    log                     127.0.0.1 local0
    retries                 3
    <span class="nb">timeout </span>http-request    10s
    <span class="nb">timeout </span>queue           1m
    <span class="nb">timeout </span>connect         5s
    <span class="nb">timeout </span>client          5s
    <span class="nb">timeout </span>server          5s
    <span class="nb">timeout </span>http-keep-alive 10s
    <span class="nb">timeout </span>check           1s
    maxconn                 10000
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_master
    <span class="nb">bind</span> <span class="k">*</span>:8000
    default_backend bk_redis_master
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_master
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:master
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check

<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_slave
    <span class="nb">bind</span> <span class="k">*</span>:8001
    default_backend bk_redis_slave
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_slave
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:slave
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># admin uI</span>
<span class="c">#---------------------------------------------------------------------</span>
listen stats
 <span class="nb">bind</span> :80
 mode http
 balance roundrobin
 maxconn 10
 <span class="nb">timeout </span>client 5000
 <span class="nb">timeout </span>connect 4000
 <span class="nb">timeout </span>server 30000

 <span class="c"># Enable stats page</span>
 stats <span class="nb">enable</span>

 <span class="c"># Hide HAProxy version</span>
 stats hide-version

  <span class="c">#This is the virtual URL to access the stats page</span>
 stats uri /haproxy_stats

 <span class="c">#Authentication realm. This can be set to anything.</span>
 <span class="c">#Escape space characters with a backslash.</span>
 stats realm HAProxy<span class="se">\ </span>Statistics

 <span class="c">#The user/pass you want to use. Change this password!</span>
 stats auth admin:admin

 <span class="c">#This allows you to take down and bring up back end servers.</span>
 <span class="c">#This will produce an error on older versions of HAProxy.</span>
 stats admin <span class="k">if </span>TRUE
</code></pre></div></div>

<p>## HAProxy 실행
HAProxy를 서비스를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> systemctl daemon-reload
 systemctl <span class="nb">enable </span>haproxy
 systemctl start haproxy
</code></pre></div></div>

<h2 id="haproxy-ui-for-redis">HAProxy UI for redis</h2>
<p>HAProxy UI를 접속하기 위해 아래의 Url http://localhost/haproxy_stats 에 접속하면 Redis master와
slave의 상태를 확인할 수 있습니다.</p>

<p>![haproxy]](07-cache-haproxy.png)</p>

<h2 id="haproxy-연결-테스트">HAProxy 연결 테스트</h2>
<p>Redis master에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8000
localhost:8000&gt; <span class="nb">set </span>k1 v1
</code></pre></div></div>
<p>Redis slave에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8001
localhost:8001&gt; get k1
</code></pre></div></div>

<p>Redis master 를 강제로 종료시키고 HAProxy UI화면을 refresh하면 master/slave정보가 변경된 것을 확인할 수 있습니다.
redis-cli를 사용해 slave에 연결해서 계속해서 조회가 가능합니다.</p>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/22">5분 안에 구축하는 Redis-Sentinel + HAProxy</a>
<a href="https://engineeringcode.tistory.com/125">공학코드 연구노트</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - 레디스 모니터링 Redis Stat</title><link href="http://localhost:4000/cache/monitoring-redis-stat/" rel="alternate" type="text/html" title="Getting Start Redis - 레디스 모니터링 Redis Stat" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/monitoring-redis-stat</id><content type="html" xml:base="http://localhost:4000/cache/monitoring-redis-stat/"><![CDATA[<p>Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.</p>

<h2 id="redis-stat-설치">Redis Stat 설치</h2>
<p>Redis Stat는 ruby로 개발되어 있어서 Ruby가 설치되어 있어야 합니다. Ruby를 설치하기전에 의존성 패키지를 먼저 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ruby-devel gcc make rpm-build rubygems
<span class="c"># Ruby install</span>
git clone https://github.com/rbenv/rbenv-installer
<span class="nb">cd </span>rbenv-installer
<span class="nb">cd </span>bin
./rbenv-installer 
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/.rbenv/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'eval "$(rbenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc
rbenv <span class="nb">install </span>2.6.0
rbenv global 2.6.0
gem <span class="nb">install </span>redis-stat
</code></pre></div></div>
<p>redis-stat를 다음과 같이 실행합니다.</p>

<p>redis-stat 주소:포트번호 주소:포트번호 주소:포트번호  –verbose –daemon –server=8888</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-stat localhost:6300 localhost:6301 localhost:6302 localhost:6400 localhost:6401 localhost:6402 <span class="nt">--daemon</span> <span class="nt">--server</span><span class="o">=</span>8888
</code></pre></div></div>
<p>브라우저 Url 입력창에 http://localhost:8888 접속하여 Redis Stat UI console에 접속합니다.</p>

<p><img src="/assets/images/cache/12-cache-redis-stat-1.png" alt="Jupyter log" /></p>

<p><img src="/assets/images/cache/12-cache-redis-stat-2.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="redis-stat" /><summary type="html"><![CDATA[Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Sentinel 구성</title><link href="http://localhost:4000/cache/setup-sentinel-redis/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Sentinel 구성" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-sentinel-redis</id><content type="html" xml:base="http://localhost:4000/cache/setup-sentinel-redis/"><![CDATA[<h2 id="redis-sentinel-소개">Redis Sentinel 소개</h2>
<p>Redis Sentinel은 Redis의 고가용성 구성을 위한 아키텍처입니다. Sentinel은 Redis를 모니터링하고 master node가 장애가 발생시 알리고 자동으로 장애 조치할 수 있는 여러 Redis 인스턴스를 관리하기 위한 redis 컴포넌트입니다.</p>

<h2 id="redis-sentinel-역할">Redis Sentinel 역할</h2>
<p>Redis Sentinel은 Redis의 여러 인스턴스를 모니터링 및 관리하며 아래 3가지 역할을 수행하니다.</p>
<ul>
  <li>redis 인스턴스 모니터링 : Sentinel은 마스터 서버와 슬레이브 서버가 제대로 작동하는지 지속적으로 확인합니다.</li>
  <li>알림: 모니터링 중인 Redis 서버에 문제가 있는 경우 Sentinel은 API를 통해 관리자 또는 다른 응용 프로그램에 알림을 보낼 수 있습니다.</li>
  <li>자동장애조치 : 마스터 서버가 정상적으로 작동하지 않을 경우 Sentinel이 자동 장애 조치를 시작하여 장애가 발생한 마스터 서버의 슬레이브 서버 중 하나를 새 마스터 서버로 업그레이드하고 장애가 발생한 마스터 서버를 기타 슬레이브 서버는 대신 새 마스터 서버를 복사합니다. 클라이언트가 실패한 마스터 서버에 연결하려고 하면 클러스터도 새 마스터 서버의 주소를 클라이언트에 반환하여 클러스터가 새 마스터 서버를 사용하여 교체할 수 있도록 합니다</li>
</ul>

<h2 id="redis-sentinel-구성">Redis Sentinel 구성</h2>
<p>Redis를 다음의 <a href="https://yoonjk.github.io/cache/install-redis/">링크</a>를 참조하여 설치합니다.</p>

<p><img src="/assets/images/cache/14-cache-sentinel.png" alt="redis sentinel" /></p>

<p>Redis 를 HA 구성하는 방법은 몇가지 방법은 아래와 같이 구성할 수 있습니다. 첫번째 방법은 Master가 장애가 발생하면 서비스 장애가 발생하는 구성이지만 구성은 간단합니다. 두번째 방법 Sentinel 방법은 Redis Master가 장애가 발생하여도 slave가 master로 승격되어 지속적인 서비스가 가능합니다. 장애가 발생했던 master가 복귀되면 이전의 master는 slave 역할로 서비스를 합니다.
마지막 방법은 Redis 구성은 이전 방법보다는 복잡하지만 좀더 낳은 고가용성을 제공하면서 처리량을 높이는 방법입니다.<br />
이번 글에서는 Redis Sentinel을 구을해 봅니다.</p>

<ul>
  <li>Redis Master and Slave</li>
  <li>Redis Sentinel</li>
  <li>Redis Cluster</li>
</ul>

<h2 id="redis-환경설정">redis 환경설정</h2>
<p>redis sentinel을 구성하기 위해 redis master/slave 를 위한 환경설정을 합니다.</p>
<ul>
  <li>redis config 구성</li>
  <li>sentinel config 구성</li>
</ul>

<p>redis master config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf redis_6382.conf
vi redis_6382.conf

<span class="c"># 포트 설정</span>
port 각자포트
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
logfile logs/redis_6382.log
</code></pre></div></div>

<p>redis slave config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6382.conf redis_6383.conf 
<span class="nb">cp </span>redis_6382.conf redis_6384.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6383/g'</span> redis_6383.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6384/g'</span> redis_6384.conf 

<span class="c"># slave1</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf

<span class="c"># slave2</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
</code></pre></div></div>

<h4 id="redis-sentinel-config-구성">redis sentinel config 구성</h4>
<p>redis sentinel config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>sentinel.conf redis_5000.conf
vi redis_5000.conf

<span class="c"># 포트 설정</span>
port 5000
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
<span class="nb">dir</span> <span class="s2">"./"</span>
logfile <span class="s2">"logs/redis_5000.log"</span>
<span class="c"># 감시할 마스터 정보 및 쿼럼(quorum) 설정</span>
sentinel monitor mymaster 127.0.0.1 6382 2
<span class="c"># 다운 되었다고 인지하는 시간 (3초)</span>
- 마스터 서버에 정기적으로 PING을 보내는데, 이 시간 동안 응답이 없으면 다운된 것으로 판단하고 장애조치<span class="o">(</span>failover<span class="o">)</span> 작업을 시작합니다
sentinel down-after-milliseconds mymaster 3000
sentinel failover-timeout mymaster 3000
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_5000.conf redis_5001.conf
<span class="nb">cp </span>redis_5000.conf redis_5002.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5001/g'</span> redis_5001.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5002/g'</span> redis_5002.conf 
</code></pre></div></div>

<h2 id="redis-실행">redis 실행</h2>
<p>Redis 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis_6382.conf
src/redis-server redis_6383.conf
src/redis-server redis_6384.conf
</code></pre></div></div>

<p>Redis Sentinel 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-sentinel redis_5000.conf
src/redis-sentinel redis_5001.conf
src/redis-sentinel redis_5002.conf
</code></pre></div></div>

<h2 id="redis-failover-테스트">redis failover 테스트</h2>
<p>redis master를 강제 종료시 slave가 master로 승격되는 확인하기 위해, sentinel 서버의 로그를 모니터링 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tail</span> <span class="nt">-f</span> logs/redis_5000.log
</code></pre></div></div>
<p>redis master process를 확인하고 서버를 강제로 종료합니다.<br />
그러면 sentinel에서 자동으로 redis slave를 master로 승격하는 것을 확인 할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis

<span class="c"># redis master pid를 확인</span>
<span class="nb">kill</span> <span class="nt">-9</span> redis_master_pid
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/15">5분 안에 구축하는 Redis-Sentinel</a>
<a href="https://www.happykoo.net/@happykoo/posts/53">해피쿠</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 소개 Redis Sentinel은 Redis의 고가용성 구성을 위한 아키텍처입니다. Sentinel은 Redis를 모니터링하고 master node가 장애가 발생시 알리고 자동으로 장애 조치할 수 있는 여러 Redis 인스턴스를 관리하기 위한 redis 컴포넌트입니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis 설치(Centos)</title><link href="http://localhost:4000/cache/install-redis/" rel="alternate" type="text/html" title="Getting Start Redis - Redis 설치(Centos)" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/install%20redis</id><content type="html" xml:base="http://localhost:4000/cache/install-redis/"><![CDATA[<h2 id="redis-설치-준비">Redis 설치 준비</h2>
<p>Redis를 다음의 절차로 설치합니다.</p>
<ul>
  <li>OS 업데이트</li>
  <li>Development Tools 설치</li>
  <li>redis download</li>
  <li>redis build</li>
  <li>redis install</li>
</ul>

<p>Centos7 OS 버전을 최신으로 업그레이드 하고, Development Tools를 설치합니다. Redis <a href="http://download.redis.io/releases/">download</a> site 에 가서 원하는 redis 를 확인하고 address link를 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum update <span class="nt">-y</span>
yum groupinstall <span class="s1">'Development Tools'</span>
<span class="nb">sudo </span>wget http://download.redis.io/releases/redis-7.0.10.tar.gz
<span class="nb">tar </span>xvzf redis-7.0.10.tar.gz
<span class="nb">cd </span>redis-7.0.10
</code></pre></div></div>
<p>Redis 압축파일을 해제한 후 make 명령어를 수행하면 아래처럼 jemalloc No such file or directory 오류가 발생합니다.
이를 해결하기 위해서는 deps 폴더에서 compile을 해야합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>deps
make hiredis jemalloc linenoise lua
<span class="nb">cd</span> ..
</code></pre></div></div>
<p>Redis 압축 해제했던 폴더로 되돌아와서 다시 build합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-7.0.10</span>
make
make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="redis-서버-실행">Redis 서버 실행</h2>
<p>redis 를 install 후 redis 서버를 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis.conf
</code></pre></div></div>

<p>redis를 접속하기 위해 terminal을 1개 열어 redis가 설치된 서버에 접속합니다.
src 폴더에 있는 redis-cli를 이용하여 redis 서버에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli
<span class="nb">set </span>k1 v1
get k1
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://mozi.tistory.com/536">꽁담</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis 설치 준비 Redis를 다음의 절차로 설치합니다. OS 업데이트 Development Tools 설치 redis download redis build redis install]]></summary></entry></feed>