<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-15T14:20:44+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">Getting Start Redis - Docker를 이용한 클러스터링 구성</title><link href="http://localhost:4000/cache/redis-cluster-using-docker/" rel="alternate" type="text/html" title="Getting Start Redis - Docker를 이용한 클러스터링 구성" /><published>2023-04-12T00:00:00+09:00</published><updated>2023-04-12T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster-using-docker</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster-using-docker/"><![CDATA[<h2 id="redisconf-편집">redis.conf 편집</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> 6300 6301 6302 6400 6401 6402
</code></pre></div></div>
<p>redis config 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## redis.conf 편집</span>
vi redis.conf
port 6379
cluster-enabled <span class="nb">yes
</span>cluster-config-file nodes.conf
cluster-node-timeout 3000
appendonly <span class="nb">yes</span>
</code></pre></div></div>
<p>redis.conf를 각 폴더에 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf 6300/
<span class="nb">cp </span>redis.conf 6301/
<span class="nb">cp </span>redis.conf 6302/
<span class="nb">cp </span>redis.conf 6400/
<span class="nb">cp </span>redis.conf 6401/
<span class="nb">cp </span>redis.conf 6402/
</code></pre></div></div>

<p>redis.conf를 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6300/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6301/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6302/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6400/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6401/g'</span> 6300/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6379/6402/g'</span> 6300/redis.conf
</code></pre></div></div>

<h2 id="master-redis-작성">Master Redis 작성</h2>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis1</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis1</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis1</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./6300/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">6300:6300</span>
    <span class="pi">-</span> <span class="s">16300:16300</span>

  <span class="na">redis2</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis2</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis2</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6301/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6301:6301</span>
      <span class="pi">-</span> <span class="s">16301:16301</span>

  <span class="na">redis3</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis3</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis3</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6302/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6302:6302</span>
      <span class="pi">-</span> <span class="s">16302:16302</span>

  <span class="na">redis4</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis4</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis4</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6400/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6400:6400</span>
      <span class="pi">-</span> <span class="s">16400:16400</span>

  <span class="na">redis5</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis5</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis5</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6401/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6401:6401</span>
      <span class="pi">-</span> <span class="s">16401:16401</span>

  <span class="na">redis6</span><span class="pi">:</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">redis6</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis6</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">network_mode</span><span class="pi">:</span> <span class="s2">"</span><span class="s">host"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server /etc/redis.conf</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./6402/redis.conf:/etc/redis.conf</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">6402:6402</span>
      <span class="pi">-</span> <span class="s">16402:16402</span>
</code></pre></div></div>
<h2 id="redis-cluster-시작">Redis cluster 시작</h2>
<p>docker-compose 이용하여 Redis Cluster를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
docker ps
</code></pre></div></div>

<h4 id="클러스터-구성">클러스터 구성</h4>
<p>6개의 docker container redis가 실행중인 것을 확인하고 redis1에 접속하여 다음과 같이 클러스터를 구성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> redis1 bash
redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
<span class="nb">exit</span>
</code></pre></div></div>
<p>redis1 container의 로그를 다음과 같이 확인합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs -f redis1
</code></pre></div></div>
<h4 id="replicas-구성">Replicas 구성</h4>
<p>Redis Master에 각각 1개의 Replica를 추가합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># master1에 replica 1 추가</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> redis1 bash
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>

<span class="c"># master2에 replica 2 추가</span>
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>

<span class="c"># master3에 replica 3 추가</span>
redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<p><img src="/assets/images/cache/13-cache-add-slave-docker.png" alt="Create Admin" /></p>
<h2 id="참고">참고</h2>
<p><a href="https://uchupura.tistory.com/56">우쭈뿌라 개발노트</a><br />
<a href="https://pinggoopark.tistory.com/268">과거의 나를 위해</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="docker" /><summary type="html"><![CDATA[redis.conf 편집]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Cluster Failover 설정</title><link href="http://localhost:4000/cache/failover-redis-cluster/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Cluster Failover 설정" /><published>2023-04-12T00:00:00+09:00</published><updated>2023-04-12T00:00:00+09:00</updated><id>http://localhost:4000/cache/failover-redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/failover-redis-cluster/"><![CDATA[<h2 id="redis-cluster-configuration-설정">Redis Cluster Configuration 설정</h2>
<p>Redis Cluster를 구성하고 failover 하기 위해서는 application config 이외에 추가적으로  Redis cluster Confugration이 필요합니다.
Redis Cluster를 구성하고 Master를 강제로 종료시키면 Replica중 1개가 Master로 승격되어 지속적인 서비스를 이어갈 수 있습니다.<br />
그리고 Lettuce를 사용하면 이를 자동으로 감지하여 서비스를 지속할 수 있습니다. 
그러나 쓰기작업이 필요한 서비스는 약간의 delay를 요구하며, Redis Cluster 상태가 refresh되면 정상적인 쓰기 작업이 가능해집니다.
물론 일기작업은 다음의 설정으로 변함없이 지속적으로 서비스가 가능합니다.</p>
<h4 id="지속적인-읽기-작업">지속적인 읽기 작업</h4>
<p>Replica중 1개 또는 모두 종료되더라도 지속적으로 일기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.</p>

<p><strong>REPLICA_PREFERRED</strong></p>

<h4 id="지속적인-쓰기-작업">지속적인 쓰기 작업</h4>
<p>Redis Cluster Master중 1개가 종료되더라도 지속적으로 쓰기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.
아래의 설정값이 default 값이 false로 되어 있기 때문에 true로 설정을 변경해야 master가 종료되고 replica중 1개가 master로 승격되어 서비스를 계속할 수 있게되고, 이를 Lettuce가 감지하여 애플리케이션에서도 서비스를 지속하기 위해 아래의 설정을 하여야 합니다.</p>

<p><strong>enablePeriodicRefresh</strong></p>

<p>그리고 Refresh time을 설정하여 Lettuce가 이를 빠르게 감지하도록 설정합니다.
<strong>refreshPeriod</strong></p>

<p>다음의 코드는 Redis Cluster를 구성하고 replica가 종료되거나 cluster의 master가 종료되더라도 읽기 작업과 쓰기 작업을 지속할 수 있도록 하기 위한 설정정보입니다.</p>

<p>전체 소스는 아래의 <a href="https://github.com/yoonjk/redis-cluster.git">github 링크</a>에 있습니다.
<a href="https://github.com/yoonjk/redis-cluster.git">https://github.com/yoonjk/redis-cluster.git</a></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.time.Duration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.RedisClusterConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.RedisConnectionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">io.lettuce.core.ReadFrom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.lettuce.core.cluster.ClusterClientOptions</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.lettuce.core.cluster.ClusterTopologyRefreshOptions</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="o">{</span>
	<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.cluster.nodes}"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clusterNodes</span><span class="o">;</span>
    <span class="c1">// lettuce 사용시</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisConnectionFactory</span> <span class="nf">redisConnectionFactory</span><span class="o">(){</span>
        <span class="nc">LettuceClientConfiguration</span> <span class="n">clientConfiguration</span> <span class="o">=</span> <span class="nc">LettuceClientConfiguration</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        		<span class="o">.</span><span class="na">clientOptions</span><span class="o">(</span><span class="nc">ClusterClientOptions</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        				<span class="o">.</span><span class="na">topologyRefreshOptions</span><span class="o">(</span><span class="nc">ClusterTopologyRefreshOptions</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        						<span class="o">.</span><span class="na">refreshPeriod</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
        						<span class="o">.</span><span class="na">enableAdaptiveRefreshTrigger</span><span class="o">()</span>
        						<span class="o">.</span><span class="na">enablePeriodicRefresh</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>    <span class="c1">// Default 가 False</span>
        						<span class="o">.</span><span class="na">build</span><span class="o">())</span>
        				<span class="o">.</span><span class="na">build</span><span class="o">())</span>
        		
                <span class="o">.</span><span class="na">readFrom</span><span class="o">(</span><span class="nc">ReadFrom</span><span class="o">.</span><span class="na">REPLICA_PREFERRED</span><span class="o">)</span> <span class="c1">// 복제본 노드에서 읽지 만 사용할 수없는 경우 마스터에서 읽습니다.</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
        

        <span class="c1">// 모든 클러스터(master, slave) 정보를 적는다. (해당 서버중 접속되는 서버에서 cluster nodes 명령어를 통해 모든 클러스터 정보를 읽어오기에 다운 됐을 경우를 대비하여 모든 노드 정보를 적어두는편이 좋다.)</span>
        <span class="nc">RedisClusterConfiguration</span> <span class="n">redisClusterConfiguration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisClusterConfiguration</span><span class="o">(</span><span class="n">clusterNodes</span><span class="o">);</span>
        
        <span class="nc">LettuceConnectionFactory</span> <span class="n">lettuceConnectionFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LettuceConnectionFactory</span><span class="o">(</span><span class="n">redisClusterConfiguration</span><span class="o">,</span> <span class="n">clientConfiguration</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">lettuceConnectionFactory</span><span class="o">;</span>
    <span class="o">}</span>
        
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis Cluster Configuration 설정 Redis Cluster를 구성하고 failover 하기 위해서는 application config 이외에 추가적으로 Redis cluster Confugration이 필요합니다. Redis Cluster를 구성하고 Master를 강제로 종료시키면 Replica중 1개가 Master로 승격되어 지속적인 서비스를 이어갈 수 있습니다. 그리고 Lettuce를 사용하면 이를 자동으로 감지하여 서비스를 지속할 수 있습니다. 그러나 쓰기작업이 필요한 서비스는 약간의 delay를 요구하며, Redis Cluster 상태가 refresh되면 정상적인 쓰기 작업이 가능해집니다. 물론 일기작업은 다음의 설정으로 변함없이 지속적으로 서비스가 가능합니다. 지속적인 읽기 작업 Replica중 1개 또는 모두 종료되더라도 지속적으로 일기 서비스가 가능하도록 하기 위해서는 다음의 설정이 필요합니다.]]></summary></entry><entry><title type="html">@Inject과 @Autowired의 차이점</title><link href="http://localhost:4000/springboot/difference-autowired-inject/" rel="alternate" type="text/html" title="@Inject과 @Autowired의 차이점" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T00:00:00+09:00</updated><id>http://localhost:4000/springboot/difference-autowired-inject</id><content type="html" xml:base="http://localhost:4000/springboot/difference-autowired-inject/"><![CDATA[<h2 id="inject-vs-autowired">@Inject vs @Autowired</h2>
<p>@Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다.
@Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.</p>

<table>
  <thead>
    <tr>
      <th>Sr. No.	Key</th>
      <th>@Inject</th>
      <th>@Autowired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1	Basic</td>
      <td>그것은 자바 CDI의 일부입니다</td>
      <td>스프링 프레임 워크의 일부입니다.</td>
    </tr>
    <tr>
      <td>2	Required</td>
      <td>required 속성이 없습니다.</td>
      <td>required속성이 있습니다.</td>
    </tr>
    <tr>
      <td>3	Default Scope	autowire</td>
      <td>기본 범위는 싱글톤입니다.</td>
      <td>주입 빈의 기본 범위는 prototype입니다.</td>
    </tr>
    <tr>
      <td>4	Ambiguity</td>
      <td>주입을 위해 빈에 모호성이있는 경우 코드에 @Named해야합니다</td>
      <td>주입을 위해 Bean에 모호한 경우 코드에 @Qualifer 추가해야합니다.</td>
    </tr>
    <tr>
      <td>5	Advantage</td>
      <td>Java CDI의 일부이므로 DI 프레임워크에 의존하지 않습니다.</td>
      <td>시스템을 느슨하게 결합합니다.</td>
    </tr>
  </tbody>
</table>

<p>응용 프로그램을 Spring 프레임워크와 밀접하게 결합시킵니다. 나중에 다른 DI 프레임워크로 이동하려면 응용 프로그램을 다시 구성해야합니다.</p>

<p>@Injection 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InjectionExample</span> <span class="o">{</span>
   <span class="nd">@Inject</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@Autowired 어노테이션 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AutowiredExample</span> <span class="o">{</span>
   <span class="nd">@Autowired</span>
   <span class="kd">private</span> <span class="nc">CarBean</span> <span class="n">carbean</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="springboot" /><summary type="html"><![CDATA[@Inject vs @Autowired @Inject 및 @Autowired 두 주석은 응용 프로그램에서 자동 의존성주입에 사용됩니다. @Inject 어노테이션은 Java 6에 도입 된 Java CDI의 일부인 반면 @Autowire 어노테이션은 스프링프레임워크의 일부. 두 어노테이션 모두 동일한 목적을 수행하므로 응용프로그램에서 사용할 수 있는 어노테이션.]]></summary></entry><entry><title type="html">Getting Start Redis - 레디스 모니터링 Redis Stat</title><link href="http://localhost:4000/cache/monitoring-redis-stat/" rel="alternate" type="text/html" title="Getting Start Redis - 레디스 모니터링 Redis Stat" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/monitoring-redis-stat</id><content type="html" xml:base="http://localhost:4000/cache/monitoring-redis-stat/"><![CDATA[<p>Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.</p>

<h2 id="redis-stat-설치">Redis Stat 설치</h2>
<p>Redis Stat는 ruby로 개발되어 있어서 Ruby가 설치되어 있어야 합니다. Ruby를 설치하기전에 의존성 패키지를 먼저 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ruby-devel gcc make rpm-build rubygems
<span class="c"># Ruby install</span>
git clone https://github.com/rbenv/rbenv-installer
<span class="nb">cd </span>rbenv-installer
<span class="nb">cd </span>bin
./rbenv-installer 
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/.rbenv/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'eval "$(rbenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc
rbenv <span class="nb">install </span>2.6.0
rbenv global 2.6.0
gem <span class="nb">install </span>redis-stat
</code></pre></div></div>
<p>redis-stat를 다음과 같이 실행합니다.</p>

<p>redis-stat 주소:포트번호 주소:포트번호 주소:포트번호  –verbose –daemon –server=8888</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-stat localhost:6300 localhost:6301 localhost:6302 localhost:6400 localhost:6401 localhost:6402 <span class="nt">--daemon</span> <span class="nt">--server</span><span class="o">=</span>8888
</code></pre></div></div>
<p>브라우저 Url 입력창에 http://localhost:8888 접속하여 Redis Stat UI console에 접속합니다.</p>

<p><img src="/assets/images/cache/12-cache-redis-stat-1.png" alt="Jupyter log" /></p>

<p><img src="/assets/images/cache/12-cache-redis-stat-2.png" alt="Jupyter log" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="redis-stat" /><summary type="html"><![CDATA[Redis 서버의 메모리 사용량을 모니터링하고자 하는 경우 오픈소스 Redis Stat를 사용할 수 있습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Sentinel &amp;amp; HAProxy</title><link href="http://localhost:4000/cache/haproxy/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Sentinel &amp;amp; HAProxy" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/haproxy</id><content type="html" xml:base="http://localhost:4000/cache/haproxy/"><![CDATA[<p>Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.</p>

<h2 id="haproxy-환경-구성">Haproxy 환경 구성</h2>

<h4 id="haproxy-설치를-위한-의존성-패키지-설치">HAProxy 설치를 위한 의존성 패키지 설치</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># HAProxy 설치를 위한 의존성 패키지 설치</span>
yum <span class="nb">install</span> <span class="nt">-y</span> gcc openssl openssl-devel pcre-static pcre-devel systemd-devel
</code></pre></div></div>

<h4 id="haproxy-설치">Haproxy 설치</h4>
<p>haproxy를 구성하기 위해 haproxy 최근 버전을 <a href="http://www.haproxy.org/download/2.8/src/devel/">download</a>하여 build 및 install합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://www.haproxy.org/download/2.8/src/devel/haproxy-2.8-dev7.tar.gz
<span class="nb">tar </span>xvzf haproxy-2.8-dev7.tar.gz
<span class="nb">cd </span>haproxy-2.8-dev7 
make <span class="nv">TARGET</span><span class="o">=</span>linux-glibc <span class="nv">USE_OPENSSL</span><span class="o">=</span>1 <span class="nv">USE_PCRE</span><span class="o">=</span>1 <span class="nv">USE_ZLIB</span><span class="o">=</span>1 <span class="nv">USE_SYSTEMD</span><span class="o">=</span>1

<span class="c">## Install haproxy</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>아래의 명령어를 입력하여 설치된 HAProxy 버전을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/sbin/haproxy <span class="nt">-v</span>
</code></pre></div></div>
<p>OS가 reboot되어도 재시작하도록 service 파일을 작서합니다. 아래의 명령어를 입력하여 HAProxy 서비스 예제 파일을 다운로드합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"http://git.haproxy.org/?p=haproxy-2.3.git;a=blob_plain;f=contrib/systemd/haproxy.service.in"</span> <span class="nt">-o</span> /etc/systemd/system/haproxy.service

<span class="c"># 서비스파일 편집</span>
vi /etc/systemd/system/haproxy.service
</code></pre></div></div>
<p>아래와 같이 서비스 파일에서 아래의 3개의 내용을 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
</code></pre></div></div>

<p>서비프파일 전체 내용</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>HAProxy Load Balancer
<span class="nv">After</span><span class="o">=</span>network-online.target
<span class="nv">Wants</span><span class="o">=</span>network-online.target

<span class="o">[</span>Service]
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/default/haproxy
<span class="nv">EnvironmentFile</span><span class="o">=</span>-/etc/sysconfig/haproxy
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"CONFIG=/etc/haproxy/haproxy.cfg"</span> <span class="s2">"PIDFILE=/run/haproxy.pid"</span> <span class="s2">"EXTRAOPTS=-S /run/haproxy-master.sock"</span>
<span class="nv">ExecStartPre</span><span class="o">=</span>/usr/local/sbin/haproxy  <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-Ws</span> <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-p</span> /run/haproxy.pid <span class="nt">-S</span> /run/haproxy-master.sock
<span class="nv">ExecReload</span><span class="o">=</span>/usr/local/sbin/haproxy <span class="nt">-f</span> /etc/haproxy/haproxy.cfg <span class="nt">-c</span> <span class="nt">-q</span> <span class="nt">-S</span> /run/haproxy-master.soc용
<span class="nv">ExecReload</span><span class="o">=</span>/bin/kill <span class="nt">-USR2</span> <span class="nv">$MAINPID</span>
<span class="nv">KillMode</span><span class="o">=</span>mixed
<span class="nv">Restart</span><span class="o">=</span>always
<span class="nv">SuccessExitStatus</span><span class="o">=</span>143
<span class="nv">Type</span><span class="o">=</span>notify

<span class="c"># The following lines leverage SystemD's sandboxing options to provide</span>
<span class="c"># defense in depth protection at the expense of restricting some flexibility</span>
<span class="c"># in your setup (e.g. placement of your configuration files) or possibly</span>
<span class="c"># reduced performance. See systemd.service(5) and systemd.exec(5) for further</span>
<span class="c"># information.</span>

<span class="c"># NoNewPrivileges=true</span>
<span class="c"># ProtectHome=true</span>
<span class="c"># If you want to use 'ProtectSystem=strict' you should whitelist the PIDFILE,</span>
<span class="c"># any state files and any other files written using 'ReadWritePaths' or</span>
<span class="c"># 'RuntimeDirectory'.</span>
<span class="c"># ProtectSystem=true</span>
<span class="c"># ProtectKernelTunables=true</span>
<span class="c"># ProtectKernelModules=true</span>
<span class="c"># ProtectControlGroups=true</span>
<span class="c"># If your SystemD version supports them, you can add: @reboot, @swap, @sync</span>
<span class="c"># SystemCallFilter=~@cpu-emulation @keyring @module @obsolete @raw-io</span>

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div></div>
<h2 id="haproxy-설정파일-수정">haproxy 설정파일 수정</h2>
<p>아래의 명령어를 입력하여 HAProxy 폴더를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/log/haproxy
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/certs
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/haproxy/errors/
</code></pre></div></div>
<p>HAProxy 설정 파일에 아래와 같이 편집합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------------------------------------------------------------------</span>
<span class="c"># common defaults that all the 'listen' and 'backend' sections will</span>
<span class="c"># use if not designated in their block</span>
<span class="c">#---------------------------------------------------------------------</span>
defaults
    mode                    tcp
    log                     127.0.0.1 local0
    retries                 3
    <span class="nb">timeout </span>http-request    10s
    <span class="nb">timeout </span>queue           1m
    <span class="nb">timeout </span>connect         5s
    <span class="nb">timeout </span>client          5s
    <span class="nb">timeout </span>server          5s
    <span class="nb">timeout </span>http-keep-alive 10s
    <span class="nb">timeout </span>check           1s
    maxconn                 10000
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_master
    <span class="nb">bind</span> <span class="k">*</span>:8000
    default_backend bk_redis_master
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_master
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:master
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check

<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># main frontend which proxys to the backends</span>
<span class="c">#---------------------------------------------------------------------</span>
frontend ft_redis_slave
    <span class="nb">bind</span> <span class="k">*</span>:8001
    default_backend bk_redis_slave
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># round robin balancing between the various backends</span>
<span class="c">#---------------------------------------------------------------------</span>
backend bk_redis_slave
    balance roundrobin
    log global
    option tcp-check
    tcp-check send info<span class="se">\ </span>replication<span class="se">\r\n</span>
    tcp-check expect string role:slave
    server tcpapp1 localhost:6382 check
    server tcpapp2 localhost:6383 check
    server tcpapp3 localhost:6384 check
<span class="c">#---------------------------------------------------------------------</span>
<span class="c"># admin uI</span>
<span class="c">#---------------------------------------------------------------------</span>
listen stats
 <span class="nb">bind</span> :80
 mode http
 balance roundrobin
 maxconn 10
 <span class="nb">timeout </span>client 5000
 <span class="nb">timeout </span>connect 4000
 <span class="nb">timeout </span>server 30000

 <span class="c"># Enable stats page</span>
 stats <span class="nb">enable</span>

 <span class="c"># Hide HAProxy version</span>
 stats hide-version

  <span class="c">#This is the virtual URL to access the stats page</span>
 stats uri /haproxy_stats

 <span class="c">#Authentication realm. This can be set to anything.</span>
 <span class="c">#Escape space characters with a backslash.</span>
 stats realm HAProxy<span class="se">\ </span>Statistics

 <span class="c">#The user/pass you want to use. Change this password!</span>
 stats auth admin:admin

 <span class="c">#This allows you to take down and bring up back end servers.</span>
 <span class="c">#This will produce an error on older versions of HAProxy.</span>
 stats admin <span class="k">if </span>TRUE
</code></pre></div></div>

<p>## HAProxy 실행
HAProxy를 서비스를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> systemctl daemon-reload
 systemctl <span class="nb">enable </span>haproxy
 systemctl start haproxy
</code></pre></div></div>

<h2 id="haproxy-ui-for-redis">HAProxy UI for redis</h2>
<p>HAProxy UI를 접속하기 위해 아래의 Url http://localhost/haproxy_stats 에 접속하면 Redis master와
slave의 상태를 확인할 수 있습니다.</p>

<p>![haproxy]](07-cache-haproxy.png)</p>

<h2 id="haproxy-연결-테스트">HAProxy 연결 테스트</h2>
<p>Redis master에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8000
localhost:8000&gt; <span class="nb">set </span>k1 v1
</code></pre></div></div>
<p>Redis slave에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redis</span><span class="nt">-cli</span> <span class="nt">-h</span> localhost <span class="nt">-p</span> 8001
localhost:8001&gt; get k1
</code></pre></div></div>

<p>Redis master 를 강제로 종료시키고 HAProxy UI화면을 refresh하면 master/slave정보가 변경된 것을 확인할 수 있습니다.
redis-cli를 사용해 slave에 연결해서 계속해서 조회가 가능합니다.</p>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/22">5분 안에 구축하는 Redis-Sentinel + HAProxy</a>
<a href="https://engineeringcode.tistory.com/125">공학코드 연구노트</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Sentinel을 구성하고, slave의 loadbalance를 위해 haproxy를 구성합니다. haproxy의 UI화면에서 redis의 master/slave의 active/deactive를 상태를 한눈에 파악하기 쉽습니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Cluster</title><link href="http://localhost:4000/cache/redis-cluster/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Cluster" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T00:00:00+09:00</updated><id>http://localhost:4000/cache/redis-cluster</id><content type="html" xml:base="http://localhost:4000/cache/redis-cluster/"><![CDATA[<h2 id="redis-cluster-환경구성">Redis Cluster 환경구성</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port <span class="o">[</span>각자포트]
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-[각자포트].conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_[각자포트].aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_[각자포트].pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_[각자포트].log
</code></pre></div></div>
<p>redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-server 6300</span>
<span class="nb">cp </span>redis.conf redis_6300.conf
vi redis_6300.conf
</code></pre></div></div>
<p>redis_6300.conf 파일을 다음과 같이 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port 6300
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># 클러스터를 사용하겠다.</span>
cluster-enabled <span class="nb">yes</span> 
<span class="c"># 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨)</span>
cluster-config-file nodes-6300.conf 
<span class="c"># 클러스터 노드가 다운되었는지 판단하는 시간 (3s)</span>
cluster-node-timeout 3000 
<span class="c"># Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항)</span>
appendonly <span class="nb">yes</span> 
<span class="c"># append only yes 시 해당 부분도 수정</span>
appendfilename appendonly_6300.aof 
<span class="c"># 프로세스 아이디 저장 경로 설정</span>
pidfile /var/run/redis_6300.pid
<span class="c"># 로그 파일 저장 경로 지정</span>
logfile logs/redis_6300.log
</code></pre></div></div>
<p>나머지 redis server의 환경파일을 복사하고 수정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6300.conf redis_6301.conf
<span class="nb">cp </span>redis_6300.conf redis_6302.conf
<span class="nb">cp </span>redis_6300.conf redis_6400.conf
<span class="nb">cp </span>redis_6300.conf redis_6401.conf
<span class="nb">cp </span>redis_6300.conf redis_6402.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6301/g'</span> redis_6301.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6302/g'</span> redis_6302.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6400/g'</span> redis_6400.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6401/g'</span> redis_6401.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6300/6402/g'</span> redis_6402.conf
</code></pre></div></div>

<h2 id="redis-cluster-실행">Redis Cluster 실행</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./src/redis-server redis_6300.conf
./src/redis-server redis_6301.conf
./src/redis-server redis_6302.conf
./src/redis-server redis_6400.conf
./src/redis-server redis_6401.conf
./src/redis-server redis_6402.conf

redis-cli <span class="nt">--cluster</span> create 127.0.0.1:6300 127.0.0.1:6301 127.0.0.1:6302
</code></pre></div></div>
<h4 id="redis-cluster-실행로그">redis cluster 실행로그</h4>
<p><img src="/assets/images/cache/08-cache-create-redis-cluster.png" alt="Jupyter log" /></p>

<h4 id="master-노드-로그">Master 노드 로그</h4>
<p><img src="/assets/images/cache/09-cache-log-redis-cluster.png" alt="Jupyter log" /></p>

<h2 id="slave1-등록">Slave1 등록</h2>
<p>Master1(6300)에 Slave1(6400) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6400 127.0.0.1:6300 <span class="nt">--cluster-slave</span>
</code></pre></div></div>
<h4 id="slave-등록-로그">Slave 등록 로그</h4>
<p><img src="/assets/images/cache/10-cache-add-slave-node.png" alt="Jupyter log" /></p>

<h4 id="master-로그">Master 로그</h4>
<p><img src="/assets/images/cache/11-cache-log-redis-master.png" alt="Jupyter log" /></p>

<h4 id="slave2-등록">Slave2 등록</h4>
<p>Master2(6301)에 Slave1(6401) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6401 127.0.0.1:6301 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h4 id="slave3-등록">Slave3 등록</h4>
<p>Master3(6302)에 Slave1(6402) node를 추가합니다</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> add-node 127.0.0.1:6402 127.0.0.1:6302 <span class="nt">--cluster-slave</span>
</code></pre></div></div>

<h2 id="클러스터-정보확인">클러스터 정보확인</h2>
<p>redis 클러스터 정보를 다음과 같이 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--cluster</span> info 127.0.0.1:6300
</code></pre></div></div>
<h4 id="redis-cluster-failover">Redis Cluster Failover</h4>
<p>Redis Master를 강제로 종료했을 떄 어떻게 failover되는지 확인하기 위해 master1(6300)을 강제로 종료하여 redis stat로 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis
<span class="nb">kill</span> <span class="nt">-9</span> pid
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="haproxy" /><summary type="html"><![CDATA[Redis Cluster 환경구성 port [각자포트] # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-[각자포트].conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_[각자포트].aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_[각자포트].pid # 로그 파일 저장 경로 지정 logfile logs/redis_[각자포트].log redis.conf 파일을 각 서버의 포트별로 파일을 작성합니다. # redis-server 6300 cp redis.conf redis_6300.conf vi redis_6300.conf redis_6300.conf 파일을 다음과 같이 수정합니다. port 6300 # 백그라운드에서 시작하도록 설정 daemonize yes # 클러스터를 사용하겠다. cluster-enabled yes # 클러스터 구성 내용을 저장한는 파일명 지정 (자동 생성됨) cluster-config-file nodes-6300.conf # 클러스터 노드가 다운되었는지 판단하는 시간 (3s) cluster-node-timeout 3000 # Appendonly를 yes로 설정하면 rdb에 저장 안되고 aof에 저장됨 (각각 장단점이 있으니 해당 부분은 선택 사항) appendonly yes # append only yes 시 해당 부분도 수정 appendfilename appendonly_6300.aof # 프로세스 아이디 저장 경로 설정 pidfile /var/run/redis_6300.pid # 로그 파일 저장 경로 지정 logfile logs/redis_6300.log 나머지 redis server의 환경파일을 복사하고 수정합니다. ```bash cp redis_6300.conf redis_6301.conf cp redis_6300.conf redis_6302.conf cp redis_6300.conf redis_6400.conf cp redis_6300.conf redis_6401.conf cp redis_6300.conf redis_6402.conf]]></summary></entry><entry><title type="html">Getting Start Redis - Redis 설치(Centos)</title><link href="http://localhost:4000/cache/install-redis/" rel="alternate" type="text/html" title="Getting Start Redis - Redis 설치(Centos)" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/install%20redis</id><content type="html" xml:base="http://localhost:4000/cache/install-redis/"><![CDATA[<h2 id="redis-설치-준비">Redis 설치 준비</h2>
<p>Redis를 다음의 절차로 설치합니다.</p>
<ul>
  <li>OS 업데이트</li>
  <li>Development Tools 설치</li>
  <li>redis download</li>
  <li>redis build</li>
  <li>redis install</li>
</ul>

<p>Centos7 OS 버전을 최신으로 업그레이드 하고, Development Tools를 설치합니다. Redis <a href="http://download.redis.io/releases/">download</a> site 에 가서 원하는 redis 를 확인하고 address link를 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum update <span class="nt">-y</span>
yum groupinstall <span class="s1">'Development Tools'</span>
<span class="nb">sudo </span>wget http://download.redis.io/releases/redis-7.0.10.tar.gz
<span class="nb">tar </span>xvzf redis-7.0.10.tar.gz
<span class="nb">cd </span>redis-7.0.10
</code></pre></div></div>
<p>Redis 압축파일을 해제한 후 make 명령어를 수행하면 아래처럼 jemalloc No such file or directory 오류가 발생합니다.
이를 해결하기 위해서는 deps 폴더에서 compile을 해야합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>deps
make hiredis jemalloc linenoise lua
<span class="nb">cd</span> ..
</code></pre></div></div>
<p>Redis 압축 해제했던 폴더로 되돌아와서 다시 build합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis-7.0.10</span>
make
make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="redis-서버-실행">Redis 서버 실행</h2>
<p>redis 를 install 후 redis 서버를 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis.conf
</code></pre></div></div>

<p>redis를 접속하기 위해 terminal을 1개 열어 redis가 설치된 서버에 접속합니다.
src 폴더에 있는 redis-cli를 이용하여 redis 서버에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli
<span class="nb">set </span>k1 v1
get k1
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://mozi.tistory.com/536">꽁담</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[Redis 설치 준비 Redis를 다음의 절차로 설치합니다. OS 업데이트 Development Tools 설치 redis download redis build redis install]]></summary></entry><entry><title type="html">Getting Start Redis - Redis Sentinel 구성</title><link href="http://localhost:4000/cache/setup-sentinel-redis/" rel="alternate" type="text/html" title="Getting Start Redis - Redis Sentinel 구성" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T00:00:00+09:00</updated><id>http://localhost:4000/cache/setup-sentinel-redis</id><content type="html" xml:base="http://localhost:4000/cache/setup-sentinel-redis/"><![CDATA[<h2 id="redis-sentinel-소개">Redis Sentinel 소개</h2>
<p>Redis Sentinel은 Redis의 고가용성 구성을 위한 아키텍처입니다. Sentinel은 Redis를 모니터링하고 master node가 장애가 발생시 알리고 자동으로 장애 조치할 수 있는 여러 Redis 인스턴스를 관리하기 위한 redis 컴포넌트입니다.</p>

<h2 id="redis-sentinel-역할">Redis Sentinel 역할</h2>
<p>Redis Sentinel은 Redis의 여러 인스턴스를 모니터링 및 관리하며 아래 3가지 역할을 수행하니다.</p>
<ul>
  <li>redis 인스턴스 모니터링 : Sentinel은 마스터 서버와 슬레이브 서버가 제대로 작동하는지 지속적으로 확인합니다.</li>
  <li>알림: 모니터링 중인 Redis 서버에 문제가 있는 경우 Sentinel은 API를 통해 관리자 또는 다른 응용 프로그램에 알림을 보낼 수 있습니다.</li>
  <li>자동장애조치 : 마스터 서버가 정상적으로 작동하지 않을 경우 Sentinel이 자동 장애 조치를 시작하여 장애가 발생한 마스터 서버의 슬레이브 서버 중 하나를 새 마스터 서버로 업그레이드하고 장애가 발생한 마스터 서버를 기타 슬레이브 서버는 대신 새 마스터 서버를 복사합니다. 클라이언트가 실패한 마스터 서버에 연결하려고 하면 클러스터도 새 마스터 서버의 주소를 클라이언트에 반환하여 클러스터가 새 마스터 서버를 사용하여 교체할 수 있도록 합니다</li>
</ul>

<h2 id="redis-sentinel-구성">Redis Sentinel 구성</h2>
<p>Redis를 다음의 <a href="https://yoonjk.github.io/cache/install-redis/">링크</a>를 참조하여 설치합니다.</p>

<p><img src="/assets/images/cache/14-cache-sentinel.png" alt="redis sentinel" /></p>

<p>Redis 를 HA 구성하는 방법은 몇가지 방법은 아래와 같이 구성할 수 있습니다. 첫번째 방법은 Master가 장애가 발생하면 서비스 장애가 발생하는 구성이지만 구성은 간단합니다. 두번째 방법 Sentinel 방법은 Redis Master가 장애가 발생하여도 slave가 master로 승격되어 지속적인 서비스가 가능합니다. 장애가 발생했던 master가 복귀되면 이전의 master는 slave 역할로 서비스를 합니다.
마지막 방법은 Redis 구성은 이전 방법보다는 복잡하지만 좀더 낳은 고가용성을 제공하면서 처리량을 높이는 방법입니다.<br />
이번 글에서는 Redis Sentinel을 구을해 봅니다.</p>

<ul>
  <li>Redis Master and Slave</li>
  <li>Redis Sentinel</li>
  <li>Redis Cluster</li>
</ul>

<h2 id="redis-환경설정">redis 환경설정</h2>
<p>redis sentinel을 구성하기 위해 redis master/slave 를 위한 환경설정을 합니다.</p>
<ul>
  <li>redis config 구성</li>
  <li>sentinel config 구성</li>
</ul>

<p>redis master config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis.conf redis_6382.conf
vi redis_6382.conf

<span class="c"># 포트 설정</span>
port 각자포트
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
logfile logs/redis_6382.log
</code></pre></div></div>

<p>redis slave config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_6382.conf redis_6383.conf 
<span class="nb">cp </span>redis_6382.conf redis_6384.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6383/g'</span> redis_6383.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/6382/6384/g'</span> redis_6384.conf 

<span class="c"># slave1</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6383.conf

<span class="c"># slave2</span>
<span class="nb">echo</span> <span class="s2">"slaveof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
<span class="nb">echo</span> <span class="s2">"replicaof 127.0.0.1 6382"</span> <span class="o">&gt;&gt;</span> redis_6384.conf
</code></pre></div></div>

<h4 id="redis-sentinel-config-구성">redis sentinel config 구성</h4>
<p>redis sentinel config 구성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>sentinel.conf redis_5000.conf
vi redis_5000.conf

<span class="c"># 포트 설정</span>
port 5000
<span class="c"># 백그라운드에서 시작하도록 설정</span>
daemonize <span class="nb">yes</span>
<span class="c"># log 파일 남도록 설정</span>
<span class="nb">dir</span> <span class="s2">"./"</span>
logfile <span class="s2">"logs/redis_5000.log"</span>
<span class="c"># 감시할 마스터 정보 및 쿼럼(quorum) 설정</span>
sentinel monitor mymaster 127.0.0.1 6382 2
<span class="c"># 다운 되었다고 인지하는 시간 (3초)</span>
- 마스터 서버에 정기적으로 PING을 보내는데, 이 시간 동안 응답이 없으면 다운된 것으로 판단하고 장애조치<span class="o">(</span>failover<span class="o">)</span> 작업을 시작합니다
sentinel down-after-milliseconds mymaster 3000
sentinel failover-timeout mymaster 3000
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>redis_5000.conf redis_5001.conf
<span class="nb">cp </span>redis_5000.conf redis_5002.conf

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5001/g'</span> redis_5001.conf 
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/5000/5002/g'</span> redis_5002.conf 
</code></pre></div></div>

<h2 id="redis-실행">redis 실행</h2>
<p>Redis 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-server redis_6382.conf
src/redis-server redis_6383.conf
src/redis-server redis_6384.conf
</code></pre></div></div>

<p>Redis Sentinel 3개 실행</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/redis-sentinel redis_5000.conf
src/redis-sentinel redis_5001.conf
src/redis-sentinel redis_5002.conf
</code></pre></div></div>

<h2 id="redis-failover-테스트">redis failover 테스트</h2>
<p>redis master를 강제 종료시 slave가 master로 승격되는 확인하기 위해, sentinel 서버의 로그를 모니터링 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tail</span> <span class="nt">-f</span> logs/redis_5000.log
</code></pre></div></div>
<p>redis master process를 확인하고 서버를 강제로 종료합니다.<br />
그러면 sentinel에서 자동으로 redis slave를 master로 승격하는 것을 확인 할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ef</span>|grep redis

<span class="c"># redis master pid를 확인</span>
<span class="nb">kill</span> <span class="nt">-9</span> redis_master_pid
</code></pre></div></div>

<h2 id="참고">참고</h2>
<p><a href="https://co-de.tistory.com/15">5분 안에 구축하는 Redis-Sentinel</a>
<a href="https://www.happykoo.net/@happykoo/posts/53">해피쿠</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="sentinel" /><summary type="html"><![CDATA[Redis Sentinel 소개 Redis Sentinel은 Redis의 고가용성 구성을 위한 아키텍처입니다. Sentinel은 Redis를 모니터링하고 master node가 장애가 발생시 알리고 자동으로 장애 조치할 수 있는 여러 Redis 인스턴스를 관리하기 위한 redis 컴포넌트입니다.]]></summary></entry><entry><title type="html">Getting Start Redis - List</title><link href="http://localhost:4000/cache/list/" rel="alternate" type="text/html" title="Getting Start Redis - List" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/list</id><content type="html" xml:base="http://localhost:4000/cache/list/"><![CDATA[<h2 id="list">List</h2>
<p>List 데이터 유형을 설명하려면 List라는 용어가  정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다.<br />
매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다:<br />
10,20,1,2,3은 목록입니다.<br />
그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다.<br />
Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. <a href="https://redis.io/commands/lpush">LPUSH</a> 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는  1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다.<br />
단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현  된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다.<br />
Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다.<br />
큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.</p>

<p>First steps with Redis Lists
<a href="https://redis.io/commands/lpush">LPUSH</a> 명령은  왼쪽(머리)의 목록에 새 요소를 추가하는 반면, <a href="https://redis.io/commands/rpush">RPUSH</a> 명령은 오른쪽(맨 끝)의 목록에 새 요소를 추가합니다. 마지막으로 <a href="https://redis.io/commands/lrange">LRANGE</a> 명령은 목록에서 요소 범위를 추출합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist A
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> rpush mylist B
<span class="o">(</span>integer<span class="o">)</span> 2
<span class="o">&gt;</span> lpush mylist first
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
</code></pre></div></div>
<p><a href="https://redis.io/commands/lrange">LRANGE</a>는  반환할 범위의 첫 번째 요소와 마지막 요소인 두 개의 인덱스를 사용합니다. 두 인덱스 모두 음수일 수 있으므로 Redis에게 끝에서 계산을 시작하도록 지시합니다. 따라서 -1은 마지막 요소이고 -2는 목록의 끝에서 두 번째 요소입니다.<br />
보시다시피 <a href="https://redis.io/commands/rpush">RPUSH</a>는  목록의 오른쪽에 요소를 추가하고 최종 <a href="https://redis.io/commands/lpush">LPUSH</a>는  왼쪽에 요소를 추가했습니다.<br />
두 명령 모두 가변 명령이므로 한 번의 호출로 여러 요소를 목록으로 자유롭게 푸시 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5 <span class="s2">"foo bar"</span>
<span class="o">(</span>integer<span class="o">)</span> 9
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"first"</span>
2<span class="o">)</span> <span class="s2">"A"</span>
3<span class="o">)</span> <span class="s2">"B"</span>
4<span class="o">)</span> <span class="s2">"1"</span>
5<span class="o">)</span> <span class="s2">"2"</span>
6<span class="o">)</span> <span class="s2">"3"</span>
7<span class="o">)</span> <span class="s2">"4"</span>
8<span class="o">)</span> <span class="s2">"5"</span>
9<span class="o">)</span> <span class="s2">"foo bar"</span>
</code></pre></div></div>

<p>Redis 목록에 정의된 중요한 작업은 요소를 팝하는 기능입니다. 요소를 팝핑하는 작업은 목록에서 요소를 검색하는 동시에 목록에서 제거하는 작업입니다. 목록의 양쪽에 요소를 푸시하는 방법과 유사하게 왼쪽과 오른쪽에서 요소를 팝 할 수 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist a b c
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> rpop mylist
<span class="s2">"c"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"b"</span>
<span class="o">&gt;</span> rpop mylist
<span class="s2">"a"</span>
</code></pre></div></div>

<p>세 개의 요소를 추가하고 세 개의 요소를 팝했으므로 이 명령 시퀀스가 끝나면 목록이 비어 있고 더 이상 팝업할 요소가 없습니다. 또 다른 요소를 터뜨리려고 하면 이것이 우리가 얻는 결과입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p>Redis는 목록에 요소가 없음을 알리기 위해 NULL 값을 반환했습니다.</p>

<p>Common use cases for lists
목록은 여러 작업에 유용하며 두 가지 매우 대표적인 사용 사례는 다음과 같습니다.:<br />
•	사용자가 소셜 네트워크에 게시 한 최신 업데이트 기억.<br />
•	생산자가 항목을 목록으로 푸시하고 소비자(일반적으로 작업자)가 해당 항목을 소비하고 작업을 실행하는 소비자-생산자 패턴을 사용하는 프로세스 간의 통신입니다. Redis에는 이 사용 사례를 보다 안정적이고 효율적으로 만드는 특수 목록 명령이 있습니다.</p>

<p>예를 들어 인기있는 Ruby 라이브러리 resque와 sidekiq는  백그라운드 작업을 구현하기 위해 내부적으로 Redis 목록을 사용합니다.<br />
인기있는 트위터 소셜 네트워크는 사용자가 게시 한 최신 트윗을 Redis 목록으로 가져옵니다.<br />
일반적인 사용 사례를 단계별로 설명하기 위해 홈페이지에 사진 공유 소셜 네트워크에 게시된 최신 사진이 표시되고 액세스 속도를 높이고 싶다고 가정해 보겠습니다.<br />
•	사용자가 새 사진을 게시 할 때마다 LPUSH를 사용하여 ID를 목록에 추가합니다.<br />
•	사용자가 홈페이지를 방문하면 <a href="https://redis.io/commands/lrange">LRANGE</a> 0 9를 사용하여  최신 10 개의 게시 된 항목을 가져옵니다.</p>

<p>Capped lists
많은 사용 사례에서 우리는 목록을 사용하여 소셜 네트워크 업데이트, 로그 또는 기타 무엇이든 최신 항목을 저장하려고합니다.<br />
Redis를 사용하면 목록을 제한 된 컬렉션으로 사용할 수 있으며 최신 N 항목 만 기억하고 <a href="https://redis.io/commands/ltrim">LTRIM</a> 명령을 사용하여 가장 오래된 항목을 모두 삭제할 수 있습니다.<br />
<a href="https://redis.io/commands/ltrim">LTRIM</a> 명령은 <a href="https://redis.io/commands/lrange">LRANGE</a>와 유사하지만 지정된 요소 범위를 표시하는 대신 이 범위를 새 목록 값으로 설정합니다. 주어진 범위를 벗어난 모든 요소가 제거됩니다.<br />
An example will make it more clear:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rpush mylist 1 2 3 4 5
<span class="o">(</span>integer<span class="o">)</span> 5
<span class="o">&gt;</span> ltrim mylist 0 2
OK
<span class="o">&gt;</span> lrange mylist 0 <span class="nt">-1</span>
1<span class="o">)</span> <span class="s2">"1"</span>
2<span class="o">)</span> <span class="s2">"2"</span>
3<span class="o">)</span> <span class="s2">"3"</span>
</code></pre></div></div>

<p>위의 <a href="https://redis.io/commands/ltrim">LTRIM</a> 명령은 Redis에게 인덱스 0에서 2까지의 목록 요소 만 가져 오도록 지시하고 다른 모든 것은 삭제됩니다. 이것은 매우 간단하지만 유용한 패턴을 허용합니다 :<br />
목록 푸시 작업 + 목록 트리밍 작업을 함께 수행하여 새 요소를 추가하고 제한을 초과하는 요소를 삭제합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LPUSH mylist &lt;some element&gt;
LTRIM mylist 0 999
</code></pre></div></div>

<p>위의 조합은 새 요소를 추가하고 1000개의 최신 요소만 목록에 가져옵니다. <a href="https://redis.io/commands/lrange">LRANGE</a>를 사용하면 아주 오래된 데이터를 기억할 필요없이 상위 항목에 액세스 할 수 있습니다.<br />
Note: <a href="https://redis.io/commands/lrange">LRANGE</a>는 기술적으로 O (N) 명령이지만 목록의 머리 또는 꼬리쪽으로 작은 범위에 액세스하는 것은 일정한 시간 작업입니다.</p>

<p>Blocking operations on lists<br />
목록에는 대기열을 구현하는 데 적합한 특수 기능이 있으며 일반적으로 프로세스 간 통신 시스템의 빌딩 블록으로 사용됩니다. 차단 작업.
하나의 프로세스가있는 목록으로 항목을 푸시하고 실제로 해당 항목으로 어떤 종류의 작업을 수행하기 위해 다른 프로세스를 사용한다고 가정 해보십시오. 이것은 일반적인 생산자 / 소비자 설정이며 다음과 같은 간단한 방법으로 구현할 수 있습니다.:<br />
•	항목을 목록에 푸시하기 위해 생산자는 <a href="https://redis.io/commands/lpush">LPUSH</a>를 호출합니다.<br />
•	목록에서 항목을 추출/처리하기 위해 소비자는 <a href="https://redis.io/commands/rpop">RPOP</a>를 호출합니다.</p>

<p>그러나 때로는 목록이 비어 있고 처리 할 것이 없으므로 RPOP는  NULL을 반환합니다. 이 경우 소비자는 잠시 기다렸다가 RPOP를 사용하여 다시 시도해야 합니다. 이것을 폴링이라고하며 몇 가지 단점이 있기 때문에이 맥락에서 좋은 생각이 아닙니다.:</p>
<ol>
  <li>Redis와 클라이언트가 쓸모없는 명령을 처리하도록합니다 (목록이 비어있을 때 모든 요청은 실제 작업을 수행하지 않고 NULL을 반환합니다).</li>
  <li>작업자가 NULL을 받은 후 잠시 기다리므로 항목 처리에 지연을 추가합니다. 지연을 줄이기 위해 RPOP에 대한 호출 사이에 더 적은 대기 시간을 할애할 수 있으며, 문제 번호 1, 즉 Redis에 대한 더 쓸모없는 호출을 증폭시키는 효과가 있습니다.</li>
</ol>

<p>따라서 Redis는 목록이 비어 있는 경우 차단할 수 있는 <a href="https://redis.io/commands/rpop">RPOP</a> 및 <a href="https://redis.io/commands/lpop">LPOP</a> 버전인 <a href="https://redis.io/commands/brpop">BRPOP</a> 및 <a href="https://redis.io/commands/blpop">BLPOP</a>라는 명령을 구현합니다. 새  요소가 목록에 추가되거나 사용자 지정 시간 초과에 도달할 때만 호출자에게 반환됩니다.<br />
이것은  작업자에서 사용할 수 있는 <a href="https://redis.io/commands/brpop">BRPOP</a> 호출의 예입니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> brpop tasks 5
1<span class="o">)</span> <span class="s2">"tasks"</span>
2<span class="o">)</span> <span class="s2">"do_something"</span>
</code></pre></div></div>
<p>즉, “목록 작업의 요소를 기다리지 만 5 초 후에 사용할 수있는 요소가 없으면 반환합니다.”.<br />
요소를 영원히 기다리는 시간 제한으로 0을 사용할 수 있으며, 동시에 여러 목록에서 대기하고 첫 번째 목록이 요소를 받을 때 알림을 받기 위해 하나가 아닌 여러 목록을 지정할 수도 있습니다.</p>

<p>BRPOP에 대해 주의해야 할 몇 가지 사항:</p>
<ol>
  <li>클라이언트는 정렬된 방식으로 제공됩니다: 목록 대기를 차단한 첫 번째 클라이언트는 다른 클라이언트에 의해 요소가 푸시될 때 먼저 제공됩니다.</li>
  <li>반환 값은 <a href="https://redis.io/commands/rpop">RPOP</a>와 다릅니다 : <a href="https://redis.io/commands/brpop">BRPOP</a> 및 <a href="https://redis.io/commands/blpop">BLPOP</a>이  여러 목록의 요소를 기다리는 것을 차단할 수 있기 때문에 키 이름도 포함하므로 2 요소 배열입니다.</li>
  <li>시간 제한에 도달하면 NULL이 반환됩니다.</li>
</ol>

<p>목록 및 차단 작업에 대해 알아야 할 사항이 더 있습니다. 다음에 대해 자세히 읽어 보시기 바랍니다.:<br />
•	<a href="https://redis.io/commands/lmove">LMOVE</a>를 사용하여 더 안전한 대기열 또는 순환 대기열을 구축할 수 있습니다.<br />
•	<a href="https://redis.io/commands/blmove">BLMOVE</a>라는 명령의 차단 변형도 있습니다.</p>

<p>Automatic creation and removal of keys
지금까지 예제에서는 요소를 푸시하기 전에 빈 목록을 만들거나 더 이상 내부에 요소가 없을 때 빈 목록을 제거 할 필요가 없었습니다. 목록이 비어있을 때 키를 삭제하거나 키가 존재하지 않고 요소를 추가하려는 경우 빈 목록을 만드는 것은 Redis의 책임입니다 
(예 : <a href="https://redis.io/commands/lpush">LPUSH</a>를 사용하여).</p>

<p>이는 목록에만 국한된 것이 아니라 여러 요소(스트림, 집합, 정렬된 집합 및 해시)로 구성된 모든 Redis 데이터 형식에 적용됩니다.
기본적으로 세 가지 규칙으로 행동을 요약 할 수 있습니다.:</p>
<ol>
  <li>집계 데이터 형식에 요소를 추가할 때 대상 키가 없으면 요소를 추가하기 전에 빈 집계 데이터 형식이 만들어집니다.</li>
  <li>집계 데이터 유형에서 요소를 제거할 때 값이 비어 있으면 키가 자동으로 삭제됩니다. Stream 데이터 형식은 이 규칙의 유일한 예외입니다.</li>
  <li><a href="https://redis.io/commands/llen">LLEN</a>(목록의 길이를 반환함)과 같은 읽기 전용 명령 또는 빈 키를 사용하여 요소를 제거하는 쓰기 명령을 호출하면 키가 명령이 찾을 것으로 예상되는 유형의 빈 집계 유형을 보유하고 있는 경우와 항상 동일한 결과가 생성됩니다.</li>
</ol>

<p>Examples of rule 1:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
</code></pre></div></div>
<p>However we can’t perform operations against the wrong type if the key exists:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">set </span>foo bar
OK
<span class="o">&gt;</span> lpush foo 1 2 3
</code></pre></div></div>
<p>(error) WRONGTYPE Operation against a key holding the wrong kind of value</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">type </span>foo
string
</code></pre></div></div>
<p>Example of rule 2:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> lpush mylist 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 1
<span class="o">&gt;</span> lpop mylist
<span class="s2">"3"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"2"</span>
<span class="o">&gt;</span> lpop mylist
<span class="s2">"1"</span>
<span class="o">&gt;</span> exists mylist
<span class="o">(</span>integer<span class="o">)</span> 0
</code></pre></div></div>
<p>The key no longer exists after all the elements are popped.<br />
Example of rule 3:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> del mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> llen mylist
<span class="o">(</span>integer<span class="o">)</span> 0
<span class="o">&gt;</span> lpop mylist
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><summary type="html"><![CDATA[List List 데이터 유형을 설명하려면 List라는 용어가 정보 기술 담당자에 의해 부적절한 방식으로 자주 사용되기 때문에 약간의 이론으로 시작하는 것이 좋습니다. 예를 들어 “파이썬 목록”은 이름이 암시하는 것 (연결 목록)이 아니라 배열 (실제로 Ruby에서는 동일한 데이터 유형을 배열이라고 함)입니다. 매우 일반적인 관점에서 List는 정렬된 요소의 시퀀스일 뿐입니다: 10,20,1,2,3은 목록입니다. 그러나 Array를 사용하여 구현된 List의 속성은 연결된 목록을 사용하여 구현된 List의 속성과 매우 다릅니다. Redis 목록은 연결된 목록을 통해 구현됩니다. 즉, 목록 내에 수백만 개의 요소가 있더라도 목록의 머리 또는 꼬리에 새 요소를 추가하는 작업은 일정한 시간에 수행됩니다. LPUSH 명령을 사용하여 새 요소를 10개의 요소가 있는 목록의 헤드에 추가하는 속도는 1,000만 개의 요소가 있는 목록의 헤드에 요소를 추가하는 것과 같습니다. 단점은 무엇입니까? 인덱스로 요소에 액세스하는 것은 Array (일정한 시간 인덱싱 된 액세스)로 구현 된 목록에서 매우 빠르며 연결된 목록으로 구현 된 목록 (액세스 된 요소의 인덱스에 비례하는 작업량이 필요한 경우)에서는 그렇게 빠르지 않습니다. Redis List는 데이터베이스 시스템의 경우 매우 빠른 방법으로 매우 긴 목록에 요소를 추가할 수 있어야 하기 때문에 연결된 목록으로 구현됩니다. 잠시 후에 볼 수 있듯이 또 다른 강력한 이점은 Redis 목록을 일정한 시간에 일정한 길이로 가져올 수 있다는 것입니다. 큰 요소 컬렉션의 중간에 빠르게 액세스하는 것이 중요한 경우 정렬된 집합이라고 하는 다른 데이터 구조를 사용할 수 있습니다. 정렬된 집합은 이 자습서의 뒷부분에서 다룹니다.]]></summary></entry><entry><title type="html">Getting Start Redis - Hashes</title><link href="http://localhost:4000/cache/hashes/" rel="alternate" type="text/html" title="Getting Start Redis - Hashes" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T00:00:00+09:00</updated><id>http://localhost:4000/cache/hashes</id><content type="html" xml:base="http://localhost:4000/cache/hashes/"><![CDATA[<h2 id="hashes">Hashes</h2>
<p>Redis 해시는 필드-값 쌍을 사용하여 “해시”가 어떻게 보이는지 정확히 보여줍니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hset user:1000 username antirez birthyear 1977 verified 1
<span class="o">(</span>integer<span class="o">)</span> 3
<span class="o">&gt;</span> hget user:1000 username
<span class="s2">"antirez"</span>
<span class="o">&gt;</span> hget user:1000 birthyear
<span class="s2">"1977"</span>
<span class="o">&gt;</span> hgetall user:1000
1<span class="o">)</span> <span class="s2">"username"</span>
2<span class="o">)</span> <span class="s2">"antirez"</span>
3<span class="o">)</span> <span class="s2">"birthyear"</span>
4<span class="o">)</span> <span class="s2">"1977"</span>
5<span class="o">)</span> <span class="s2">"verified"</span>
6<span class="o">)</span> <span class="s2">"1"</span>
</code></pre></div></div>
<p>해시는 객체를 나타내는 데 편리하지만 실제로 해시 안에 넣을 수있는 필드 수에는 사용 가능한 메모리 이외의 실질적인 제한이 없으므로 응용 프로그램 내에서 다양한 방법으로 해시를 사용할 수 있습니다.<br />
<a href="https://redis.io/commands/hset">HSET</a> 명령은  해시의 여러 필드를 설정하는 반면 HGET는 단일 필드를 검색합니다.</p>

<p><a href="https://redis.io/commands/hmget">HMGET</a>은 HGET와 유사  하지만 값 배열을 반환합니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hmget user:1000 username birthyear no-such-field
1<span class="o">)</span> <span class="s2">"antirez"</span>
2<span class="o">)</span> <span class="s2">"1977"</span>
3<span class="o">)</span> <span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<p><a href="https://redis.io/commands/hincrby">HINCRBY</a>와 같이 개별 필드에 대한 작업을 수행 할 수있는 명령도 있습니다.:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> hincrby user:1000 birthyear 10
<span class="o">(</span>integer<span class="o">)</span> 1987
<span class="o">&gt;</span> hincrby user:1000 birthyear 10
<span class="o">(</span>integer<span class="o">)</span> 1997
</code></pre></div></div>
<p>설명서에서 해시 명령의 전체 목록을 찾을 수 있습니다.
작은 해시 (즉, 작은 값을 가진 몇 가지 요소)가 메모리에서 특별한 방식으로 인코딩되어 메모리 효율이 매우 높다는 점은 주목할 가치가 있습니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[Hashes Redis 해시는 필드-값 쌍을 사용하여 “해시”가 어떻게 보이는지 정확히 보여줍니다.: &gt; hset user:1000 username antirez birthyear 1977 verified 1 (integer) 3 &gt; hget user:1000 username "antirez" &gt; hget user:1000 birthyear "1977" &gt; hgetall user:1000 1) "username" 2) "antirez" 3) "birthyear" 4) "1977" 5) "verified" 6) "1" 해시는 객체를 나타내는 데 편리하지만 실제로 해시 안에 넣을 수있는 필드 수에는 사용 가능한 메모리 이외의 실질적인 제한이 없으므로 응용 프로그램 내에서 다양한 방법으로 해시를 사용할 수 있습니다. HSET 명령은 해시의 여러 필드를 설정하는 반면 HGET는 단일 필드를 검색합니다.]]></summary></entry></feed>