<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-29T06:01:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html"></title><link href="http://localhost:4000/2023-06-30-install-argo-workflow/" rel="alternate" type="text/html" title="" /><published>2023-07-29T06:01:47+09:00</published><updated>2023-07-29T06:01:47+09:00</updated><id>http://localhost:4000/2023-06-30-install-argo-workflow</id><content type="html" xml:base="http://localhost:4000/2023-06-30-install-argo-workflow/"><![CDATA[<h2 id="argo-workflow-설치">Argo Workflow 설치</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-n</span> argo <span class="nt">-f</span> https://github.com/argoproj/argo-workflows/releases/download/v3.4.6/namespace-install.yaml
</code></pre></div></div>

<h2 id="argo-workflow-server-login-변경없이-접근">Argo Workflow server login 변경없이 접근</h2>
<p>Argo Workflow 3.x 이후 부터 UI에 접근하기 위해 로그인하도록 변경되었습니다.
그존 방식처럼 로그인 없이 사용하기 위해 다음과 같이 설정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl patch deployment   argo-server   <span class="nt">--namespace</span> argo   <span class="nt">--type</span><span class="o">=</span><span class="s1">'json'</span>   <span class="nt">-p</span><span class="o">=</span><span class="s1">'[{"op": "replace", "path": "/spec/template/spec/containers/0/args", "value": [
  "server",
  "--auth-mode=server"
]}]'</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2023-04-16-install-lua/" rel="alternate" type="text/html" title="" /><published>2023-07-29T06:01:47+09:00</published><updated>2023-07-29T06:01:47+09:00</updated><id>http://localhost:4000/2023-04-16-install-lua</id><content type="html" xml:base="http://localhost:4000/2023-04-16-install-lua/"><![CDATA[<h2 id="lua-설치---사전준비">lua 설치 - 사전준비</h2>
<p>사전에 compiler가 설치되어 있어야 합니다.
Compiler가 설치되어 있지 않는 경우 다음을 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo yum update -y
yum groupinstall -y 'Development Tools'
</code></pre></div></div>
<h2 id="lua-설치">lua 설치</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-R</span> <span class="nt">-O</span> http://www.lua.org/ftp/lua-5.4.4.tar.gz
<span class="nb">tar </span>zxf lua-5.4.4.tar.gz
<span class="nb">cd </span>lua-5.4.4
make all <span class="nb">test</span>
</code></pre></div></div>

<h2 id="lua-cli-실행">lua cli 실행</h2>
<p>lua를 실행하고 Hello World를 출력합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/lua
str = "Hello World"
print(str)
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author></entry><entry><title type="html">Watson Assistant 로 코딩없이 ChatBot 만들기</title><link href="http://localhost:4000/watson/watson-assistant-tutorial/" rel="alternate" type="text/html" title="Watson Assistant 로 코딩없이 ChatBot 만들기" /><published>2023-07-27T00:00:00+09:00</published><updated>2023-07-27T00:00:00+09:00</updated><id>http://localhost:4000/watson/watson-assistant-tutorial</id><content type="html" xml:base="http://localhost:4000/watson/watson-assistant-tutorial/"><![CDATA[<h2 id="ibm-왓슨-어시스턴트로-챗봇을-구축하는-방법">IBM 왓슨 어시스턴트로 챗봇을 구축하는 방법</h2>
<p>이 글에서는 IBM 왓슨 어시스턴트를 사용하여 작동하는 챗봇을 구축하는 방법에 대해 알아보겠습니다.<br />
왓슨 어시스턴트는 IBM 클라우드에서 호스팅되는 챗봇 구축용 서비스로, 별도의 프로그래밍 없이도 챗봇을 구축할 수 있습니다.</p>

<p><img src="/assets/images/watson/01-bot.png" alt="" /></p>

<p>챗봇 구축을 시작하기 전에 챗봇이란 무엇이며 챗봇의 사용 사례를 이해해 보겠습니다.</p>
<blockquote>
  <p>챗봇은 사람과 대화를 시뮬레이션할 수 있는 인공 지능(AI) 소프트웨어입니다. 챗봇 서비스는 사용자의 텍스트, 
시각 또는 청각 입력에 응답하도록 프로그래밍되어 있으며 SMS, 웹사이트 채팅창, 소셜 메시징 서비스 등의 매체를 활용하여 메시지를 수신하고 응답합니다.</p>
</blockquote>

<p>챗봇은 FAQ 답변, 24*7 고객 관리 지원, 티켓 예약, 피자 주문 접수 등 다양한 서비스에서 사용할 수 있습니다.</p>

<p>다음 작업을 처리할 수 있는 레스토랑용 챗봇을 구축하겠습니다:</p>

<ol>
  <li><strong>예약하기</strong> - 챗봇이 최종 사용자를 위해 테이블을 예약할 수 있습니다.</li>
  <li><strong>영업시간</strong> - 챗봇이 레스토랑의 영업 시간에 대한 정보를 제공할 수 있습니다.</li>
</ol>

<p>원하는 만큼 많은 기능을 추가할 수 있지만,<br />
단순화와 이해를 돕기 위해 위의 두 가지 기능에만 초점을 맞춰 설명하겠습니다.</p>

<p>이제 챗봇이 수행할 수 있는 작업의 종류에 대한 의도를 설정했으니 구축을 시작하겠습니다.</p>

<h2 id="챗봇-만들기">챗봇 만들기</h2>
<p>IBM 왓슨 어시스턴트 서비스를 사용하려면 IBM 클라우드 계정이 있어야 합니다.<br />
IBM Cloud 계정에 로그인합니다. 계정이 없는 경우 여기에서 무료로 가입할 수 있습니다.</p>

<p><a href="https://cloud.ibm.com/registration">IBM Cloud 가입</a></p>

<p><strong>1단계: 왓슨 어시스턴트 서비스 인스턴스 만들기</strong><br />
IBM 클라우드 계정에 로그인하면 대시보드에 아래와 같은 화면이 나타납니다.<br />
<img src="/assets/images/watson/02-dashboard.png" alt="" /></p>

<p>검색창에 “왓슨 어시스턴트”를 입력하고 왓슨 어시스턴트 서비스를 생성합니다.</p>

<p>왓슨 어시스턴트 서비스를 생성한 후 해당 서비스를 클릭하면 다음과 같은 화면이 나타납니다.</p>

<p><img src="/assets/images/watson/03-start-by-launching the tool.png" alt="" /></p>

<p>이제 ‘왓슨 어시스턴트 실행’을 클릭하여 서비스를 시작합니다.</p>

<p><strong>2단계: 어시스턴트에 대화 스킬 추가하기</strong>
첫 번째 단계를 완료하면 다음 이미지가 표시됩니다.</p>

<p><img src="/assets/images/watson/04-add-a-dialog-skill-to the assistant.png" alt="" /></p>

<p>이 단계에서는 어시스턴트에 대화 스킬을 추가하겠습니다.<br />
대화 스킬은 어시스턴트가 언급된 작업을 수행하는 데 도움이 됩니다.</p>

<p>어시스턴트에 대화 스킬을 추가하려면 “내 첫 번째 어시스턴트”를 클릭합니다. 다음 이미지가 표시됩니다.</p>

<p><img src="/assets/images/watson/05-my-first-assistant.png" alt="" /></p>

<p>여기에서 어시스턴트에 연결된 액션 스킬이 있음을 알 수 있습니다.<br />
어떤 경우에는 어시스턴트에 연결된 액션 스킬이 있고 어떤 경우에는 어시스턴트에 연결된 대화 스킬이 있습니다.</p>

<p>어시스턴트에 연결된 대화 스킬이 있는 경우에는 아무것도 변경할 필요가 없지만, 우리의 경우에는<br />
어시스턴트에 연결된 액션 스킬이 있고 대화 스킬을 연결하려고 합니다.<br />
이렇게 하려면 먼저 어시스턴트에서 액션 스킬을 제거합니다.</p>

<p><img src="/assets/images/watson/06-remove-action-skill.png" alt="" /></p>

<p>기존 액션 스킬을 제거하려면 내 첫 번째 스킬의 오른쪽 상단 모서리에 있는 점 3개를 클릭하고 스킬 제거를 클릭합니다.<br />
액션 스킬을 성공적으로 제거하면 다음 이미지가 표시됩니다.</p>

<p><img src="/assets/images/watson/07-add-dialog-skill.png" alt="" /></p>

<p>이제 대화 스킬을 추가하려면 “액션 또는 대화 스킬 추가”를 클릭하고<br />
“Restaurant Skill” 이라는 이름의 새 대화 스킬을 만든 다음 스킬 만들기를 클릭합니다.</p>

<p><img src="/assets/images/watson//08-add-action-or-dialog.png" alt="" /></p>

<p>이 작업을 완료하면 어시스턴트에 새 대화 스킬이 추가됩니다. 이것으로 챗봇 구축의 2단계가 완료됩니다.</p>

<p><img src="/assets/images/watson/09-complete-step2.png" alt="" /></p>

<p><strong>3단계: 인텐트를 만들고 스킬에 추가하기</strong></p>

<p>이 단계에서는 인텐트를 생성하고 스킬에 추가하겠습니다. 하지만 그 전에 인텐트가 무엇인지 이해해야 합니다.</p>

<p>왓슨 어시스턴트에 따르면</p>

<blockquote>
  <p>인텐트는 동일한 의미를 가진 사용자 질의 문장의 모음입니다.<br />
인텐트를 만들면 어시스턴트가 사용자가 목표를 표현하는 다양한 방식을 이해하도록 훈련시킬 수 있습니다.</p>
</blockquote>

<p>인텐트는 단순히 동일한 의미를 가진 사용자 문장의 모음입니다. 
이러한 문장은 사용자가 원하는 목표를 표현하는 문장이 될 수 있으며, 이 경우 테이블 예약하기와 같은 문장이 될 수 있습니다.</p>

<p>사용자가 레스토랑에서 테이블을 예약하기 위해 말할 수 있는 다양한 방법에는 어떤 것이 있나요?</p>

<p>테이블 예약하기.</p>

<p>나를 위한 테이블 예약하기.</p>

<p>레스토랑의 테이블을 예약하세요.</p>

<p>테이블 예약하기.</p>

<p>저녁 식사를 위한 테이블을 예약하고 싶습니다.</p>

<p>이 모든 예는 사용자가 테이블을 예약하려는 의도를 보여줍니다.<br />
이 예시를 보면 사용자가 테이블을 예약하고 싶다는 것을 쉽게 알 수 있습니다. 챗봇의 인텐트도 마찬가지입니다.</p>

<p>인텐트는 챗봇이 사용자가 달성하고자 하는 목표를 식별하는 데 도움이 됩니다. <br />
이러한 목표는 예약하기, 운영 시간 정보를 얻기 등이 될 수 있습니다.</p>

<p>챗봇에서는 예약을 하고 영업시간에 대한 정보를 얻는 두 가지 주요 목표를 달성하고자 합니다.<br />
따라서 각각에 대해 하나씩 두 개의 인텐트를 만들 것입니다.</p>

<p>먼저, 사용자의 테이블 예약 의도를 파악하기 위해 인텐트를 생성합니다.</p>

<p>인텐트를 생성하려면 먼저 레스토랑 스킬을 클릭합니다. 다음 이미지가 표시됩니다.</p>

<p><img src="/assets/images/watson/09-make-intent.png" alt="" /></p>

<p>이제 인텐트 생성을 클릭합니다. 그런 다음 인텐트 이름 “make_booking”을 입력한 다음 인텐트 생성을 클릭합니다.<br />
다음 이미지가 표시됩니다.</p>

<p><img src="/assets/images/watson/10-make-a-booking.png" alt="" /></p>

<p>이제 인텐트 생성을 클릭합니다. 그런 다음 인텐트 이름 “make_booking”을 입력한 다음 인텐트 생성을 클릭합니다. 다음 이미지가 표시됩니다.</p>

<p>테이블을 예약.</p>

<p>나를 위해 테이블을 예약.</p>

<p>레스토랑의 테이블을 예약.</p>

<p>테이블 예약하기.</p>

<p>저녁 식사를 위한 테이블을 예약하고 싶습니다.</p>

<p>예제를 추가하려면 문장을 입력한 다음 예제 추가를 클릭하세요. 모든 예제를 성공적으로 추가하면 다음 이미지가 표시됩니다.</p>

<p><img src="/assets/images/watson/11-add-examples.png" alt="" /></p>

<p>마찬가지로 다음 예제를 사용하여 운영 시간에 대한 다른 인텐트를 만듭니다.</p>

<p>운영 시간은 어떻게 되나요?</p>

<p>주말에 영업하나요?</p>

<p>일요일에도 영업하나요?</p>

<p>근무 시간은 어떻게 되나요?</p>

<p>레스토랑의 영업 시간은 언제인가요?</p>

<p><img src="/assets/images/watson/12-house-of-operations.png" alt="" /></p>

<p><strong>결과</strong><br />
<img src="/assets/images/watson/13-house-of-operations-examples.png" alt="" /></p>

<p>지금까지 왓슨 어시스턴트 서비스 인스턴스를 생성하고 어시스턴트에 대화 스킬을 추가하고 두 개의 인텐트를 생성했습니다.<br />
다음 단계로 넘어가겠습니다.</p>

<p><strong>4단계: 엔티티를 생성하고 스킬에 추가하기</strong></p>

<p>이 단계에서는 엔티티를 만들어 스킬에 추가하겠습니다. 하지만 그 전에 엔티티가 무엇이며 챗봇을 구축하는 데 어떻게 사용될 수 있는지 이해해 보겠습니다.</p>

<p>왓슨 어시스턴트에 따르면…</p>

<blockquote>
  <p>엔티티는 사용자 입력에서 사용자의 목적과 관련된 정보를 나타냅니다.</p>
</blockquote>

<p>인텐트가 동사(사용자가 수행하려는 작업)를 나타내는 경우 엔티티는 명사(해당 작업의 대상 또는 해당 작업의 컨텍스트)를 나타냅니다.<br />
예를 들어 일기 예보를 확인하는 것이 인텐트인 경우 애플리케이션이 정확한 예보를 반환하려면 관련 위치 및 날짜 엔티티가 필요합니다.</p>

<p>이 예제에서 사용자는 레스토랑에서 테이블을 예약하려고 합니다.<br />
하지만 테이블을 예약하려면 챗봇은 사용자가 몇 시, 몇 날짜에 테이블을 예약하려는지 알아야 합니다.<br />
여기서 날짜와 시간은 테이블을 예약하는 데 필요한 엔티티입니다.</p>

<p>따라서 대화 스킬에 날짜와 시간이라는 두 개의 엔티티를 추가하겠습니다. 다행히도 이 두 엔티티를 만들 필요는 없습니다.<br />
왓슨 어시스턴트에서 이 두 엔티티는 시스템 엔티티에 미리 정의되어 있습니다.<br />
이 두 엔티티를 사용하도록 설정하기만 하면 됩니다.</p>

<p>이 두 엔티티를 활성화하려면 “Restuarant 스킬”에서 “엔티티”를 클릭합니다.<br />
클릭하면 다음 이미지가 표시됩니다</p>

<p><img src="/assets/images/watson/13-entities.png" alt="" /></p>

<p>엔티티 섹션에 내 엔티티와 시스템 엔티티라는 두 가지 옵션이 표시됩니다.<br />
시스템 엔티티를 클릭하고 시스템 날짜 및 시스템 시간 엔티티를 활성화하면 챗봇에서 사용할 수 있습니다.</p>

<p><img src="/assets/images/watson/14-systems-entities.png" alt="" /></p>

<p>이제 시스템 날짜 및 시스템 시간 엔티티를 활성화했습니다. 이제 챗봇을 구축하는 데 사용할 수 있습니다.</p>

<p><strong>5단계: 대화 상자 만들기</strong> .<br />
이제 사용자 입력에 대한 응답을 제공하는 대화 상자를 만들겠습니다.<br />
하지만 그 전에 대화 상자가 무엇인지 이해해 봅시다.</p>

<p>왓슨 어시스턴트에 따르면…</p>

<blockquote>
  <p>Dialog는 논리 트리의 형태로 대화의 흐름을 정의합니다.<br />
이 트리는 의도(사용자가 말하는 내용)와 응답(챗봇이 응답하는 내용)을 일치시킵니다.<br />
트리의 각 노드에는 사용자 입력에 따라 트리를 트리거하는 조건이 있습니다.</p>
</blockquote>]]></content><author><name>Jaeguk Yun</name></author><category term="watson" /><category term="watson assistant" /><summary type="html"><![CDATA[IBM 왓슨 어시스턴트로 챗봇을 구축하는 방법 이 글에서는 IBM 왓슨 어시스턴트를 사용하여 작동하는 챗봇을 구축하는 방법에 대해 알아보겠습니다. 왓슨 어시스턴트는 IBM 클라우드에서 호스팅되는 챗봇 구축용 서비스로, 별도의 프로그래밍 없이도 챗봇을 구축할 수 있습니다.]]></summary></entry><entry><title type="html">맥환경에서 eclipse 자동완성 단축키 설정</title><link href="http://localhost:4000/springboot/auto-sts/" rel="alternate" type="text/html" title="맥환경에서 eclipse 자동완성 단축키 설정" /><published>2023-06-01T00:00:00+09:00</published><updated>2023-06-01T00:00:00+09:00</updated><id>http://localhost:4000/springboot/auto-sts</id><content type="html" xml:base="http://localhost:4000/springboot/auto-sts/"><![CDATA[<p>윈도우에서 자동완성 단축키는 Ctrl + Space 입니다. 하지만 맥북환경에서는 Ctrl + Space로 기본으로 설정되어 있습니다.
그래서 자동완성 단축키를 Shift + Space로 변경해서 사용합니다.</p>

<p><img src="/assets/images/springboot/05-sts-short-cut-mac.png" alt="sts-short-cut-mac" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="short-key" /><summary type="html"><![CDATA[윈도우에서 자동완성 단축키는 Ctrl + Space 입니다. 하지만 맥북환경에서는 Ctrl + Space로 기본으로 설정되어 있습니다. 그래서 자동완성 단축키를 Shift + Space로 변경해서 사용합니다.]]></summary></entry><entry><title type="html">Kafka using docker-compose</title><link href="http://localhost:4000/docker/kafka-on-docker/" rel="alternate" type="text/html" title="Kafka using docker-compose" /><published>2023-05-13T00:00:00+09:00</published><updated>2023-05-13T00:00:00+09:00</updated><id>http://localhost:4000/docker/kafka-on-docker</id><content type="html" xml:base="http://localhost:4000/docker/kafka-on-docker/"><![CDATA[<p>카프카 브로커 1개, 주키퍼 1로 구성된 confluent사의 docker 이미지를 기반으로 실행하는 docker-compose 파일입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: '2'

services:
  zookeeper:
    container_name: zookeeper
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_SERVER_ID: 1
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
      ZOOKEEPER_INIT_LIMIT: 5
      ZOOKEEPER_SYNC_LIMIT: 2
    ports:
      - "2181:2181"

  kafka:
    container_name: kafka
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
</code></pre></div></div>

<h2 id="kafka-연결">Kafka 연결</h2>
<p>Confluent 사의 docker image에서는 kafka CLI 들이  sh 확장자가 없습니다. apache 나 Bitnami 에서 제공하는 docker image는 sh 확장자가 있는 것이 특징입니다.</p>

<p>다음의 명령어로 현재 topic 목록을 조회합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker exec -it kafka kafka-topics --bootstrap-server kafka:9092 --list
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="Kafka" /><summary type="html"><![CDATA[카프카 브로커 1개, 주키퍼 1로 구성된 confluent사의 docker 이미지를 기반으로 실행하는 docker-compose 파일입니다. ``` version: ‘2’]]></summary></entry><entry><title type="html">Lua Script 및 Redis7 FUNCTION</title><link href="http://localhost:4000/cache/lua-example/" rel="alternate" type="text/html" title="Lua Script 및 Redis7 FUNCTION" /><published>2023-04-30T00:00:00+09:00</published><updated>2023-04-30T00:00:00+09:00</updated><id>http://localhost:4000/cache/lua-example</id><content type="html" xml:base="http://localhost:4000/cache/lua-example/"><![CDATA[<p>Lua를 이용하여 Redis에 있는 데이터를 월별 합계를 계산하거나, from ~ to 기간을 입력받아 합계를 계산할 수 도 있습니다.</p>

<p>다음은 그 예시입니다.</p>

<h2 id="초기-데이터-로드">초기 데이터 로드</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; hmset SiteID:TotalCnt 20180101 10 20180102 2 20180103 5 20180120 10 20180131 30 20180205 20 20180210 5 20180331 23 20181230 1230 20190130 130 20190301 310 20200102 10 20200215 30 20200503 15 20200601 40 20200801 45 20200909 500 20201015 70 20201117 60 20201220 45 20220115 10 20220212 51 20220301 80 20220405 2 20220505 25 20220606 60 20220717 70 20220815 80 20220903 90 20221009 100 20221101 110 20221225 120 20230120 10 20230222 20 20230313 30 20230414 40 20230501 50<span class="s2">"
</span></code></pre></div></div>

<h2 id="lua-script">Lua script</h2>
<h4 id="월별합계">월별합계</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- summon.lua
local key, mon = KEYS[1], ARGV[1]
local subkey
local sumkey, keyval= 0

for i = 1,31 do
    if i &lt; 10 then 
        subkey = mon .. '0' .. tostring(i)
    else 
        subkey = mon .. tostring(i)
    end

    keyval = tonumber(redis.call('hget',key,subkey))

    if keyval ~= nil then
        sumkey = sumkey + keyval
    end
end

return sumkey
</code></pre></div></div>
<h4 id="lua-function-days-of-month">lua FUNCTION days-of-month</h4>
<p>Redis 7 부터 지원하는 FUNCTION을 이용하여 월별 마지막 달을 구하는 Redis FUNCTION 입니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!lua name=mylib</span>
<span class="nt">--</span> get_days_in_month
<span class="nb">local </span><span class="k">function </span>get_days_in_month <span class="o">(</span>keys, args<span class="o">)</span>
  <span class="nb">local </span>year <span class="o">=</span> tonumber<span class="o">(</span>keys[1]<span class="o">)</span>
  <span class="nb">local </span>month <span class="o">=</span> tonumber<span class="o">(</span>args[1]<span class="o">)</span>
  <span class="nb">local </span><span class="nv">days_in_month</span><span class="o">=</span> <span class="o">{</span> 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 <span class="o">}</span>
  <span class="nb">local </span>days <span class="o">=</span> days_in_month[month]

  <span class="k">if</span> <span class="o">(</span>month <span class="o">==</span> 2<span class="o">)</span> <span class="k">then
    if</span> <span class="o">(</span>math.mod<span class="o">(</span>year,4<span class="o">)</span> <span class="o">==</span> 0<span class="o">)</span> <span class="k">then
      if</span> <span class="o">(</span>math.mod<span class="o">(</span>year,100<span class="o">)</span> <span class="o">==</span> 0<span class="o">)</span><span class="k">then
        if</span> <span class="o">(</span>math.mod<span class="o">(</span>year,400<span class="o">)</span> <span class="o">==</span> 0<span class="o">)</span> <span class="k">then
          </span>days <span class="o">=</span> 29
        end
      <span class="k">else
        </span>days <span class="o">=</span> 29
     end
    end
  end

  <span class="k">return </span>days
end

redis.register_function<span class="o">(</span><span class="s1">'get_days_in_month'</span>, get_days_in_month<span class="o">)</span>
</code></pre></div></div>

<h4 id="redis-function-등록">Redis FUNCTION 등록</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>day_of_month.lua | redis-cli <span class="nt">-p</span> 6383 <span class="nt">-x</span> FUNCTION LOAD REPLACE
</code></pre></div></div>

<h4 id="redis-function-호출">Redis FUNCTION 호출</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6383&gt; FCALL get_days_in_month 1 2020 2
127.0.0.1:6383&gt; FCALL get_days_in_month 1 2022 2
127.0.0.1:6383&gt; FCALL get_days_in_month 1 2023 2
127.0.0.1:6383&gt; FCALL get_days_in_month 1 2023 4
</code></pre></div></div>

<h2 id="참조">참조</h2>
<p><a href="https://bstar36.tistory.com/348">멋지게 놀아라</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="lua" /><summary type="html"><![CDATA[Lua를 이용하여 Redis에 있는 데이터를 월별 합계를 계산하거나, from ~ to 기간을 입력받아 합계를 계산할 수 도 있습니다.]]></summary></entry><entry><title type="html">VS Code에서 사용하거나 사용하지 않는 import 클래스 단축키로 일용등록/삭제.</title><link href="http://localhost:4000/springboot/quick-fix/" rel="alternate" type="text/html" title="VS Code에서 사용하거나 사용하지 않는 import 클래스 단축키로 일용등록/삭제." /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T00:00:00+09:00</updated><id>http://localhost:4000/springboot/quick-fix</id><content type="html" xml:base="http://localhost:4000/springboot/quick-fix/"><![CDATA[<p>맥북 개발자가 springboot기반으로 개발환경을 사용할 때 자동 import 를 하거나 사용하지 않는 Class가 import되어 있는 것이 있을 때 이를 단축키로 자동으로 제거하는 명렁어는
<strong>Shift + alt(option) + o</strong> 를 동시에 누르면 Never used 로 되어 있는 import 클래스를 삭제해줍니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="quickfix" /><summary type="html"><![CDATA[맥북 개발자가 springboot기반으로 개발환경을 사용할 때 자동 import 를 하거나 사용하지 않는 Class가 import되어 있는 것이 있을 때 이를 단축키로 자동으로 제거하는 명렁어는 Shift + alt(option) + o 를 동시에 누르면 Never used 로 되어 있는 import 클래스를 삭제해줍니다.]]></summary></entry><entry><title type="html">maven에서 jdk 버전이 변경되지 않는 경우</title><link href="http://localhost:4000/springboot/change-jdk11-to-maven/" rel="alternate" type="text/html" title="maven에서 jdk 버전이 변경되지 않는 경우" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T00:00:00+09:00</updated><id>http://localhost:4000/springboot/change-jdk11-to-maven</id><content type="html" xml:base="http://localhost:4000/springboot/change-jdk11-to-maven/"><![CDATA[<p>jdk1.8 에서 jdk11로 전환하여 개발을 하는 경우 jdk는 11로 변경되었지만 maven은 여전히 jdk1.8로 빌드를 하는 경우 다음과 같이 추가합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi <span class="nv">$HOME</span>/.mavenrc

<span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span><span class="si">$(</span>/usr/libexec/java_home <span class="nt">-v</span> 110<span class="si">)</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="quickfix" /><summary type="html"><![CDATA[jdk1.8 에서 jdk11로 전환하여 개발을 하는 경우 jdk는 11로 변경되었지만 maven은 여전히 jdk1.8로 빌드를 하는 경우 다음과 같이 추가합니다. ```bash vi $HOME/.mavenrc]]></summary></entry><entry><title type="html">Redis 시작하기 - PubSub - springboot</title><link href="http://localhost:4000/cache/pub-sub/" rel="alternate" type="text/html" title="Redis 시작하기 - PubSub - springboot" /><published>2023-04-23T00:00:00+09:00</published><updated>2023-04-23T00:00:00+09:00</updated><id>http://localhost:4000/cache/pub-sub</id><content type="html" xml:base="http://localhost:4000/cache/pub-sub/"><![CDATA[<p>Redis에서 Pub/Sub을 지원합니다. 특정 topic에 메시지를 전송하는 것을 Springboot을 이용하여 구현하는 것을 알아봅니다.</p>

<h2 id="applicationyml-설정">application.yml 설정</h2>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">main.allow-circular-references</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">application</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">redis-cluster</span>
  <span class="na">redis</span><span class="pi">:</span>
     <span class="na">topic</span><span class="pi">:</span> <span class="s">${MY_TOPIC:topic1}</span>
</code></pre></div></div>
<h2 id="chatmessage-model">ChatMessage Model</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@ToString</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatMessage</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">sender</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">context</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="chatmessage-dto">ChatMessage Dto</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@ToString</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatMessageDto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">sender</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">context</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="subscribe-serivce">Subscribe Serivce</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisSubService</span> <span class="kd">implements</span> <span class="nc">MessageListener</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">message</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
    	<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"받은 메시지 = {}, body={}, pattern:{}"</span><span class="o">,</span> <span class="n">message</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">getBody</span><span class="o">()),</span>  <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">pattern</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="redis-configuration">Redis Configuration</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="o">;</span>

	<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.topic}"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">topicName</span><span class="o">;</span>

     <span class="o">:</span>
    <span class="c1">//리스너어댑터 설정</span>
    <span class="nd">@Bean</span>
    <span class="nc">MessageListenerAdapter</span> <span class="nf">messageListenerAdapter</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MessageListenerAdapter</span><span class="o">(</span><span class="k">new</span> <span class="nc">RedisSubService</span><span class="o">());</span>
    <span class="o">}</span>
    
    <span class="c1">//컨테이너 설정</span>
    <span class="nd">@Bean</span>
    <span class="nc">RedisMessageListenerContainer</span> <span class="nf">redisContainer</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">RedisMessageListenerContainer</span> <span class="n">container</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisMessageListenerContainer</span><span class="o">();</span>
        <span class="n">container</span><span class="o">.</span><span class="na">setConnectionFactory</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">());</span>
        <span class="n">container</span><span class="o">.</span><span class="na">addMessageListener</span><span class="o">(</span><span class="n">messageListenerAdapter</span><span class="o">(),</span> <span class="n">topic</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">container</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//pub/sub 토픽 설정</span>
    <span class="nd">@Bean</span>
    <span class="nc">ChannelTopic</span> <span class="nf">topic</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ChannelTopic</span><span class="o">(</span><span class="n">topicName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="publish-service">Publish Service</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisPubService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="o">;</span>

	<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.topic}"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">topicName</span><span class="o">;</span>
	
	<span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendMessage</span><span class="o">(</span><span class="nc">ChatMessage</span> <span class="n">chatMessage</span><span class="o">)</span> <span class="o">{</span>
    	<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"topicName:{}, Chat Message:{}"</span><span class="o">,</span> <span class="n">topicName</span><span class="o">,</span> <span class="n">chatMessage</span><span class="o">);</span>
    	<span class="k">try</span> <span class="o">{</span>
        <span class="n">redisTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">topicName</span><span class="o">,</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">chatMessage</span><span class="o">));</span>
    	<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">JsonProcessingException</span> <span class="n">jpe</span><span class="o">)</span> <span class="o">{</span>
    		<span class="n">jpe</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    	<span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="controller">Controller</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PubSubController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RedisPubService</span> <span class="n">redisPubService</span><span class="o">;</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/api/chat"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">pubSub</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">ChatMessageDto</span> <span class="n">chatMessageDto</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//메시지 보내기</span>
    	<span class="nc">ChatMessage</span> <span class="n">chatMessage</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ChatMessage</span><span class="o">();</span>
    	<span class="nc">BeanUtils</span><span class="o">.</span><span class="na">copyProperties</span><span class="o">(</span><span class="n">chatMessageDto</span><span class="o">,</span> <span class="n">chatMessage</span><span class="o">);</span>
    	<span class="n">redisPubService</span><span class="o">.</span><span class="na">sendMessage</span><span class="o">(</span><span class="n">chatMessage</span><span class="o">);</span>

      <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="springboot" /><summary type="html"><![CDATA[Redis에서 Pub/Sub을 지원합니다. 특정 topic에 메시지를 전송하는 것을 Springboot을 이용하여 구현하는 것을 알아봅니다.]]></summary></entry><entry><title type="html">Redis 시작하기 - Usecases - Leaderboard</title><link href="http://localhost:4000/cache/usecases-leaderboard/" rel="alternate" type="text/html" title="Redis 시작하기 - Usecases - Leaderboard" /><published>2023-04-22T00:00:00+09:00</published><updated>2023-04-22T00:00:00+09:00</updated><id>http://localhost:4000/cache/usecases-leaderboard</id><content type="html" xml:base="http://localhost:4000/cache/usecases-leaderboard/"><![CDATA[<p>LUA 스크립팅의 효율적인 방법으로 수행 할 수 있는 사례에 사용될 수 사례를 살펴봅니다.
여기에는 Redis zset에 유지되는 리더 보드가 있으며, 현재 사용 사례를 위해 주어진 사용자의 경우 해당 사용자의 순위와 리더 보드에서 사용자의 주변의 rank를 얻을 수도 있습니다.</p>

<p><img src="/assets/images/cache/30-cache-leaderboard.png" alt="locked" /></p>

<p>아래의 2 개의 명령이 연속적으로 수행했을 때 정확한 결과를 가져오는가?</p>

<ul>
  <li>첫 번째는 Zrank Leaderboard Heather를 사용하여 사용자 순위를 얻습니다</li>
  <li>그런 다음 위의 순위를 사용하여 하위 및 상한을 얻으려면 아래에서 3을, 아래 3 개를 원한다고 가정 해 봅시다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6383&gt; zadd leaderboard 10 Andrew 20 Bella 30 Andy 33 Dolly 40 Cathy 42 Heather 43 Gilbert 45 Lilly 50  Dinesh 58 <span class="s2">"Jon snow"</span> 60 Ygnitte
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6383&gt; zrange leaderboard 0 <span class="nt">-1</span>
 1<span class="o">)</span> <span class="s2">"Andrew"</span>
 2<span class="o">)</span> <span class="s2">"Bella"</span>
 3<span class="o">)</span> <span class="s2">"Andy"</span>
 4<span class="o">)</span> <span class="s2">"Dolly"</span>
 5<span class="o">)</span> <span class="s2">"Cathy"</span>
 6<span class="o">)</span> <span class="s2">"Heather"</span>
 7<span class="o">)</span> <span class="s2">"Gilbert"</span>
 8<span class="o">)</span> <span class="s2">"Lilly"</span>
 9<span class="o">)</span> <span class="s2">"Dinesh"</span>
10<span class="o">)</span> <span class="s2">"Jon snow"</span>
11<span class="o">)</span> <span class="s2">"Ygnitte"</span>
127.0.0.1:6383&gt; zrank leaderboard Heather
<span class="o">(</span>integer<span class="o">)</span> 5
127.0.0.1:6383&gt; zrange leaderboard 2 8
1<span class="o">)</span> <span class="s2">"Andy"</span>
2<span class="o">)</span> <span class="s2">"Dolly"</span>
3<span class="o">)</span> <span class="s2">"Cathy"</span>
4<span class="o">)</span> <span class="s2">"Heather"</span>
5<span class="o">)</span> <span class="s2">"Gilbert"</span>
6<span class="o">)</span> <span class="s2">"Lilly"</span>
7<span class="o">)</span> <span class="s2">"Dinesh"</span>
</code></pre></div></div>

<p>그러나 리더 보드는 zrank와 zrange Redis 명령어를 실행하는 사이에 순위가 변경 될 수 있습니다.
이를 해결하기 위한 솔루션 중 하나는 사용자의 순위를 얻기 전에 일종의 lock 장치를 사용한 다음 zrange를 사용한 다음 lock을 제거하는 것입니다. 그리고 이전에, 리더 보드에 쓰고, 우리는 lock을 점검해야하며, lock 장치가 있으면 lock 장치가 제거 될 때까지 재 시도해야합니다.</p>

<p><img src="/assets/images/cache/29-cache-locked.png" alt="locked" /></p>

<p>유스 케이스를 처리하는 우아한 방법은 LUA 스크립트를 사용하는 것입니다
Redis는 서버에서 LUA 스크립트를 업로드하고 실행할 수 있으며 스크립트가 서버에서 실행되기 때문에 스크립트에서 데이터를 읽고 쓰는 것이 매우 효율적입니다.
또한 Redis는 스크립트의 원자(Atomic) 실행을 보장합니다. 스크립트를 실행하는 동안 전체 런타임 중에 모든 서버의 명령이 차단됩니다.</p>

<p>간단한 LUA 스크립트를 작성하여 어떻게 문제를 해결할 수 있는지 보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">local </span>rank <span class="o">=</span> redis.call<span class="o">(</span><span class="s1">'zrank'</span>, KEYS[1], KEYS[2]<span class="o">)</span>
<span class="nb">local </span>min <span class="o">=</span> math.max<span class="o">(</span>rank - ARGV[1], 0<span class="o">)</span>
<span class="nb">local </span>max <span class="o">=</span> rank + ARGV[1]
<span class="nb">local </span>ldb <span class="o">=</span> redis.call<span class="o">(</span><span class="s1">'zrange'</span>, KEYS[1], min, max<span class="o">)</span>
<span class="nb">local </span>results <span class="o">=</span> <span class="o">{}</span>

results[<span class="s1">'rank'</span><span class="o">]</span> <span class="o">=</span> tostring<span class="o">(</span>rank + 1<span class="o">)</span>
results[<span class="s1">'item'</span><span class="o">]</span> <span class="o">=</span> ldb

<span class="nb">local </span>vars <span class="o">=</span> cjson.encode<span class="o">(</span>results<span class="o">)</span>
<span class="k">return </span>vars
</code></pre></div></div>

<p>| member | score | rank |
— — — — — — — — — — —
| member_1 | 50 | 1 |
| member_2 | 50 | 1 |
| member_3 | 30 | 3 |
| member_4 | 30 | 3 |
| member_5 | 10 | 5 |</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; zadd test-leaderboard 9 user1
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zadd test-leaderboard 5 user2
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zadd test-leaderboard 5 user3
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zadd test-leaderboard 3 user4
<span class="o">(</span>integer<span class="o">)</span> 1

127.0.0.1:6379&gt; zrank test-leaderboard user2
<span class="o">(</span>integer<span class="o">)</span> 1
127.0.0.1:6379&gt; zrank test-leaderboard user3
<span class="o">(</span>integer<span class="o">)</span> 2

127.0.0.1:6379&gt; ZSCORE test-leaderboard user3
<span class="s2">"5"</span>
127.0.0.1:6379&gt; ZRANGEBYSCORE test-leaderboard 5 5 LIMIT 0 1
1<span class="o">)</span> <span class="s2">"user2"</span>
127.0.0.1:6379&gt; ZRANK test-leaderboard user2
<span class="o">(</span>integer<span class="o">)</span> 1

127.0.0.1:6379&gt; ZADD test-leaderboard 5 user2
127.0.0.1:6379&gt; ZADD test-ranks 5 5

EVAL <span class="s2">"local score = redis.call('ZSCORE', KEYS[1], ARGV[1]) </span><span class="se">\n</span><span class="s2"> return redis.call('ZRANK', KEYS[2], score)"</span> 2 test-leaderboard test-ranks user2
<span class="o">(</span>integer<span class="o">)</span> 1
</code></pre></div></div>

<p>스크립트를 한 줄로 보면</p>]]></content><author><name>Jaeguk Yun</name></author><category term="cache" /><category term="redis" /><category term="jupyter" /><summary type="html"><![CDATA[LUA 스크립팅의 효율적인 방법으로 수행 할 수 있는 사례에 사용될 수 사례를 살펴봅니다. 여기에는 Redis zset에 유지되는 리더 보드가 있으며, 현재 사용 사례를 위해 주어진 사용자의 경우 해당 사용자의 순위와 리더 보드에서 사용자의 주변의 rank를 얻을 수도 있습니다.]]></summary></entry></feed>