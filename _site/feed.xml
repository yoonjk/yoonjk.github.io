<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-16T05:01:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">kind 에 dashboard 설치하기</title><link href="http://localhost:4000/kubernetes/install-dashboard-for-kind/" rel="alternate" type="text/html" title="kind 에 dashboard 설치하기" /><published>2023-02-15T00:00:00+09:00</published><updated>2023-02-15T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/install%20dashboard%20for%20kind</id><content type="html" xml:base="http://localhost:4000/kubernetes/install-dashboard-for-kind/"><![CDATA[<h2 id="dashboard-설치">Dashboard 설치</h2>
<p>kind를 사용하여 Kubernetes cluster를 구성하고 dashboard를 구성합니다.
dashboard는 다음과 같이 remote에 있는 yaml을 직접적용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml
</code></pre></div></div>

<h2 id="port-forward로-port-오픈">port-forward로 port 오픈</h2>
<p>port-forward를 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward svc/kubernetes-dashboard <span class="nt">-n</span> kubernetes-dashboard  443 <span class="nt">--address</span> 0.0.0.0
</code></pre></div></div>
<p><img src="/assets/images/k8s/03-k8s-yourconnection-is-not-private.png" alt="port-forward" /></p>

<p><img src="/assets/images/k8s/04-k8s-kubernetes-dashboard.png" alt="port-forward" /></p>

<h2 id="create-serviceaccount-and-role-token">Create serviceaccount and role, token</h2>
<p>kubernetes dashboard를 위한 serviceaccount와 cluster-role를 생성한 다음 token을 생성합니다. 그리고 생성한 token 값을 
dashboard login token 입력항목에 붙여넣기를 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create sa dashboard-admin <span class="nt">-n</span> kubernetes-dashboard
kubectl create clusterrolebinding dashbaord-admin <span class="nt">--clusterrole</span> admin <span class="nt">--serviceaccount</span> kubernetes-dashboard:dashboard-admin
kubectl create token dashboard-admin <span class="nt">-n</span> kubernetes-dashboard

<span class="o">[</span>수행결과]
eyJhbGciOiJSUzI1NiIsImtpZCI6IjcxeDlkdFlKOVhLZjRXOFdfNzVmLTZpUFVLOUtvQVM5M0RUMlMxcVBtblEifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc2NDkzNzA3LCJpYXQiOjE2NzY0OTAxMDcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJkYXNoYm9hcmQtYWRtaW4iLCJ1aWQiOiIwNDdlM2RjYS03N2JiLTRmYzMtYTkzZS0yMjAwNWNkZDBkOWYifX0sIm5iZiI6MTY3NjQ5MDEwNywic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.uDhrySLj1sZgsRovMS7TqT4DuTipdhaa2n1uKDLnfGq_-JNwQma7S0qOuLY20FAXfIGceax_k_LY5js0SP0GFWHSrw8m2S2jOEeDXkcvEkBQVDXi5DY-bp6p_y2dI4CleUxauFgPXOwXTOu8Un1fOfgltMCvGBcf68qPjZ1pxrni5_HlPi_o9xjhmfbggUxEq8zx0n2H5j0ssVITM7jH38F6eO7rMPVHRBngMok2qqOydviQZ0994TPgq_NByKkWDk1npCXOvrt03z9X6I7Q5-k6yX8vVEZSKq9rbq0lAJQLKlpKlttTHz6YJf0YEQwgygcakDxKCRsCk07kgEXP2Q
</code></pre></div></div>
<p>token을 입력합니다.<br />
<img src="/assets/images/k8s/05-k8s-input-token-dashboard.png" alt="port-forward" /></p>

<p>dashboard 로그인 화면입니다.<br />
<img src="/assets/images/k8s/06-k8s-dashboard-login.png" alt="port-forward" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="kind" /><summary type="html"><![CDATA[Dashboard 설치 kind를 사용하여 Kubernetes cluster를 구성하고 dashboard를 구성합니다. dashboard는 다음과 같이 remote에 있는 yaml을 직접적용합니다. kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml]]></summary></entry><entry><title type="html">Nginx proxy 리모트 kind cluster 접근</title><link href="http://localhost:4000/kubernetes/access-a-remote-kind/" rel="alternate" type="text/html" title="Nginx proxy 리모트 kind cluster 접근" /><published>2023-02-15T00:00:00+09:00</published><updated>2023-02-15T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/access-a-remote-kind</id><content type="html" xml:base="http://localhost:4000/kubernetes/access-a-remote-kind/"><![CDATA[<h2 id="사전설치환경-구성">사전설치환경 구성</h2>
<p>kind를 구성하기 위해 docker를 설치합니다. docker engine 설치  blog posting을 확인하세요.</p>

<h2 id="setup--on-kind-cluster-server">Setup  on kind cluster server</h2>
<p>kind 로컬 머신에 VM을 생성하고 하나의 노드만 포함하는 경량의 클러스터를 배포하는 쿠버네티스 입니다. kind는 Linux, macOS 및 Windows 시스템에서 사용할 수 있습니다.</p>

<p>Kind가 작동하려면 하이퍼바이저(버추얼 박스 또는 KVM)가 필요하지만 이미 가상 머신 내부에 있는 경우 none 드라이버를 사용하여 추가 VM 계층 생성을 건너뛸 수 있습니다<br />
이번에는 VM에 Docker 엔진을 설치하고, 가상화 대신 도커를 사용하여 local server에서 remote kind cluster에 접근하는 구성합니다.</p>

<p>docker를 성공적으로 설치한 후 다음 명령을 사용하여 로컬 Kubernetes를 시작할 차례입니다.</p>

<p><a href="https://kind.sigs.k8s.io/docs/user/quick-start/">kind Quick 설치 가이드</a></p>

<p>Linux 환경에서 설치</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-Lo</span> ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64
<span class="nb">chmod</span> +x ./kind
<span class="nb">sudo mv</span> ./kind /usr/local/bin/kind
</code></pre></div></div>

<p>kind를 시작하기 위해 kind cluster config 파일을 다음과 같이 control-plane, 2개의 worker node로 구성된 cluster를 작성합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">Cluster</span>
<span class="na">networking</span><span class="pi">:</span>
  <span class="na">apiServerAddress</span><span class="pi">:</span> <span class="s2">"</span><span class="s">119.81.103.70"</span>
  <span class="na">apiServerPort</span><span class="pi">:</span> <span class="m">58350</span>
<span class="na">nodes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">control-plane</span>
  <span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
  <span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
</code></pre></div></div>

<p>kind cluster를 작성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kind create cluster <span class="nt">--config</span> jenkins-config.yaml
</code></pre></div></div>

<p>원격 호스트에서 실행되는 Kubernetes 클러스터가 있습니다. Kind는 홈 디렉토리의 .kube/ 디렉토리 안에 config 파일을 생성합니다.</p>

<p>kubernetes의 config 파일에는 다음의 내용이 있습니다.<br />
•	certificate-authority(인증 기관) - 사용자가 제어하는 CA(인증 기관)에서 서명한 TLS 인증서를 프로비저닝할 수 있는 API를 제공합니다. 이러한 CA 및 인증서는 워크로드에서 신뢰를 설정하는 데 사용할 수 있습니다.<br />
•	server - 파드, 서비스, 복제 컨트롤러 등을 포함하는 API 객체에 대한 데이터의 유효성을 검사하고 구성하는 쿠버네티스 API 서버의 주소이다.<br />
•	client-certificate -.쿠버네티스/미니큐브는 TLS를 통한 인증을 위해 PKI 인증서가 필요하다.<br />
•	client-key - 클라이언트 인증서와 일치하는 키입니다.</p>

<p>.kube/config에 들어있는 인증서 내용을 x509 형식으로 변환합니다.</p>
<ul>
  <li>client-certificate-data 데이터를 base64로 decoding</li>
  <li>client-key-data 데이터를 base64로 decode</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">cat</span> .kube/config

<span class="nv">client_certificate</span><span class="o">=</span><span class="nv">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURJVENDQWdtZ0F3SUJBZ0lJYnFFNXUyM0ZYRE13RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2EzVmlaWEp1WlhSbGN6QWVGdzB5TXpBeU1UUXhNakkyTXpOYUZ3MHlOREF5TVRReE1qSTJNelZhTURReApGekFWQmdOVkJBb1REbk41YzNSbGJUcHRZWE4wWlhKek1Sa3dGd1lEVlFRREV4QnJkV0psY201bGRHVnpMV0ZrCmJXbHVNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXRYNnZTcHZPclo4S0cvbWwKZHdZTEcyNWVWNEJzTndWMFFOQVFiWmMyYWd6eDNHOEVBVEh2QUpKcmVUZkIzQmlRUTlqa2xVUVlQL1ByaFI3TgpJMjczbGkrdHE5dGZRUlczN3c4UE44Q0J1dmRVRDNPNUNWaHNDdG5ITXJyVXZJR2xWOXNGNTVHdkVRNklsVitDCnVGdGhnTm9YaWNIaWFiR081bnZ4Y3BoWjJXL0h6SU5CYXJhMEVPdW5wMENpNlMwUHZURjZ2RHRYQXlqTklVR3gKOW8xQ3VjWmw4TU16QW11TWF2eFBBKzBrWUlJMmw0RTlZMDFIdGVZdzBLUHVHK1ZDUDVRREE4TlNDb25mWDZ6ZwpabG5xRGVDMjBGUTV0QjBlbTJQL2tIc3llSTJnaWV1dDNibTdaVm5YWGROLyswbjNhNW9iMHNhaThvMzVNZDlNCnZPT1lnUUlEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JUY1dOUTRMN2ZGcThkN0RyUnBuTXpWbzRGbwptREFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBYzAycWNiRE9XcjRVbENZeFZPSys3cFVCc0ZyK0JIb2tic01jCmVlOXpZT05aRGNaY0VnYm5IeE95ZCt3L0oweVNScyt4aUpDNFRRRHMyU0FydVoxZnZQOFRzQ3I5ZTBrU2JPcEMKT0NrYTJIazlFV3h5eTIvd20xRVRZbXo5UEh3RWtRUytSQkRxNXJGMjMyMXpqZzQybURsU2R3SHB0QnRHNmJQYgp0d1lHY2tHcnJxVElBa0tGZlhBV1JCZWRuVi80S0M2TWg0ZkRVaFdQNjhVWmdyUU9KWENWUFAyc1B2Z3djMmQwCmFYaVF5NWh6b3NpWTdFOCswaHIwK0xpMXVtS3JjeHNGWGdjL01zTW1XbUtJMkR2Y2dManFpNDRSRlNvclV4TzYKWGVJQ0NvMnNMeHl5SFB5NUhjeXRVZTkxSFd4V2p6NDcyK3c1dDJ2MFAzWXY4UGRGQ1E9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg</span><span class="o">==</span>
<span class="nv">client_key</span><span class="o">=</span><span class="nv">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb2dJQkFBS0NBUUVBdFg2dlNwdk9yWjhLRy9tbGR3WUxHMjVlVjRCc053VjBRTkFRYlpjMmFnengzRzhFCkFUSHZBSkpyZVRmQjNCaVFROWprbFVRWVAvUHJoUjdOSTI3M2xpK3RxOXRmUVJXMzd3OFBOOENCdXZkVUQzTzUKQ1Zoc0N0bkhNcnJVdklHbFY5c0Y1NUd2RVE2SWxWK0N1RnRoZ05vWGljSGlhYkdPNW52eGNwaFoyVy9IeklOQgphcmEwRU91bnAwQ2k2UzBQdlRGNnZEdFhBeWpOSVVHeDlvMUN1Y1psOE1NekFtdU1hdnhQQSswa1lJSTJsNEU5ClkwMUh0ZVl3MEtQdUcrVkNQNVFEQThOU0NvbmZYNnpnWmxucURlQzIwRlE1dEIwZW0yUC9rSHN5ZUkyZ2lldXQKM2JtN1pWblhYZE4vKzBuM2E1b2Iwc2FpOG8zNU1kOU12T09ZZ1FJREFRQUJBb0lCQUh5RFFmejhjVWs1bjdUYgppMEhodW9NQ0wrVDE3TWUralNmZDFqZHBFdUtrcU5VaXNHdWxkeU04VUZFa0NISlh3N2xZTmxHVkd0SGRKSW42ClBKLy9oQW5jQWRpeU1tSXpaVEd6Y2l3OGZJUHBKQmxKdWZzSVYyOEdReHV4Z3pzajhtd1lqYTkxaWRZNDAwa3UKOGo1S0t0VThTZ092S1FaNzB0NmF6MlZmMGR4U0kxaXA0VHBxM3pMVXRGSkt1dWJnYThKYmpsQ01jaGVvUUxYVQorT0ZzR1llU0VZK0g4NXltNFRUZGZSUGNsbjdONDJnc2M5UGlYaEx0N1U2OWNKdXdHVEM3NDF1QjNGYnVMQmJvCkRYalBKeTFJK1VpTWRkN0hmcThwSnppVzdQMXlId3dRU2ZqUG1XMzFYYzBoYVk1clBUbmpDY2Q1UkNJRzVWNXAKUkF3NmJjVUNnWUVBd3pXWVZyTWg1bFNjNGgySWdNWGh0S3FleFZxOXFEZE44eXowa3dPMnpLd3E3eUV3R0U4Wgp6cU1ENjk2RFBrditnU1krbTI1M1FIVDhJZG1LcTNzdG9SOEhIZXNOV2lzZTJGSGMxMzVRT1NWUFFaNmV6d1p0ClBsL3lrM2VJM0hIWEUyZEZNRWk0N0NoVWtpRHRZV1dVZDEyVEpHeGtMWTBJVmdFQjdsUEtKVGNDZ1lFQTdnTy8KZzNKUXVZd0dUak45NFBVTUd1cHlhTWx6UEpiSlZ6MmZWMkl1T2R3a1FlbHI4bktJUE50Nm9rS2JtUjFQSzYrSwpSYmJybU1aTnNYM2JGOWFHamhhRWRNV3dIRFRKMFhhVzdlVkxxbHVyQUxPR0NxM2lYRU5CZ3lMWTY5UWZjaURsCkRkaUx0WC9GTzcvSUY0OUEyOHIvZmdoK1FoQ3BQby9yWTl0U0RBY0NnWUJiVE9uZlF4RUw1VzhxNHAxQmZVdS8KY0QycUdISzBCb25TdnFmMVNydG9wdTI5d2t2NFVxYkRXc011d25lbjMyczloR0dyMk5LMXR3Rmw0NVZUOXR5MAppd3FORjY2N0NZZjNyUElaWjk2bG02bWlDMHBEa2NIdWRubkNOeG92NEo2eldJMm5zNXVwK0lMMWhha0E4TDJyCnhueFhnTXFwODFoK3dTSGlFaFp0cVFLQmdDRE5VMitDS2Ezb3BsWFFzdUIxNVIwd2dtUCtuMnNTUE4xUkdNeXEKTTBTMkdpa2JTazAzaTU4WGdHY3NWdFZiUExZQWswWFlWOC9PUkpiWmlZQlhpR084cHJTUktodzVDamRiNktFUQpvTVR4clRlRGhrMmllVGZON1JGdGxBZXNURWttVDJzQkZRQUdnK0FnSml0WkNzOC93c1pUMVZLMWlSMmVLQXF6CkJ6T3hBb0dBVEk0NlNoby8rV0N4d3VNUmZJSHMrU2luZEh6NTUwOVBlTmg4ejdEYnVuNzlXZi9CQ0VVdkNaeW8KV1dUck1kSmh5NTNXUjhBb2hTSy9YTGxWU0U5WTN3K2VteWw5aEU1bmtiNjBIN0M4YWkyUGpsVXBIZzBXR0Y0egpRWmQ3d21RNi9QOHVxS0ZEcnVkcSs4YmRON1dhNWFtZ1pUMy9YdHRWWGlXdHNRUzVYRzQ9Ci0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg</span><span class="o">==</span>

<span class="c"># convert encoded certificates to x509 format</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kind
<span class="nb">echo</span> <span class="nv">$client_certificate</span> | <span class="nb">base64</span> <span class="nt">-d</span> <span class="o">&gt;</span> .kind/client.crt
<span class="nb">echo</span> <span class="nv">$client_certificate</span> | <span class="nb">base64</span> <span class="nt">-d</span> <span class="o">&gt;</span> .kind/client.key

</code></pre></div></div>
<h2 id="install-nginx-for-reverse-proxy-on--kind-cluster-server">Install nginx for Reverse Proxy on  Kind Cluster server</h2>
<p>리모트에서 Kind에 접근하기 위해 reverse proxy를 구성합니다.</p>

<p>미니큐브 앞에 Nginx Reverse 프록시를 배포합니다.</p>

<p>쿠버네티스 API 서버는 커맨드 라인 도구 kubectl을 사용할 때 모든 요청이 전달되는 지점입니다. kubectl을 사용하면 쿠버네티스 클러스터에 대해 명령을 실행할 수 있다. 이 예에서 내 kube-apiserver의 주소는 https://Your-ServierIP:58350 Kind의 IP 주소입니다. Kind는 로컬에서만 액세스할 수 있으나, 원격으로 액세스할 수 없습니다. 이러한 이유로 Kind 옆에 Nginx 역방향 프록시를 배포하여 원격 클라이언트의 요청을 수신한 다음 kube-apiserver로 전달할 수 있도록 해야 합니다.</p>

<p>docker를 통해 배포하므로 마운트에 필요한 디렉토리와 파일을 만들어야합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/nginx/conf.d/ /etc/nginx/certs
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/nginx/conf.d/default.conf 
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;
    auth_basic "Administrator's Area";
    auth_basic_user_file /etc/nginx/.htpasswd;

    location / {
        proxy_pass https://Your-Kind-ServerIP:58350;
        proxy_ssl_certificate /etc/nginx/certs/kind-client.crt;
        proxy_ssl_certificate_key /etc/nginx/certs/kind-client.key;
    }
}
</span><span class="no">EOF
</span></code></pre></div></div>

<p>아직 사용자 이름/암호 쌍을 만들지 않았습니다. 이를 위해 htpasswd라는 cmd 도구를 사용합니다<br />
. 아직 설치하지 않은 경우 yum 을 통해 설치하십시오.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> httpd-tools 
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd kind-kind
</code></pre></div></div>

<p>Ubuntu 환경인 경우 htpasswd 유틸 설치</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get <span class="nb">install </span>apache2-utils <span class="nt">-y</span>
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd kind-kind
</code></pre></div></div>
<p>이제 사용자이름/암호가 /etc/nginx/.htpasswd 파일에 저장됩니다. 필요한 구성 파일이 이미 있으므로 다음 명령을 사용하여 Nginx를 배포 할 준비가 되었습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="se">\</span>
<span class="nt">--name</span> nginx <span class="se">\</span>
<span class="nt">--network</span> kind <span class="se">\</span>
<span class="nt">-p</span> 9080:80 <span class="se">\</span>
<span class="nt">-v</span> /root/.kind/client.key:/etc/nginx/certs/kind-client.key <span class="se">\</span>
<span class="nt">-v</span> /root/.kind/client.crt:/etc/nginx/certs/kind-client.crt <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/conf.d/:/etc/nginx/conf.d <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/.htpasswd:/etc/nginx/.htpasswd <span class="se">\</span>
nginx
</code></pre></div></div>

<p>브라우저에서 Nginx에 요청하려고 하면 사용자 이름과 비밀번호가 필요하다는 다음 팝업 창이 나타납니다. 브라우저에서 페이지를 열려면 다음 주소로 이동하십시오</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;YOUR_SERVER_IP&gt;:9080  
</code></pre></div></div>

<h2 id="install-kubectl-on-local-computer">Install kubectl on local computer</h2>

<p>Kind에 접속할려는 서버에 kubectl 를 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>curl <span class="nt">-L</span> <span class="s2">"https://dl.k8s.io/release/</span><span class="si">$(</span>curl <span class="nt">-L</span> <span class="nt">-s</span> https://dl.k8s.io/release/stable.txt<span class="si">)</span><span class="s2">/bin/linux/amd64/kubectl"</span> <span class="nt">-o</span> /usr/local/bin/kubectl

<span class="nb">sudo chmod</span> +x /usr/local/bin/kubectl
</code></pre></div></div>

<p>이미 kubectl이 설치되어 있으므로이 단계를 건너 뜁니다.<br />
이제 미니큐브에 대한 kubectl을 구성해야 한다. 원격 호스트에서 구성 파일의 내용을 복사하고(Img.3 참조) 로컬 server 붙여넣습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.kube/  <span class="c"># execute on local computer</span>
</code></pre></div></div>

<p>아래 이미지에는 변경해야 할 강조 표시된 줄이 있습니다.<br />
remote 서버에 있는 config 파일을 복사하고 강조 표시된 부분을 수정합니다.<br />
ENTER_YOUR_PASSWORD_HERE : remote 서버에서 설정한 kind-kind 비밀번호<br />
YOUR_SERVER_IP : remote 서버<br />
•	certificate-authority , client-certificate , and client-key</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://kind-kind:&lt;ENTER_YOUR_PASSWORD_HERE&gt;@&lt;YOUR_SERVER_IP&gt;:9080
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF &gt; .kube/config</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">clusters</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">cluster</span><span class="pi">:</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">http://kind-kind:admin1234@@119.81.103.70:9080</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kind-kind</span>
<span class="na">contexts</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">context</span><span class="pi">:</span>
    <span class="na">cluster</span><span class="pi">:</span> <span class="s">kind-kind</span>
    <span class="na">user</span><span class="pi">:</span> <span class="s">kind-kind</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">kind-kind</span>
<span class="na">current-context</span><span class="pi">:</span> <span class="s">kind-kind</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Config</span>
<span class="na">preferences</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">users</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">kind-kind</span>
  <span class="na">user</span><span class="pi">:</span>
<span class="s">EOF</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="kind" /><summary type="html"><![CDATA[사전설치환경 구성 kind를 구성하기 위해 docker를 설치합니다. docker engine 설치 blog posting을 확인하세요.]]></summary></entry><entry><title type="html">Install kind for Jenkins</title><link href="http://localhost:4000/kubernetes/install-kind/" rel="alternate" type="text/html" title="Install kind for Jenkins" /><published>2023-02-12T00:00:00+09:00</published><updated>2023-02-12T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/install-kind</id><content type="html" xml:base="http://localhost:4000/kubernetes/install-kind/"><![CDATA[<h2 id="pre-requisites--install-docker-engine">Pre-requisites : Install docker engine</h2>
<p>docker engine 설치는 docker engine 설치 글을 참조해 주세요.</p>

<h2 id="step-1--download-kind-binary">Step 1 : Download kind binary</h2>
<p>kind binary를 download 받습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-Lo</span> ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64
<span class="nb">chmod</span> +x ./kind
<span class="nb">sudo mv</span> ./kind /usr/local/bin/kind
</code></pre></div></div>

<h2 id="step-2--config-파일-작성성">Step 2 : config 파일 작성성</h2>

<p>Kind를 이용하여 Kubernetes Cluster를 생성하기 위해 jenkins-config.yaml 파일을 아래와 같이 작성합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kind.x-k8s.io/v1alpha4</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Cluster</span>
<span class="na">nodes</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">control-plane</span>
<span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
<span class="pi">-</span> <span class="na">role</span><span class="pi">:</span> <span class="s">worker</span>
</code></pre></div></div>

<h2 id="step-3--create-cluster">Step 3 : Create Cluster</h2>
<p>Cluster를 생성합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kind create cluster <span class="nt">--config</span> jenkins-config.yaml
</code></pre></div></div>
<h2 id="step-4--configure">Step 4 : Configure</h2>
<p>Kind는 .kube/config파일 변경 없이 인증서 파일의 내용이 config파일에 있어서 변환할 필요는 없습니다.<br />
minikube와 동일하게 Jenkins를 설정합니다.</p>
<ul>
  <li>Install Kubernetes Plugins</li>
  <li>Manage Jenkins &gt; Manage Nodes and Clouds &gt; Configure Clouds</li>
</ul>

<h2 id="step-4--kubernetes-dashboard-설치">Step 4 : Kubernetes Dashboard 설치</h2>

<p>Kubernetes dashboard yaml파일을 remote에 있는 것을 직접 kubernetes cluster에 적용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml
</code></pre></div></div>

<h2 id="step-5--kubernetes-dashboard-접속">Step 5 : Kubernetes Dashboard 접속</h2>
<p>kubectl proxy로 8001 port를 다음과 같이 오픈합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward svc/kubernetes-dashboard <span class="nt">-n</span> kubernetes-dashboard 443:443 <span class="nt">--address</span> 0.0.0.0
</code></pre></div></div>

<p>브라우저에서 dashboard에 접속합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://Your-Server-IP/
</code></pre></div></div>

<p><img src="/assets/images/k8s/04-k8s-kubernetes-dashboard.png" alt="kube-dashboard" /></p>

<h2 id="step-6--token-생성">Step 6 : Token 생성</h2>
<ul>
  <li>kubernetes-dashboard namespace에 admin-user Serviceaccount를 생성
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create sa admin-user <span class="nt">-n</span> kubernetes-dashboard
</code></pre></div>    </div>
  </li>
  <li>cluster-admin을 clusterrolebinding합니다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create clusterrolebinding admin <span class="nt">--clusterrole</span> cluster-admin <span class="nt">--serviceaccount</span> kubernetes-dashboard:admin-user
</code></pre></div>    </div>
  </li>
  <li>token을 생성
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create token admin-user <span class="nt">-n</span> kuberneetes-dashboard
<span class="c"># [수행결과] </span>
eyJhbGciOiJSUzI1NiIsImtpZCI6ImgxSUxfYzA4Zk54TFdRNF9pdDY3VFgtall1N1M5b1BPMFp2c3JXRVFodFUifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc2Mjk2MDE3LCJpYXQiOjE2NzYyOTI0MTcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiNTAwNGUwMDYtMTNjYy00YWYwLWE2MWEtZjFmYWJiMjczNzBhIn19LCJuYmYiOjE2NzYyOTI0MTcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.AVfEFQBnSHW4DQR3Iyf15-BRMDdIAloSkC1BGpUaK-gLVHt-5EB72EK9XX1TK675-DClXEHbNTgEHey_ViP68JPTr99B3mRLy5KXD8gOxjueRMSvQbHo-le85j-DwIOu3TfE9Zyo7NlkGVglU61IBylIfZbg7Sh1TeYpoD6qmTAub6EVWMw1m5OGThBRd7Da6WMd1nI0MMlrT8hGUkCPml3F-x4ExNETjukTfhQTbz0HwRg-jVkad9QwFuCN9_uGuUvw4QUPeZ04hdccADP7fwbd7r4U0Jx2YANVZYNefbmSRl3M4s_Lu5aVxZ4PdcTFR04yiZBQ1C911lluT6hOGw
</code></pre></div>    </div>
  </li>
</ul>

<p>생성한 token을 dashboard token 입력항목에 붙여넣기 합니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="kind" /><summary type="html"><![CDATA[Pre-requisites : Install docker engine docker engine 설치는 docker engine 설치 글을 참조해 주세요.]]></summary></entry><entry><title type="html">Nginx proxy로 리모트 Minikube 연결</title><link href="http://localhost:4000/kubernetes/access-a-remote-minikube/" rel="alternate" type="text/html" title="Nginx proxy로 리모트 Minikube 연결" /><published>2023-02-11T00:00:00+09:00</published><updated>2023-02-11T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/access-a-remote-minikube</id><content type="html" xml:base="http://localhost:4000/kubernetes/access-a-remote-minikube/"><![CDATA[<h2 id="setup-minikube-on-minikube-server">Setup Minikube on minikube server</h2>

<p>Minikube는 로컬 머신에 VM을 생성하고 하나의 노드만 포함하는 경량의 클러스터를 배포하는 쿠버네티스 입니다. Minikube는 Linux, macOS 및 Windows 시스템에서 사용할 수 있습니다.</p>

<p>Minikube가 작동하려면 하이퍼바이저(버추얼 박스 또는 KVM)가 필요하지만 이미 가상 머신 내부에 있는 경우 none 드라이버를 사용하여 추가 VM 계층 생성을 건너뛸 수 있습니다<br />
이 경우  해당 VM에 Docker 엔진을 설치해야 합니다. 이는 가상화 대신 도커를 사용한다는 의미입니다 (버추얼 박스, VM웨어 퓨전, kvm2, VM웨어 등).</p>

<p>docker를 성공적으로 설치한 후 다음 명령을 사용하여 로컬 Kubernetes를 시작할 차례입니다.</p>

<p><img src="/assets/images/k8s/01-k8s-download-minikube.png" alt="download-minikube" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>curl <span class="nt">-LO</span> https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
<span class="nb">install </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="c"># 또는</span>
<span class="nb">sudo mv </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="nb">sudo chmod</span> +x /usr/local/bin/minikube
</code></pre></div></div>

<p>minikube를 시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube start <span class="nt">--driver</span><span class="o">=</span>docker
</code></pre></div></div>

<p>원격 호스트에서 실행되는 Kubernetes 클러스터가 있습니다. Minikube는 홈 디렉토리의 .kube/ 디렉토리 안에 config 파일을 생성합니다.</p>

<p>kubernetes의 config 파일에는 다음의 내용이 있습니다.<br />
•	certificate-authority(인증 기관) - 사용자가 제어하는 CA(인증 기관)에서 서명한 TLS 인증서를 프로비저닝할 수 있는 API를 제공합니다. 이러한 CA 및 인증서는 워크로드에서 신뢰를 설정하는 데 사용할 수 있습니다.<br />
•	server - 파드, 서비스, 복제 컨트롤러 등을 포함하는 API 객체에 대한 데이터의 유효성을 검사하고 구성하는 쿠버네티스 API 서버의 주소이다.<br />
•	client-certificate -.쿠버네티스/미니큐브는 TLS를 통한 인증을 위해 PKI 인증서가 필요하다.<br />
•	client-key - 클라이언트 인증서와 일치하는 키입니다.</p>

<p><img src="/assets/images/k8s/02-k8s-cat-kube-config.png" alt="start-minikube" /></p>

<h2 id="install-nginx-for-reverse-proxy-on-minikube-server">Install nginx for Reverse Proxy on minikube server</h2>
<p>리모트에서 minikube에 접근하기 위해 reverse proxy를 구성합니다.</p>

<p>미니큐브 앞에 Nginx Reverse 프록시를 배포합니다.</p>

<p>쿠버네티스 API 서버는 커맨드 라인 도구 kubectl을 사용할 때 모든 요청이 전달되는 지점입니다. kubectl을 사용하면 쿠버네티스 클러스터에 대해 명령을 실행할 수 있다. 이 예에서 내 kube-apiserver의 주소는 https://10.142.0.17:8443 여기서 10.142.0.17은  minikube의 IP 주소입니다. minikube는 로컬에서만 액세스할 수 있으나, 원격으로 액세스할 수 없습니다. 이러한 이유로 minikube 옆에 Nginx 역방향 프록시를 배포하여 원격 클라이언트의 요청을 수신한 다음 kube-apiserver로 전달할 수 있도록 해야 합니다.</p>

<p>docker를 통해 배포하므로 마운트에 필요한 디렉토리와 파일을 만들어야합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/nginx/conf.d/ /etc/nginx/certs
<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/nginx/conf.d/minikube.conf 
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;
    auth_basic "Administrator’s Area";
    auth_basic_user_file /etc/nginx/.htpasswd;    
    
    location / {   
        proxy_pass https://`minikube ip`:8443;
        proxy_ssl_certificate /etc/nginx/certs/minikube-client.crt;
        proxy_ssl_certificate_key /etc/nginx/certs/minikube-client.key;
    }
}
</span><span class="no">EOF
</span></code></pre></div></div>

<p>아직 사용자 이름/암호 쌍을 만들지 않았습니다. 이를 위해 htpasswd라는 cmd 도구를 사용합니다<br />
. 아직 설치하지 않은 경우 yum 을 통해 설치하십시오.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> httpd-tools 
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd minikube
</code></pre></div></div>

<p>Ubuntu 환경인 경우 htpasswd 유틸 설치</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get <span class="nb">install </span>apache2-utils <span class="nt">-y</span>
htpasswd <span class="nt">-c</span> /etc/nginx/.htpasswd minikube
</code></pre></div></div>
<p>이제 사용자이름/암호가 /etc/nginx/.htpasswd 파일에 저장됩니다. 필요한 구성 파일이 이미 있으므로 다음 명령을 사용하여 Nginx를 배포 할 준비가 되었습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="se">\</span>
<span class="nt">--name</span> nginx <span class="se">\</span>
<span class="nt">--network</span> minikube <span class="se">\</span>
<span class="nt">-p</span> 9080:80 <span class="se">\</span>
<span class="nt">-v</span> /root/.minikube/profiles/minikube/client.key:/etc/nginx/certs/minikube-client.key <span class="se">\</span>
<span class="nt">-v</span> /root/.minikube/profiles/minikube/client.crt:/etc/nginx/certs/minikube-client.crt <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/conf.d/:/etc/nginx/conf.d <span class="se">\</span>
<span class="nt">-v</span> /etc/nginx/.htpasswd:/etc/nginx/.htpasswd <span class="se">\</span>
nginx
</code></pre></div></div>

<p>브라우저에서 Nginx에 요청하려고 하면 사용자 이름과 비밀번호가 필요하다는 다음 팝업 창이 나타납니다. 브라우저에서 페이지를 열려면 다음 주소로 이동하십시오</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://&lt;YOUR_SERVER_IP&gt;:9080  
</code></pre></div></div>

<h2 id="install-kubectl-on-local-computer">Install kubectl on local computer</h2>

<p>minikube에 접속할려는 서버에 kubectl 를 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>curl <span class="nt">-L</span> <span class="s2">"https://dl.k8s.io/release/</span><span class="si">$(</span>curl <span class="nt">-L</span> <span class="nt">-s</span> https://dl.k8s.io/release/stable.txt<span class="si">)</span><span class="s2">/bin/linux/amd64/kubectl"</span> <span class="nt">-o</span> /usr/local/bin/kubectl

<span class="nb">sudo chmod</span> +x /usr/local/bin/kubectl
</code></pre></div></div>

<p>이미 kubectl이 설치되어 있으므로이 단계를 건너 뜁니다.<br />
이제 미니큐브에 대한 kubectl을 구성해야 한다. 원격 호스트에서 구성 파일의 내용을 복사하고(Img.3 참조) 로컬 server 붙여넣습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.kube/  <span class="c"># execute on local computer</span>
</code></pre></div></div>

<p>아래 이미지에는 변경해야 할 강조 표시된 줄이 있습니다.<br />
remote 서버에 있는 config 파일을 복사하고 강조 표시된 부분을 수정합니다.<br />
ENTER_YOUR_PASSWORD_HERE : remote 서버에서 설정한 minikube 비밀번호<br />
YOUR_SERVER_IP : remote 서버<br />
•	certificate-authority , client-certificate , and client-key</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://minikube:&lt;ENTER_YOUR_PASSWORD_HERE&gt;@&lt;YOUR_SERVER_IP&gt;:9080
</code></pre></div></div>

<p><img src="/assets/images/k8s/03-k8s-local-kube-config.png" alt="kube-config-minikube" /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF &gt; .kube/config</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">clusters</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">cluster</span><span class="pi">:</span>
    <span class="na">extensions</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">extension</span><span class="pi">:</span>
        <span class="na">last-update</span><span class="pi">:</span> <span class="s">Fri, 20 Jan 2023 13:56:37 CST</span>
        <span class="na">provider</span><span class="pi">:</span> <span class="s">minikube.sigs.k8s.io</span>
        <span class="na">version</span><span class="pi">:</span> <span class="s">v1.28.0</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">cluster_info</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">http://minikube:ENTER_YOUR_PASSWORD_HERE@@YOUR_SERVER_IP:9080</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">minikube</span>
<span class="na">contexts</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">context</span><span class="pi">:</span>
    <span class="na">cluster</span><span class="pi">:</span> <span class="s">minikube</span>
    <span class="na">extensions</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">extension</span><span class="pi">:</span>
        <span class="na">last-update</span><span class="pi">:</span> <span class="s">Fri, 20 Jan 2023 13:56:37 CST</span>
        <span class="na">provider</span><span class="pi">:</span> <span class="s">minikube.sigs.k8s.io</span>
        <span class="na">version</span><span class="pi">:</span> <span class="s">v1.28.0</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">context_info</span>
    <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
    <span class="na">user</span><span class="pi">:</span> <span class="s">minikube</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">minikube</span>
<span class="na">current-context</span><span class="pi">:</span> <span class="s">minikube</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Config</span>
<span class="na">preferences</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">users</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">minikube</span>
  <span class="na">user</span><span class="pi">:</span>
<span class="s">EOF</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="kubernetes" /><category term="minikube" /><summary type="html"><![CDATA[Setup Minikube on minikube server]]></summary></entry><entry><title type="html">Tekton 설치</title><link href="http://localhost:4000/devops/tekton-installation/" rel="alternate" type="text/html" title="Tekton 설치" /><published>2023-02-05T00:00:00+09:00</published><updated>2023-02-05T00:00:00+09:00</updated><id>http://localhost:4000/devops/tekton-installation</id><content type="html" xml:base="http://localhost:4000/devops/tekton-installation/"><![CDATA[<h2 id="tekton-설치">Tekton 설치</h2>
<p>Tekton pipeline을 Kubernetes에 설치합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">--filename</span> https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
</code></pre></div></div>

<p>터미널 화면을 신규로 더 실행하여, 신규 터미널에서 tekton pipeline 설치를 확인하기 위해 다음의 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">--namespace</span> tekton-pipelines <span class="nt">-w</span>
</code></pre></div></div>
<h4 id="tekton-dashboard-설치">Tekton dashboard 설치</h4>

<p>tekton pipeline, task를 실행되는 WEB UI를 통해 보고자 하는 경우 tekton dashboard를 활용하여 현재 설치되어 있는 pipeline, task, 실행결과를 확인 할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">--filename</span> https://storage.googleapis.com/tekton-releases/dashboard/latest/release.yaml
</code></pre></div></div>

<p>tekton dashboard 설치를 확인하기 위해 다음의 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">--namespace</span> tekton-pipelines <span class="nt">-w</span>
</code></pre></div></div>

<p>Tekton pipeline 설치에 대해 자세한 것은 아래의 <a href="https://tekton.dev/docs/pipelines/install/">링크</a>를 확인하세요.</p>

<p><a href="https://tekton.dev/docs/pipelines/install/">https://tekton.dev/docs/pipelines/install/</a></p>

<p>Tekton dashboard 설치에 대해 자세한 것은 아래의 <a href="https://tekton.dev/docs/dashboard/install/">링크</a>를 확인하세요.</p>

<p><a href="https://tekton.dev/docs/dashboard/install/">https://tekton.dev/docs/dashboard/install/</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="tekton" /><summary type="html"><![CDATA[Tekton 설치 Tekton pipeline을 Kubernetes에 설치합니다.]]></summary></entry><entry><title type="html">Nexus를 docker container repository로 사용하기</title><link href="http://localhost:4000/devops/push-container-image-to-nexus/" rel="alternate" type="text/html" title="Nexus를 docker container repository로 사용하기" /><published>2023-02-04T00:00:00+09:00</published><updated>2023-02-04T00:00:00+09:00</updated><id>http://localhost:4000/devops/push%20container%20image%20to%20nexus</id><content type="html" xml:base="http://localhost:4000/devops/push-container-image-to-nexus/"><![CDATA[<h2 id="nexus를-docker-container-repository로-사용하기">Nexus를 docker container repository로 사용하기</h2>
<p>Nexus를 docker container image의 repository로 사용하는 위한 설정입니다.
Harbor 같은 전용 Docker container Registry로 사용하는 Open Source 솔루션도 있으나
애플리케이션 수가 몇개 되지 않는 것은 Nexus를 Container Image Repository로 사용할 수 있습니다.</p>

<p>Nexus 설치는 블로그 목록을 참고해 주시고, 설정이 끝나고 추가적으로 container Image Repository를 추가하는 부분만 소개합니다.</p>

<h2 id="step-1--docker-유형-repository-생성">Step 1 : docker 유형 Repository 생성</h2>
<p>create repository를 선택합니다.<br />
<img src="/assets/images/nexus/06-jenkins-nexus-create-repository.png" alt="nexus docker repository" /></p>

<p>Repository 유형중에 docker(hosted) repository를 선택합니다.<br />
<img src="/assets/images/nexus/07-jenkins-nexus-select-docker-repository.png" alt="nexus docker repository" /></p>

<p>docker-repo 이름으로 다음과 같이 정보를 선택하고 repository를 생성합니다.<br />
<img src="/assets/images/nexus/08-jenkins-nexus-docker-repository.png" alt="nexus docker repository" /></p>

<h2 id="step-2-add-docker-bearer-token-to-realms">Step 2: Add docker bearer token to Realms</h2>

<p>Realms 에 Docker Bearer token을 추가하고, 저장합니다.</p>

<p><img src="/assets/images/nexus/08-jenkins-nexus-realms-docker-bearer-token.png" alt="add realm" /></p>

<h2 id="step-2-podman-을-사용하여-nexus에-로그인">Step 2: podman 을 사용하여 nexus에 로그인</h2>

<p>Podman을 사용하여 http로 login 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nexus-server-ip : remote server ip 또는 localhost</span>
podman login <span class="nt">-u</span> deploy-user <span class="nt">-p</span> Passw0rd@ <span class="nt">--tls-verify</span><span class="o">=</span><span class="nb">false </span>nexus-server-ip:5000
</code></pre></div></div>

<p>Nexus 가 local에 있는 경우 nexus-server-id를 localhost로 지정합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>podman login <span class="nt">-u</span> deploy-user <span class="nt">-p</span> Passw0rd@ <span class="nt">--tls-verify</span><span class="o">=</span><span class="nb">false </span>localhost:5000
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="nexus" /><category term="podman" /><summary type="html"><![CDATA[Nexus를 docker container repository로 사용하기 Nexus를 docker container image의 repository로 사용하는 위한 설정입니다. Harbor 같은 전용 Docker container Registry로 사용하는 Open Source 솔루션도 있으나 애플리케이션 수가 몇개 되지 않는 것은 Nexus를 Container Image Repository로 사용할 수 있습니다.]]></summary></entry><entry><title type="html">Jenkins Pipeline 이란</title><link href="http://localhost:4000/devops/jenkins-pipeline/" rel="alternate" type="text/html" title="Jenkins Pipeline 이란" /><published>2023-02-04T00:00:00+09:00</published><updated>2023-02-04T00:00:00+09:00</updated><id>http://localhost:4000/devops/jenkins%20pipeline</id><content type="html" xml:base="http://localhost:4000/devops/jenkins-pipeline/"><![CDATA[<h2 id="jenkins-pipeline-이란">Jenkins Pipeline 이란</h2>
<p>Jenkins Pipeline이란 Jenkins를 사용하여 CD 파이프라인울 구현하고 통합하는 것을 지원하는 플러그인의 집합입니다.
Jenkins에 의해 정의된 모든 표준 Job을 하나의 script 작성되며 git 과 같은 repository 저장할 수 있습니다.
각 단계에 대해 여러 작업을 작성하는 대신 이제 전체 워크플로를 코딩하여 하나의 Jenkinsfile에 넣을 수 있습니다.
이러한 Pipeline을 작성하는 데에는 크게 두 가지, 선언적(Declarative) 구문 방식, 스크립팅(Scripted) 방식의 두 가지 유형의 구문을 사용하여 작성할 수 있습니다.</p>

<h4 id="declarative-pipeline">Declarative Pipeline</h4>
<p>선언적 파이프 라인은 Jenkins Pipeline에 비교적 최근에 추가 된 것으로, 파이프 라인 위에 보다 단순화되고 구조적인 구문을 제공합니다.
모든 유효한 선언적 파이프라인은 파이프라인 블록 내에 포함되어야 합니다.</p>

<p>•	agent
•	tools
•	options
•	environment
•	stages
o	stage
•	post</p>

<h2 id="pipeline-section">Pipeline section</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pipeline <span class="o">{</span>
    /<span class="k">*</span> insert Declarative Pipeline here <span class="k">*</span>/
<span class="o">}</span>
</code></pre></div></div>

<p>선언적 파이프라인에서 유효한 기본 문 및 식은 Groovy의 구문과 동일한 규칙을 따르지만 다음과 같은 예외가 있습니다.
•	파이프라인의 최상위 수준은 블록이어야 합니다: pipeline { }.
•	statement 구분 기호로 세미콜론이 없습니다. 각 문장은 한 줄에 있어야합니다.
•	선언 파이프라인의 섹션은 일반적으로 하나 이상의 지시사항( 순서, 지시문) 또는steps을 포함합니다.
•	속성 참조 문은 인수 없는 메서드 호출로 처리됩니다. 예를 들어, 입력은 input()으로 처리됩니다.</p>

<p>선언적 파이프라인에서는 지시문과 섹션 구성을 시작을 도와주기 위해 선언적 지시문 생성기를 사용하여 지원합니다.
현재 pipeline{} 블록 내에서 코드의 최대 크기를 제한하는 미해결 문제가 있습니다. 이 제한은 Scripted Pipeline에는 적용되지 않습니다.
선언적 파이프라인의 섹션에는 일반적으로 하나 이상의 지시문 또는 단계가 포함됩니다.</p>

<h4 id="declarative-pipeline--pipeline">Declarative Pipeline : pipeline</h4>
<p>Agent section은  선언형 Pipeline에서는 필수section 입니다.
Jenkins 환경에서 에이전트 섹션이 위치에 따라 전체 파이프라인 또는 특정 stage가 실행되는 위치에 지정할 수 있습니다.
agent가 최상위 부분에 위치할 때는 pipeline이 실행되는node가 됩니다. agent any는 사용가능한 node중에 random 하게 사용하겠다는 의미입니다. 또는 agent에 label을 지정하여 지정된 node에서  pipeline을 실행할 수 있도록 label을 지정할 수 있습니다.
agent none으로 지정한 경우 각 stage에서 agent를 설정하겠다는 의미입니다.
agent { docker …} 로 설정한 경우 pipeline을 실행할 때 docker container에서 실행하고자 하는 경우 사용합니다.  이러한 경우 일반적으로 top level agent는 none으로 설정하고 stage 에서 agent를 필요한 docker container image를 사용하기 위해 선언합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pipeline <span class="o">{</span>
    agent none 
    stages <span class="o">{</span>
        stage<span class="o">(</span><span class="s1">'Example Build'</span><span class="o">)</span> <span class="o">{</span>
            agent <span class="o">{</span> docker <span class="s1">'maven:3.8.7-eclipse-temurin-11'</span> <span class="o">}</span> 
            steps <span class="o">{</span>
                <span class="nb">echo</span> <span class="s1">'Hello, Maven'</span>
                sh <span class="s1">'mvn --version'</span>
            <span class="o">}</span>
        <span class="o">}</span>
        stage<span class="o">(</span><span class="s1">'Example Test'</span><span class="o">)</span> <span class="o">{</span>
            agent <span class="o">{</span> docker <span class="s1">'openjdk:8-jre'</span> <span class="o">}</span> 
            steps <span class="o">{</span>
                <span class="nb">echo</span> <span class="s1">'Hello, JDK'</span>
                sh <span class="s1">'java -version'</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="declarative-pipeline--agent">Declarative Pipeline : agent</h4>
<p>agent { kubernetes … } 로 설정되는 경우 dynamic agent로 동적으로 pipeline을 실행할 때만 resource를 사용하고 종료되면 resource를 반환하는 것으로 kubernetes 환경에서 Jenkins agent를 운영하고자 하는 경우 사용합니다.</p>

<h4 id="declarative-pipeline--tools">Declarative Pipeline : tools</h4>
<p>tools section은 stage에서 사용하는 tool을 사용하기 위해 정의하는 section입니다. agent none인 경우 tools는 무시됩니다. optional 항목입니다.</p>

<h4 id="declarative-pipeline--environemt">Declarative Pipeline : environemt</h4>
<p>environment section은 pipeline 또는 stage에서 사용하는 key-value 형식의 환경변수를 정의해서 stage에서 사용하는 section입니다.  credentials 를 미리 load,  value에 저장하여 stage에 사용할 수 있습니다.</p>

<h4 id="declarative-pipeline--stages">Declarative Pipeline : stages</h4>
<p>stages section은 최소한 하나 이상의 stage에 대한 모음을 정의합니다. 대두분의 작업, 예를 들면 Build, Test, Deploy stage와 같이 작업들이 stages의 아래에 위치합니다.</p>

<h4 id="declarative-pipeline--stage">Declarative Pipeline : stage</h4>
<p>stage section stages section안에 정의하며,하나의 steps section 을 포함합니다.</p>

<h4 id="declarative-pipeline--steps">Declarative Pipeline : steps</h4>
<p>steps section은 선언적 pipeline에서만 지원하는 것으로 steps내에 실제 해야 할 작업을 정의하는 영역입니다.</p>

<h4 id="declarative-pipeline--script">Declarative Pipeline : script</h4>
<p>script section은 scripted pipeline의 블록을 가져와 선언적 pipeline에서 실행합니다. 대부분의 사용 사례에서 script 단계는 선언적 파이프라인에서 필요하지 않지만 groovy 문법을 사용해야 하는 경우 사용할 수 있습니다.   script가 로직이 길고 복잡한 블록인 경우 대신 공유 라이브러리로 이동해야 합니다.</p>

<h4 id="declarative-pipeline--post">Declarative Pipeline : post</h4>
<p>post section은 pipeline 또는 stage 실행 상태,  성공,실패, 또는 성공과 실패에 상관없이 항상 실행하고자 할 떄 사용하는 기능입니다.<br />
•	pipeline block의 끝에 위치하거나 stage 에 위치
•	always, success, failure, changed, fixed, regression, aborted, unstable, unsuccessfull, cleanup을 지원합니다.</p>

<p>post는 Condition의 기능입니다.<br />
<strong>always</strong><br />
파이프라인 또는 단계 실행의 완료 상태에 관계없이 실행합니다.
<strong>changed</strong> <br />
현재 파이프라인의 실행이 이전 실행과 완료 상태가 다른 경우에만 changed 를 실행합니다.<br />
<strong>fixed</strong>  <br />
현재 파이프라인의 실행이 성공하고 이전 실행이 실패했거나 불안정한 경우에만 post 에 서 이 fixed 를 실행합니다 
<strong>regression</strong> <br />
현재 파이프라인 또는 상태가 실패, 불안정 또는 중단되고 이전 실행이 성공한 경우에만실행합니다.<br />
<strong>aborted</strong>    <br />
현재 파이프라인의 실행이 “중단됨” 상태인 경우(일반적으로 파이프라인이 수동으로 중단되었기 때문에) 사후 단계를 실행합니다. 일반적으로 웹 UI에서 회색으로 표시됩니다.<br />
<strong>failure</strong>  <br />
현재 파이프라인 또는 stage의 실행이 “실패” 상태(일반적으로 웹 UI에서 빨간색으로 표시됨)인 경우에만 실행합니다.<br />
<strong>success</strong>  <br />
현재 파이프라인 또는 스테이지의 실행이 “성공” 상태(일반적으로 웹 UI에서 파란색 또는 녹색으로 표시됨)인 경우에만 실행합니다.<br />
<strong>cleanup</strong>  <br />
파이프라인 또는 stage의 상태에 관계없이 다른 모든 사후 조건이 평가된 후 cleanup 실행합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pipeline <span class="o">{</span>
    agent any
    stages <span class="o">{</span>
        stage<span class="o">(</span><span class="s1">'Example'</span><span class="o">)</span> <span class="o">{</span>
            steps <span class="o">{</span>
                <span class="nb">echo</span> <span class="s1">'Hello World'</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    post <span class="o">{</span> 
        always <span class="o">{</span> 
            <span class="nb">echo</span> <span class="s1">'I will always say Hello again!'</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><summary type="html"><![CDATA[Jenkins Pipeline 이란 Jenkins Pipeline이란 Jenkins를 사용하여 CD 파이프라인울 구현하고 통합하는 것을 지원하는 플러그인의 집합입니다. Jenkins에 의해 정의된 모든 표준 Job을 하나의 script 작성되며 git 과 같은 repository 저장할 수 있습니다. 각 단계에 대해 여러 작업을 작성하는 대신 이제 전체 워크플로를 코딩하여 하나의 Jenkinsfile에 넣을 수 있습니다. 이러한 Pipeline을 작성하는 데에는 크게 두 가지, 선언적(Declarative) 구문 방식, 스크립팅(Scripted) 방식의 두 가지 유형의 구문을 사용하여 작성할 수 있습니다.]]></summary></entry><entry><title type="html">Private Gitlab Repository 구성하기</title><link href="http://localhost:4000/devops/gitlab-ce/" rel="alternate" type="text/html" title="Private Gitlab Repository 구성하기" /><published>2023-02-04T00:00:00+09:00</published><updated>2023-02-04T00:00:00+09:00</updated><id>http://localhost:4000/devops/gitlab-ce</id><content type="html" xml:base="http://localhost:4000/devops/gitlab-ce/"><![CDATA[<h2 id="gitlab-ce-설치하기">Gitlab-CE 설치하기</h2>
<p>git repository로 public 으로 사용할 수 있는 대표적인 것 중 하나가 github와 gitlab입니다.</p>

<p>gitlab은 Gitlab-CE 로 기업의 Private 환경에  git 소스 Repository로 구성이 가능합니다. 상용 솔루션으로 Bitbucket도 많이 사용하지만 오픈소스 무료 솔루션으로 구성할 수도 있습니다.</p>

<h2 id="step-1--gitlab을-위한-pre-requisites-package-설치">Step 1 : Gitlab을 위한 Pre-requisites package 설치</h2>
<p>gitalb-ce 를 설치하기 위한 사전 필수 패키지를 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nt">-y</span> <span class="nb">install </span>wget bash-completion git policycoreutils-python
</code></pre></div></div>

<h2 id="step-2--postfix-설치-및-설정">Step 2 : Postfix 설치 및 설정</h2>
<p>Gitlab system 에서 Notification 을 수행하기 위해 Postfix 를 설치하고 간단하게 설정합</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nt">-y</span> <span class="nb">install </span>postfix
</code></pre></div></div>

<p>/etc/postfix/main.cf 에서 아래의 내용을 수정합니다.</p>

<p>myhostname = gitlab.example.com 
mydomain = example.com<br />
myorigin = $myhostname <br />
inet_interfaces = all 
mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain<br />
relay_domains = $mydestination</p>

<p><img src="/assets/images/gitlab/01-jenkins-gitlab-main-cf.png" alt="gitlab-ce" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /etc/postfix/main.cf
</code></pre></div></div>

<h2 id="step-3--gitlab-ce-설치">Step 3 : Gitlab-CE 설치</h2>
<p>gitlab repo 정보를 download 받습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-sS</span> https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | <span class="nb">sudo </span>bash

<span class="nv">EXTERNAL_URL</span><span class="o">=</span><span class="s2">"https://gitlab.example.com"</span> yum <span class="nb">install</span> <span class="nt">-y</span> gitlab-ce

<span class="c"># gitalb 실행 상태 확인</span>
gitlab status
</code></pre></div></div>

<h2 id="step-4--private-domain-을-hosts-파일에-등록">Step 4 : private domain 을 hosts 파일에 등록</h2>

<p>브라우저에서 gitlab.example.com으로 접속하기 위해 laptop의 hosts에 gitlab.example.com domain을 등록하고 브라우저에서 접속합니다.</p>

<h2 id="step-5--root-사용자-비밀번호-초괴화">Step 5 : root 사용자 비밀번호 초괴화</h2>
<p>gitlab console로 접속하기 위해 다음의 명령어를 수행합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gitlab-rails console <span class="nt">-e</span> production
</code></pre></div></div>

<p>첫번째 아이디값을 user에 넣는 명령어이다. #&lt;User id:1 @root&gt; 라는 응답이 올것이다. 관리자계정은 root 입니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user <span class="o">=</span> User.where<span class="o">(</span><span class="nb">id</span>: 1<span class="o">)</span>.first

<span class="c"># 수행결과 </span>
<span class="nt">--------------------------------------------------------------------------------</span>
 Ruby:         ruby 2.7.7p221 <span class="o">(</span>2022-11-24 revision 168ec2b1e5<span class="o">)</span> <span class="o">[</span>x86_64-linux]
 GitLab:       15.8.1 <span class="o">(</span>383efe57adf<span class="o">)</span> FOSS
 GitLab Shell: 14.15.0
 PostgreSQL:   13.8
<span class="nt">------------------------------------------------------------</span><span class="o">[</span> booted <span class="k">in </span>36.14s <span class="o">]</span>
Loading production environment <span class="o">(</span>Rails 6.1.6.1<span class="o">)</span>

</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb<span class="o">(</span>main<span class="o">)</span>:001:0&gt; user <span class="o">=</span> User.where<span class="o">(</span><span class="nb">id</span>: 1<span class="o">)</span>.first

<span class="c"># 수행결과</span>
<span class="o">=&gt;</span> <span class="c">#&lt;User id:1 @root&gt;</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb<span class="o">(</span>main<span class="o">)</span>:011:0&gt; user.password<span class="o">=</span><span class="s1">'Passw0rd!'</span>
<span class="o">=&gt;</span> <span class="s2">"Passw0rd!과
irb(main):012:0&gt; user.password_confirmation='Passw0rd!'

=&gt; "</span>Passw0rd!<span class="s2">"
irb(main):013:0&gt; user.save
</span></code></pre></div></div>

<h2 id="step-6--gitlab-ce-로그인">Step 6 : gitlab-ce 로그인</h2>

<p>위에서 설정한 root 사용자의 credentials 정보로 로그인합니다.<br />
<img src="/assets/images/gitlab/02-jenkins-gitlab-root-login.png" alt="root login" /></p>

<p>gitab에 로그인 후 첫 화면은 다음과 같습니다.<br />
<img src="/assets/images/gitlab/03-jenkins-gitlab-home.png" alt="root home" /></p>

<h2 id="step-7--new-account-생성">Step 7 : New Account 생성</h2>
<p>gitlab 에 사용자를 추가하기 위해 admin을 선택합니다.<br />
<img src="/assets/images/gitlab/04-jenkins-gitlab-user.png" alt="add user" /></p>

<p>gitlab 에 사용자를 추가합니다.
<img src="/assets/images/gitlab/05-jenkins-gitlab-new-user.png" alt="new user" /></p>

<p>gitlab 에 사용자 정보를 입력하고 저장버튼을 클릭합니다.<br />
<img src="/assets/images/gitlab/06-jenkins-gitlab-new-user-save.png" alt="new user" /></p>

<p>gitlab 에 새로 생성한 사용자 정보를 확인하고, 초기 비밀번호를 설정하기 위해 Edit 버튼을 클릭합니다. <br />
<img src="/assets/images/gitlab/07-jenkins-gitlab-new-user-result.png" alt="new user" /></p>

<p>gitlab 에 새로 생성한 사용자 초기 임시 비밀번호를 설정하고 저장합니다.<br />
<img src="/assets/images/gitlab/08-jenkins-gitab-edit-new-user.png" alt="new user" /></p>

<h2 id="step-8--신규-사용자-로그인">Step 8 : 신규 사용자 로그인</h2>

<p>gitlab을 root사용자를 logout하고, 새로 생성한 user00로 로그인하여, 비밀번호를 설정합니다.<br />
<img src="/assets/images/gitlab/09-jenkins-gitlab-new-password.png" alt="new user" /></p>

<h2 id="step-9--신규-project-생성">Step 9 : 신규 project 생성</h2>

<p>gitlab을 smaple-service project를 생성합니다. 
<img src="/assets/images/gitlab/10-jenkins-gitlab-create-project.png" alt="new user" /></p>

<p>gitlab을 smaple-service project를 생성합니다. 
<img src="/assets/images/gitlab/11-jenkins-gitlab-create-blank-project.png" alt="new user" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="gitlab" /><summary type="html"><![CDATA[Gitlab-CE 설치하기 git repository로 public 으로 사용할 수 있는 대표적인 것 중 하나가 github와 gitlab입니다.]]></summary></entry><entry><title type="html">Harbor로 Docker Private Registry 구축하기</title><link href="http://localhost:4000/docker/Harbor%EB%A1%9C-Private-Registry-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="Harbor로 Docker Private Registry 구축하기" /><published>2023-01-30T00:00:00+09:00</published><updated>2023-01-30T00:00:00+09:00</updated><id>http://localhost:4000/docker/Harbor%EB%A1%9C%20Private%20Registry%20%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/docker/Harbor%EB%A1%9C-Private-Registry-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="harbor-로-docker-private-registry-구축하기">Harbor 로 Docker Private Registry 구축하기</h2>

<p>Harbor는 Offline Install과 Online Install 두 가지 방식으로 설치를 지원하고 있습니다. 이 실습에서는 Offline Install 을 기준으로 설치하도록 합니다. Harbor는 아래 github 사이트에 릴리즈 정보를 확인하고 download 받습니다.</p>

<p><a href="https://github.com/goharbor/harbor/releases/">Harbor 설치</a></p>

<h2 id="step-1-root-ca-certificates--생성">Step 1: Root CA Certificates  생성</h2>

<p>Docker Engine 설치는 아래 링크를 따라 설치과정을 참고해주세요</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/certs
openssl genrsa <span class="nt">-out</span> ca.key 4096
openssl req <span class="nt">-x509</span> <span class="nt">-new</span> <span class="nt">-nodes</span> <span class="nt">-sha512</span> <span class="nt">-days</span> 365 <span class="nt">-key</span> ca.key <span class="nt">-subj</span> <span class="s2">"/CN=*.example.com"</span> <span class="nt">-out</span> ca.crt
</code></pre></div></div>

<h2 id="step-2--server-private-key-생성">Step 2 : Server Private Key 생성</h2>

<p>Harbor 서버의 인증서를 생성합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Server의 비밀키 생성</span>
openssl genrsa <span class="nt">-out</span> server.key 4096
</code></pre></div></div>

<h2 id="step-3--harbor-서버의-csr-생성">Step 3 : Harbor 서버의 CSR 생성</h2>
<p>Server의 CSR 파일 생성</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-sha512</span> <span class="nt">-new</span> <span class="nt">-key</span> server.key <span class="nt">-out</span> server.crt <span class="nt">-subj</span> <span class="s2">"/CN=server1.example.com"</span>
</code></pre></div></div>

<h2 id="step-4-san-등록">Step 4: SAN 등록</h2>

<p>Harbor 서버의 IP : 169.56.100.106</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"subjectAltName = IP:169.56.100.106,IP:127.0.0.1,DNS:server.example.com"</span> <span class="o">&gt;</span> v3ext.cnf
</code></pre></div></div>

<h2 id="step-5-server-인증서-생성">Step 5: Server 인증서 생성</h2>
<p>Harbor Domain 이 server1.example.com 이라고 가정하고,<br />
로그인 사용자가 user01로 생성되어 있다면 다음과 같이 수행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 <span class="nt">-req</span> <span class="nt">-sha512</span> <span class="nt">-days</span> 365  <span class="nt">-CA</span> ca.crt <span class="nt">-CAkey</span> ca.key <span class="nt">-CAcreateserial</span> <span class="nt">-in</span> server.csr <span class="nt">-out</span> server.crt <span class="nt">-extfile</span> v3ext.cnf
</code></pre></div></div>
<p>Server 인증서 변환</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 <span class="nt">-inform</span> PEM <span class="nt">-in</span> server.crt <span class="nt">-out</span> server.cert
</code></pre></div></div>

<h2 id="step-6-인증서-업데이트">Step 6: 인증서 업데이트</h2>
<p>certificates 업데이트 합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># server.example.com</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /etc/docker/certs.d/server1.example.com
<span class="nb">mkdir</span> <span class="nt">-p</span> /etc/pki/ca-trust/source/anchors/

<span class="nb">cp</span> <span class="nt">-u</span> server.cert /etc/docker/certs.d/server1.example.com
<span class="nb">cp</span> <span class="nt">-u</span> server.key  /etc/docker/certs.d/server1.example.com
<span class="nb">cp</span> <span class="nt">-u</span> ca.crt      /etc/docker/certs.d/server1.example.com
<span class="nb">cp</span> <span class="nt">-u</span> ca.crt      /etc/pki/ca-trust/source/anchors/
<span class="nb">cp</span> <span class="nt">-u</span> server.crt  /etc/pki/ca-trust/source/anchors/

update-ca-trust
</code></pre></div></div>

<h2 id="step-7-호스트에-도메인-등록">Step 7: 호스트에 도메인 등록</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"119.81.103.68 server1.example.com"</span> <span class="o">&gt;&gt;</span> /etc/hosts
</code></pre></div></div>

<h2 id="step-8-download-harbor">Step 8: Download Harbor</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/goharbor/harbor/releases/download/v2.7.0/harbor-offline-installer-v2.7.0.tgz
<span class="nb">tar </span>xzvf harbor-offline-installer-v2.7.0.tgz
</code></pre></div></div>

<h2 id="step-9-configure-harbor-in-harboryml">Step 9: Configure harbor in harbor.yml</h2>
<p>Harbor 폴더로 이동하고 harbor.yml 을 수정합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># harbor.yml 작성</span>
<span class="nb">cd </span>harbor
<span class="nb">cp </span>harbor.yml.tmpl harbor.yml

<span class="c"># harbor.yml 편집</span>
vi harbor.yml
<span class="c"># ---------------------</span>
by external clients.
<span class="nb">hostname</span>: server1.example.com

<span class="c"># http related config</span>
http:
  <span class="c"># port for http, default is 80. If https enabled, this port will redirect to https port</span>
  port: 80

<span class="c"># https related config</span>
https:
  <span class="c"># https port for harbor, default is 443</span>
  port: 443
  <span class="c"># The path of cert and key files for nginx</span>
  certificate: /etc/docker/certs.d/server1.example.com/server.cert
  private_key: /etc/docker/certs.d/server1.example.com/server.key
</code></pre></div></div>

<h2 id="step-10-install-harbor">Step 10: Install Harbor</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./prepare
./install.sh

<span class="c"># 수행결과</span>
<span class="o">[</span>Step 0]: checking <span class="k">if </span>docker is installed ...

Note: docker version: 20.10.23

<span class="o">[</span>Step 1]: checking docker-compose is installed ...

Note: Docker Compose version v2.14.2

<span class="o">[</span>Step 2]: loading Harbor images ...
Loaded image: goharbor/prepare:v2.7.0
716575e41c45: Loading layer  145.8MB/145.8MB

<span class="o">[</span>Step 3]: preparing environment ...

<span class="o">[</span>Step 4]: preparing harbor configs ...
prepare base <span class="nb">dir </span>is <span class="nb">set </span>to /root/harbor
Clearing the configuration file: /config/registry/passwd
Clearing the configuration file: /config/registry/config.yml

<span class="o">[</span>Step 5]: starting Harbor ...
<span class="o">[</span>+] Running 10/10
 ⠿ Network harbor_harbor        Created       0.1s
 ⠿ Container harbor-log         Started                                         0.8s
 ⠿ Container harbor-db          Started                                         2.2s
 ⠿ Container registry           Started                                         2.2s
 ⠿ Container registryctl        Started                                         1.7s
 ⠿ Container redis              Started                                         1.8s
 ⠿ Container harbor-portal      Started                                         2.2s
 ⠿ Container harbor-core        Started                                         2.7s
 ⠿ Container harbor-jobservice  Started                                         3.8s
 ⠿ Container nginx              Started                                         3.9s

<span class="nt">----Harbor</span> has been installed and started successfully.----
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="Harbor" /><summary type="html"><![CDATA[Harbor 로 Docker Private Registry 구축하기]]></summary></entry><entry><title type="html">리모트 서버에서 Harbor 서버에 docker login</title><link href="http://localhost:4000/docker/%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-Harbor-%EC%97%90-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="리모트 서버에서 Harbor 서버에 docker login" /><published>2023-01-29T00:00:00+09:00</published><updated>2023-01-29T00:00:00+09:00</updated><id>http://localhost:4000/docker/%EB%A6%AC%EB%AA%A8%ED%8A%B8%20%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C%20Harbor%20%EC%97%90%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/docker/%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-Harbor-%EC%97%90-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="리모트-서버에서-harbor-서버에-docker-login">리모트 서버에서 Harbor 서버에 docker login</h2>

<p>리모트 서버는 Centos7을 기준으로 합니다.</p>

<p>Harbor Container Registry를 구축하고 리모트 서버에서 docker login 하기 위해 환경을 설정합니다.</p>

<h2 id="step-1-setup-docker-engine">Step 1: Setup Docker Engine</h2>

<p>Docker Engine 설치는 아래 링크를 따라 설치과정을 참고해주세요</p>

<p><a href="https://yoonjk.github.io/docker/docker/">Docker Engine 설치</a></p>

<h2 id="step-2--jfrog-artifactory-docker-image-를-download">Step 2 : JFrog Artifactory Docker Image 를 download</h2>

<p>hosts file 파일에 domain을 등록합니다.</p>

<p>Harbor 설치서버의 사설 도메인 서버 이름이 server1.example.com 라고 가정하고 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"119.81.103.68 server1.example.com"</span> <span class="o">&gt;&gt;</span> /etc/hosts
</code></pre></div></div>

<h2 id="step-3--harbor-에서-제공하는-ca-인증서를-복사">Step 3 : Harbor 에서 제공하는 CA 인증서를 복사</h2>

<p>Harbor 에서 제공하는 CA 인증서를 복사하고, 인증서 참조 디렉토리에 복사합니다.<br />
ca 인증서가 /root/certs 폴더에 있다고 가정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>scp root@119.81.103.68:/root/certs/ca.crt <span class="nb">.</span>

<span class="nb">sudo cp </span>ca.crt /etc/pki/ca-trust/source/anchors/

update-ca-trust extract
</code></pre></div></div>

<h2 id="step-4-restart-docker-engine-및-로그인">Step 4: Restart Docker Engine 및 로그인</h2>
<p>Docker Engine을 재시작합니다.</p>

<p>Harbor Domain 이 server1.example.com 이라고 가정하고,<br />
로그인 사용자가 user01로 생성되어 있다면 다음과 같이 수행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart docker
docker login <span class="nt">-u</span> user01 <span class="nt">-p</span> XXXX server1.example.com

WARNING! Using <span class="nt">--password</span> via the CLI is insecure. Use <span class="nt">--password-stdin</span><span class="nb">.</span>
WARNING! Your password will be stored unencrypted <span class="k">in</span> /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="Harbor" /><summary type="html"><![CDATA[리모트 서버에서 Harbor 서버에 docker login]]></summary></entry></feed>