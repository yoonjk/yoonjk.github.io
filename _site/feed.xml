<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-06T20:59:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Cloud Native Journey</title><subtitle>Software Engineer/Architect</subtitle><author><name>Jaeguk Yun</name></author><entry><title type="html">MacOS openJDK 1.8 설치하기</title><link href="http://localhost:4000/springboot/mac-jdk-switch/" rel="alternate" type="text/html" title="MacOS openJDK 1.8 설치하기" /><published>2023-03-06T00:00:00+09:00</published><updated>2023-03-06T00:00:00+09:00</updated><id>http://localhost:4000/springboot/mac-jdk-switch</id><content type="html" xml:base="http://localhost:4000/springboot/mac-jdk-switch/"><![CDATA[<h2 id="open-jdk">open jdk</h2>
<p>mac에서 open jdk를 설치합니다</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew tap AdoptOpenJDK/openjdk

brew <span class="nb">install</span> <span class="nt">--cask</span> adoptopenjdk8
</code></pre></div></div>
<h2 id="switch-jdk-18-to-11">switch jdk 1.8 to 11</h2>
<p>jdk를 여러 버전을 설치한 경우 jdk를 필요에 따라 switch하고자 하는 경우 다음과 같이 합니다.<br />
vi로 ~/.zshrc 파일을 편집하고 아래의 항목을 추가합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span><span class="sb">`</span>/usr/libexec/java_home <span class="nt">-v</span> 1.8<span class="sb">`</span>
</code></pre></div></div>

<p>zsh profile을 적용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.zshrc
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="openjdk" /><summary type="html"><![CDATA[open jdk mac에서 open jdk를 설치합니다]]></summary></entry><entry><title type="html">배너 추가</title><link href="http://localhost:4000/springboot/banner/" rel="alternate" type="text/html" title="배너 추가" /><published>2023-03-03T00:00:00+09:00</published><updated>2023-03-03T00:00:00+09:00</updated><id>http://localhost:4000/springboot/banner</id><content type="html" xml:base="http://localhost:4000/springboot/banner/"><![CDATA[<h2 id="배너-파일">배너 파일</h2>
<p>Springboot의 왼쪽 하단에 있는 dashboard tab에서 springboot를 시작하면 console 로그에 자신만의 로고를 출력하고 싶을 때가 있습니다. 이때 베너를 추가하는 방법에 설명합니다.</p>

<h2 id="배너-생성">배너 생성</h2>
<p>Springboot에서 배너를 추가하기 위해서 resources 폴더 하위에 banner.txt 파일을 생성해서 내용을 추가하면 springboot가 시작되면서 텍스트를 읽어 출력합니다.</p>

<p><img src="/assets/images/springboot/01-springboot-banner.png" alt="banner" /></p>

<h2 id="배너-텍스트-생성-및-복사">배너 텍스트 생성 및 복사</h2>

<p>아래의 <a href="http://patorjk.com/software/taag/">배너 링크 사이트</a>에서 배너를 작성해서 banner.txt에 내용을 붙여넣기 하면 쉽게 배너를 만들 수 있습니다.</p>

<p><a href="http://patorjk.com/software/taag/">http://patorjk.com/software/taag/</a></p>]]></content><author><name>Jaeguk Yun</name></author><category term="springboot" /><category term="banner" /><summary type="html"><![CDATA[배너 파일 Springboot의 왼쪽 하단에 있는 dashboard tab에서 springboot를 시작하면 console 로그에 자신만의 로고를 출력하고 싶을 때가 있습니다. 이때 베너를 추가하는 방법에 설명합니다.]]></summary></entry><entry><title type="html">mac 에서 jdk switch</title><link href="http://localhost:4000/docker/jdk-switch-on-mac/" rel="alternate" type="text/html" title="mac 에서 jdk switch" /><published>2023-03-02T00:00:00+09:00</published><updated>2023-03-02T00:00:00+09:00</updated><id>http://localhost:4000/docker/jdk%20switch-on-mac</id><content type="html" xml:base="http://localhost:4000/docker/jdk-switch-on-mac/"><![CDATA[<h2 id="jdk-11-or-8-switch">jdk 11 or 8 switch</h2>

<p>java 기반 개발을 하면서 jdk 다양한 버전이 필요해서 설치하는 경우 있습니다. jdk를 switch하고자 하는 경우
다음과 같이 .zshrc에 추가해서 사용합니다.</p>

<p>~/.zshrc 파일을 editor로 열어서 다음과 같이 JAVA_HOME을 추가하면 됩니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.zshrc
<span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span><span class="sb">`</span>/usr/libexec/java_home <span class="nt">-v</span> 1.8<span class="sb">`</span>

</code></pre></div></div>

<p>.zshrc 다시 적용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.zshrc
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="jdk" /><category term="mac" /><summary type="html"><![CDATA[jdk 11 or 8 switch]]></summary></entry><entry><title type="html">docker-compose로 postgreSQL 실행</title><link href="http://localhost:4000/docker/redis-docker-compose-copy/" rel="alternate" type="text/html" title="docker-compose로 postgreSQL 실행" /><published>2023-03-01T00:00:00+09:00</published><updated>2023-03-01T00:00:00+09:00</updated><id>http://localhost:4000/docker/redis-docker-compose%20copy</id><content type="html" xml:base="http://localhost:4000/docker/redis-docker-compose-copy/"><![CDATA[<h2 id="postgressql-docker-compose-파일">PostgresSQL docker-compose 파일</h2>
<p>새로운 응용 프로그램을 만들 때 PostgreSQL을 데이터베이스 엔진으로 자주 사용합니다. 빠르고 사용하기 쉬우 며 인터넷상의 거의 모든 프로그래밍 언어 및 플랫폼과 매우 잘 통합됩니다.<br />
Windows 시스템을 실행하지 않고 macOS 또는 Linux에서 PostgreSQL 데이터베이스를 실행해야하는 경우 Docker를 사용할 수 있습니다. 몇 가지 간단한 명령만으로 도커에서 PostgreSQL을 시작하는 것은 매우 쉽습니다.</p>

<p>이 글은 매우 간단하고 따라하기 쉽습니다. docker-compose 파일을 작성하여 standalone PostgreSQL 데이터베이스를 실행할 수 있습니다.</p>

<p>컨테이너에서 데이터베이스를 실행하는 것은 개발 환경뿐만 아니라 프로덕션 환경에서도 매우 이상적입니다. 호스팅 환경의 전체 아키텍처를 변경하지 않고도 쉽게 확장하고 사용자의 요구에 맞게 조정할 수 있습니다.
스마트한 방식으로 작업하는 경우(열심히 작업하지 않고 스마트하게 작업) 데이터베이스를 CI/CD 파이프라인에 통합하여 애플리케이션과 연결된 데이터베이스가 항상 있고 팀의 다른 개발자도 수많은 소프트웨어를 로컬로 다운로드하여 설치하지 않고도 개발 머신에서 새로운 기능을 테스트할 수 있도록 합니다.</p>

<h2 id="도커-작성을-사용하여-postgresql을-실행하는-방법">도커 작성을 사용하여 PostgreSQL을 실행하는 방법</h2>
<p>도커 작성을 사용하여 인프라를 코드로 지정하면 PostgreSQL을 시작하는 것은 매우 쉽습니다.<br />
아래는 PostgreSQL을 쉽게 시작하고 실행하는 방법을 보여주는 전체 docker-compose.yaml 파일입니다. 
여기에는  데이터베이스 데이터에 대한 로컬 볼륨(경로)을 자동으로 생성하는 볼륨 섹션이 포함되어 있습니다. 이렇게 하면 컨테이너가 다시 시작되어도 데이터가 손실되지 않습니다. 일반적으로 모든 데이터는 컨테이너 내부의 메모리에 있지만 이렇게하면 유지할 수 있습니다.</p>

<h2 id="username-and-password-설정">username and password 설정</h2>

<p>항상 환경 변수 내에서 민감한 데이터를 구성하여 작성 파일 내부에 노출되지 않도록 합니다. 이렇게 하면 다른 개발자가 내 자격 증명을 몰라도 작성 파일을 공유 할 수 있습니다.<br />
환경. 구성해야 하는 변수는 다음과 같습니다.</p>
<ul>
  <li>POSTGRES_USER</li>
  <li>POSTGRES_PASSWORD
필요에 따라 자격 증명을 설정할 수 있습니다. 다음은 데모를 위한 작성 파일 내의 자격 증명입니다.</li>
</ul>

<p>postgreSQL docker-compose 파일입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.5'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">postgres</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">postgres</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres:latest</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">POSTGRES_USER</span><span class="pi">:</span> <span class="s">postgres</span>
      <span class="na">POSTGRES_PASSWORD</span><span class="pi">:</span> <span class="s">admin1234</span>
      <span class="na">PGDATA</span><span class="pi">:</span> <span class="s">/data/postgres</span>
    <span class="na">volumes</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="s">postgres-db:/data/postgres</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5432:5432"</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">postgres-db</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">local</span>
</code></pre></div></div>
<p>위의 코드를 자신의 도커 작성 파일에 복사 할 수 있습니다.  이 데모에서 내 이름을 docker-compose.yaml로 지정했습니다</p>

<p>docker-compose.yaml 파일이 있는 곳에서 docker-compose를 실행합니다.<br />
Mac 또는 Linux (GUI) 컴퓨터를 사용하는 경우 터미널을 불러와 작성 파일을 저장 한 폴더 내에서 아래 명령을 실행할 수 있습니다. 하드 코어이고 CLI에서만 작업하는 경우 아래 명령을 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>
<p>이렇게 하면 Docker Hub에서 최신 버전의 PostgreSQL을 가져옵니다.<br />
컨테이너가 실행 중인지 확인하려면 터미널에서 다음 명령을 실행할 수 있습니다. 그러면 모든 Docker 프로세스가 나열됩니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps
</code></pre></div></div>
<p>또는</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose ps
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="postgresSQL" /><summary type="html"><![CDATA[PostgresSQL docker-compose 파일 새로운 응용 프로그램을 만들 때 PostgreSQL을 데이터베이스 엔진으로 자주 사용합니다. 빠르고 사용하기 쉬우 며 인터넷상의 거의 모든 프로그래밍 언어 및 플랫폼과 매우 잘 통합됩니다. Windows 시스템을 실행하지 않고 macOS 또는 Linux에서 PostgreSQL 데이터베이스를 실행해야하는 경우 Docker를 사용할 수 있습니다. 몇 가지 간단한 명령만으로 도커에서 PostgreSQL을 시작하는 것은 매우 쉽습니다.]]></summary></entry><entry><title type="html">docker-compose로 redis standalone으로 실행</title><link href="http://localhost:4000/docker/redis-docker-compose/" rel="alternate" type="text/html" title="docker-compose로 redis standalone으로 실행" /><published>2023-03-01T00:00:00+09:00</published><updated>2023-03-01T00:00:00+09:00</updated><id>http://localhost:4000/docker/redis-docker-compose</id><content type="html" xml:base="http://localhost:4000/docker/redis-docker-compose/"><![CDATA[<h2 id="redis-docker-compose-파일">Redis docker-compose 파일</h2>

<p>redis docker-compose 파일입니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
    <span class="na">redis</span><span class="pi">:</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">redis:alpine</span>
      <span class="na">command</span><span class="pi">:</span> <span class="s">redis-server --port </span><span class="m">6379</span>
      <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">name=redis"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">mode=standalone"</span>
      <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">6379:6379</span>
</code></pre></div></div>

<p>docker-compose.yaml 파일이 있는 곳에서 docker-compose를 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up -d
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="redis" /><summary type="html"><![CDATA[Redis docker-compose 파일]]></summary></entry><entry><title type="html">mysql docker-compose 로 실행하기</title><link href="http://localhost:4000/docker/mysql-docker-compose/" rel="alternate" type="text/html" title="mysql docker-compose 로 실행하기" /><published>2023-03-01T00:00:00+09:00</published><updated>2023-03-01T00:00:00+09:00</updated><id>http://localhost:4000/docker/mysql-docker-compose</id><content type="html" xml:base="http://localhost:4000/docker/mysql-docker-compose/"><![CDATA[<h2 id="mysql-docker-compose-파일">mysql docker-compose 파일</h2>

<p>mysql docker-compose 파일입니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> data
vi docker-compose.yaml
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span> <span class="c1"># 파일규격버전</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span> <span class="c1"># 서비스이름</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:8.0.23</span> <span class="c1"># 이미지</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">mysql</span> <span class="c1"># 컨테이너 이름</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3306:3306"</span> <span class="c1"># 포트 설정  외부:내부</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1234qwer"</span> <span class="c1"># 패스워드설정</span>
      <span class="na">MYSQL_DATABASE</span><span class="pi">:</span> <span class="s2">"</span><span class="s">demo"</span>
      <span class="na">MYSQL_USER</span><span class="pi">:</span> <span class="s2">"</span><span class="s">user00"</span>
      <span class="na">MYSQL_PASSWORD</span><span class="pi">:</span> <span class="s2">"</span><span class="s">admin1234"</span>
    <span class="na">command</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">--character-set-server=utf8</span> <span class="c1"># 인코딩</span>
      <span class="pi">-</span> <span class="s">--collation-server=utf8_general_ci</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data:/dev/docker/db/mysql-db01</span> <span class="c1"># 마운트 설정</span>
</code></pre></div></div>

<p>docker-compose.yaml 파일이 있는 곳에서 docker-compose를 실행합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up -d
</code></pre></div></div>]]></content><author><name>Jaeguk Yun</name></author><category term="docker" /><category term="mysql" /><summary type="html"><![CDATA[mysql docker-compose 파일]]></summary></entry><entry><title type="html">nginx as Reverse Proxy for Jenkins</title><link href="http://localhost:4000/devops/nginx-as-a-reverse-proxy-for-jenkins/" rel="alternate" type="text/html" title="nginx as Reverse Proxy for Jenkins" /><published>2023-02-24T00:00:00+09:00</published><updated>2023-02-24T00:00:00+09:00</updated><id>http://localhost:4000/devops/nginx%20as%20a%20reverse%20proxy%20for%20jenkins</id><content type="html" xml:base="http://localhost:4000/devops/nginx-as-a-reverse-proxy-for-jenkins/"><![CDATA[<p>Jenkins를 Nginx Reverse Proxy를 설정하여 접근하는 것을 설명합니다.</p>

<h2 id="nginx-설치">Nginx 설치</h2>
<p>nginx를 설치하기 위해 사전에 필요한 package를 아래와 같이 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> yum-utils
yum <span class="nb">install</span> <span class="nt">-y</span> epel-release
</code></pre></div></div>

<p>nginx를 설치합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> nginx
</code></pre></div></div>

<p>nginx의 status를 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>● nginx.service - The nginx HTTP and reverse proxy server
   Loaded: loaded <span class="o">(</span>/usr/lib/systemd/system/nginx.service<span class="p">;</span> disabled<span class="p">;</span> vendor preset: disabled<span class="o">)</span>
   Active: inactive <span class="o">(</span>dead<span class="o">)</span>
</code></pre></div></div>
<h2 id="nginx-시작">nginx 시작</h2>
<p>jenkins.service 파일에서 Environment의 JENKINS_PORT=9080으로 변경합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl start nginx
</code></pre></div></div>

<p>nginx가 정상적으로 실행되었는지 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>● nginx.service - The nginx HTTP and reverse proxy server
   Loaded: loaded <span class="o">(</span>/usr/lib/systemd/system/nginx.service<span class="p">;</span> disabled<span class="p">;</span> vendor preset: disabled<span class="o">)</span>
   Active: active <span class="o">(</span>running<span class="o">)</span> since Fri 2023-02-24 08:13:06 CST<span class="p">;</span> 28s ago
  Process: 49962 <span class="nv">ExecStart</span><span class="o">=</span>/usr/sbin/nginx <span class="o">(</span><span class="nv">code</span><span class="o">=</span>exited, <span class="nv">status</span><span class="o">=</span>0/SUCCESS<span class="o">)</span>
  Process: 49958 <span class="nv">ExecStartPre</span><span class="o">=</span>/usr/sbin/nginx <span class="nt">-t</span> <span class="o">(</span><span class="nv">code</span><span class="o">=</span>exited, <span class="nv">status</span><span class="o">=</span>0/SUCCESS<span class="o">)</span>
  Process: 49956 <span class="nv">ExecStartPre</span><span class="o">=</span>/usr/bin/rm <span class="nt">-f</span> /run/nginx.pid <span class="o">(</span><span class="nv">code</span><span class="o">=</span>exited, <span class="nv">status</span><span class="o">=</span>0/SUCCESS<span class="o">)</span>
 Main PID: 49964 <span class="o">(</span>nginx<span class="o">)</span>
   CGroup: /system.slice/nginx.service
           ├─49964 nginx: master process /usr/sbin/ngin
           ├─49965 nginx: worker proces
           └─49966 nginx: worker proces

Feb 24 08:13:06 virtualserver01.HyukSeoung-Choi-s-Account.cloud systemd[1]: Starting The nginx HTTP and reverse proxy server...
Feb 24 08:13:06 virtualserver01.HyukSeoung-Choi-s-Account.cloud nginx[49958]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
Feb 24 08:13:06 virtualserver01.HyukSeoung-Choi-s-Account.cloud nginx[49958]: nginx: configuration file /etc/nginx/nginx.conf <span class="nb">test </span>is successful
Feb 24 08:13:06 virtualserver01.HyukSeoung-Choi-s-Account.cloud systemd[1]: Started The nginx HTTP and reverse proxy server.
</code></pre></div></div>

<p>nginx configuration 테스트합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nginx <span class="nt">-t</span>
</code></pre></div></div>
<p>google.com에서 <a href="https://www.jenkins.io/doc/book/system-administration/reverse-proxy-configuration-nginx/">jenkins reverse proxy nginx</a> 키워드로 검색해서 나온 결과중에<br />
첫번째 검색결과항목을 클릭합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>upstream jenkins <span class="o">{</span>
  keepalive 32<span class="p">;</span> <span class="c"># keepalive connections</span>
  server 127.0.0.1:8080<span class="p">;</span> <span class="c"># jenkins ip and port</span>
<span class="o">}</span>

<span class="c"># Required for Jenkins websocket agents</span>
map <span class="nv">$http_upgrade</span> <span class="nv">$connection_upgrade</span> <span class="o">{</span>
  default upgrade<span class="p">;</span>
  <span class="s1">''</span> close<span class="p">;</span>
<span class="o">}</span>

server <span class="o">{</span>
  listen          80<span class="p">;</span>       <span class="c"># Listen on port 80 for IPv4 requests</span>

  server_name     jenkins.example.com<span class="p">;</span>  <span class="c"># replace 'jenkins.example.com' with your server domain name</span>

  <span class="c"># this is the jenkins web root directory</span>
  <span class="c"># (mentioned in the output of "systemctl cat jenkins")</span>
  root            /var/run/jenkins/war/<span class="p">;</span>

  access_log      /var/log/nginx/jenkins.access.log<span class="p">;</span>
  error_log       /var/log/nginx/jenkins.error.log<span class="p">;</span>

  <span class="c"># pass through headers from Jenkins that Nginx considers invalid</span>
  ignore_invalid_headers off<span class="p">;</span>

  location ~ <span class="s2">"^/static/[0-9a-fA-F]{8}</span><span class="se">\/</span><span class="s2">(.*)$"</span> <span class="o">{</span>
    <span class="c"># rewrite all static files into requests to the root</span>
    <span class="c"># E.g /static/12345678/css/something.css will become /css/something.css</span>
    rewrite <span class="s2">"^/static/[0-9a-fA-F]{8}</span><span class="se">\/</span><span class="s2">(.*)"</span> /<span class="nv">$1</span> last<span class="p">;</span>
  <span class="o">}</span>

  location /userContent <span class="o">{</span>
    <span class="c"># have nginx handle all the static requests to userContent folder</span>
    <span class="c"># note : This is the $JENKINS_HOME dir</span>
    root /var/lib/jenkins/<span class="p">;</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nt">-f</span> <span class="nv">$request_filename</span><span class="o">){</span>
      <span class="c"># this file does not exist, might be a directory or a /**view** url</span>
      rewrite <span class="o">(</span>.<span class="k">*</span><span class="o">)</span> /<span class="nv">$1</span> last<span class="p">;</span>
      <span class="nb">break</span><span class="p">;</span>
    <span class="o">}</span>
    sendfile on<span class="p">;</span>
  <span class="o">}</span>

  location / <span class="o">{</span>
      sendfile off<span class="p">;</span>
      proxy_pass         http://jenkins<span class="p">;</span>
      proxy_redirect     default<span class="p">;</span>
      proxy_http_version 1.1<span class="p">;</span>

      <span class="c"># Required for Jenkins websocket agents</span>
      proxy_set_header   Connection        <span class="nv">$connection_upgrade</span><span class="p">;</span>
      proxy_set_header   Upgrade           <span class="nv">$http_upgrade</span><span class="p">;</span>

      proxy_set_header   Host              <span class="nv">$host</span><span class="p">;</span>
      proxy_set_header   X-Real-IP         <span class="nv">$remote_addr</span><span class="p">;</span>
      proxy_set_header   X-Forwarded-For   <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
      proxy_set_header   X-Forwarded-Proto <span class="nv">$scheme</span><span class="p">;</span>
      proxy_max_temp_file_size 0<span class="p">;</span>

      <span class="c">#this is the maximum upload size</span>
      client_max_body_size       10m<span class="p">;</span>
      client_body_buffer_size    128k<span class="p">;</span>

      proxy_connect_timeout      90<span class="p">;</span>
      proxy_send_timeout         90<span class="p">;</span>
      proxy_read_timeout         90<span class="p">;</span>
      proxy_buffering            off<span class="p">;</span>
      proxy_request_buffering    off<span class="p">;</span> <span class="c"># Required for HTTP CLI commands</span>
      proxy_set_header Connection <span class="s2">""</span><span class="p">;</span> <span class="c"># Clear for keepalive</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>위의 내용을 클립보드에 복사하고 jenkins.conf 파링에 붙여넣기 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/nginx/conf.d/
vi jenkins.conf
</code></pre></div></div>

<p>jenkins.conf에서 아래의 내용으로 변경합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root            /var/cache/jenkins/war/<span class="p">;</span>
</code></pre></div></div>

<p>nginx configuration을 테스트하고 nginx를 재시작합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nginx <span class="nt">-t</span>
systemctl restart nginx
</code></pre></div></div>

<p>browser에서 jenkins server에  80 port로 접속합니다.<br />
만약 502 Bad Gateway가 발생하면 아래의 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setenforce permissive
</code></pre></div></div>

<p>jenkins server에 접속하여 Manage jenkins &gt; Configure System 에 접속하여 jenkins URL을 변경합니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><category term="nginx" /><summary type="html"><![CDATA[Jenkins를 Nginx Reverse Proxy를 설정하여 접근하는 것을 설명합니다.]]></summary></entry><entry><title type="html">Jenkins Port 변경</title><link href="http://localhost:4000/devops/change-jenkins-port/" rel="alternate" type="text/html" title="Jenkins Port 변경" /><published>2023-02-24T00:00:00+09:00</published><updated>2023-02-24T00:00:00+09:00</updated><id>http://localhost:4000/devops/change-jenkins-port</id><content type="html" xml:base="http://localhost:4000/devops/change-jenkins-port/"><![CDATA[<h2 id="jenkins-port-확인-및-복사">Jenkins Port 확인 및 복사</h2>
<p>Jenkins Default Port를 확인하기 위해 아래와 같이 명령어를 실행합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl edit jenkins <span class="nt">--full</span>
</code></pre></div></div>
<p>JENKINS_PORT를 검색해서  아래의 내용을 clipboard에 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Environment</span><span class="o">=</span><span class="s2">"JENKINS_PORT=8080"</span>
</code></pre></div></div>

<h2 id="jenkins-port-변경">Jenkins Port 변경</h2>
<p>jenkins.service 파일에서 Environment의 JENKINS_PORT=9080으로 변경합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl edit jenkins.service
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"JENKINS_PORT=9080"</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl restart jenkins
</code></pre></div></div>

<p>위에서 지정한 Port로 접속해서 Port가 변경된 것을 확인합니다.</p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><summary type="html"><![CDATA[Jenkins Port 확인 및 복사 Jenkins Default Port를 확인하기 위해 아래와 같이 명령어를 실행합니다. systemctl edit jenkins --full JENKINS_PORT를 검색해서 아래의 내용을 clipboard에 복사합니다. Environment="JENKINS_PORT=8080"]]></summary></entry><entry><title type="html">Jenkins 서버 재시작 방법</title><link href="http://localhost:4000/devops/how-to-restart-jenkins/" rel="alternate" type="text/html" title="Jenkins 서버 재시작 방법" /><published>2023-02-24T00:00:00+09:00</published><updated>2023-02-24T00:00:00+09:00</updated><id>http://localhost:4000/devops/how-to-restart-jenkins</id><content type="html" xml:base="http://localhost:4000/devops/how-to-restart-jenkins/"><![CDATA[<h2 id="jenkins-port-확인-및-복사">Jenkins Port 확인 및 복사</h2>
<p>Jenkins 를 재시작하는 방법은 3가지 있습니다.</p>
<ul>
  <li>systemctl 사용</li>
  <li>browser에서 restart</li>
  <li>browser에서 safeRestart</li>
</ul>

<h2 id="systemctl-사용">Systemctl 사용</h2>
<p>systemctl 명령어로 사용하는 경우 Jenkins Job이 실행중인 것이 있더라도 jenkins를 즉시 재시작합니다.<br />
Jenkins 가 재시작 이후 그존 실행중인 job은 다시 재개합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart jenkins
</code></pre></div></div>
<h2 id="browser에서-restart">browser에서 restart</h2>
<p>Jenkins를 로그인 해서 browser url에서 your-jenkins/restart를 입력하면 다음과 같이 재시작 여부를 묻는 메시지가 출력됩니다.</p>

<p>Are you sure you want to restart Jenkins?</p>

<p>Yes 버튼을 클릭합니다.</p>

<h2 id="browser에서-saferestart">browser에서 safeRestart</h2>
<p>browser에서 safeRestart를 수행하면 다음과 같이 메시지가 출력됩니다. 기존 수행중인 Job 은 중단되고, Jenkins가 재시작하면 다시 재게합니다.<br />
Yes 버튼을 클릭합니다.</p>

<p>Are you sure you want to restart Jenkins? Jenkins will restart once all running jobs are finished. (Pipeline builds may prevent Jenkins from restarting for a short period of time in some cases, but if so, they will be paused at the next available opportunity and then resumed after Jenkins restarts.)</p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><summary type="html"><![CDATA[Jenkins Port 확인 및 복사 Jenkins 를 재시작하는 방법은 3가지 있습니다. systemctl 사용 browser에서 restart browser에서 safeRestart]]></summary></entry><entry><title type="html">Jenkins-Grafana 설정</title><link href="http://localhost:4000/devops/grafana-setup/" rel="alternate" type="text/html" title="Jenkins-Grafana 설정" /><published>2023-02-19T00:00:00+09:00</published><updated>2023-02-19T00:00:00+09:00</updated><id>http://localhost:4000/devops/grafana%20setup</id><content type="html" xml:base="http://localhost:4000/devops/grafana-setup/"><![CDATA[<h2 id="grafana-로그인">Grafana 로그인</h2>
<p>Grafana에 로그인하고, 비밀번호를 변경합니다.<br />
<img src="/assets/images/jenkins/03-grafana-login.png" alt="gitlab-ce" /></p>

<h2 id="prometheus-설정">Prometheus 설정</h2>
<p>Grafana에 로그인하면 다음과 같이 화면이 출력됩니다.<br />
<img src="/assets/images/jenkins/04-grafana-first.png" alt="gitlab-ce" /></p>

<p>설정을 선택하고, Grafana에 datasource를 추가하기 위해 Add data source를 클릭합니다.<br />
<img src="/assets/images/jenkins/05-grafana-add-datasource.png" alt="gitlab-ce" /></p>

<p>Prometheus datasource를 선택합니다.<br />
<img src="/assets/images/jenkins/06-grafana-prometheus-datasource.png" alt="gitlab-ce" /></p>

<p>Prometheus datasource를 설정합니다.<br />
<img src="/assets/images/jenkins/06-grafana-prometheus-setting.png" alt="gitlab-ce" /></p>

<p>Prometheus save-test 버튼을 클릭하면 Data source is working 메시지를 출력됩니다.<br />
![gitlab-ce](/assets/images/jenkins/07-grafana-prometheus-save-test.png</p>

<h2 id="jenkins-dashboard-선택">Jenkins dashboard 선택</h2>

<p><a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a> 에서 download jenkins dashboard를 선택합니다.</p>

<p><img src="/assets/images/jenkins/08-grafana-select-dashboard.png" alt="gitlab-ce" /></p>

<p>Jenkins Dashbaord Id를 clipboard에 복사합니다.<br />
<img src="/assets/images/jenkins/09-grafana-copy-clipboard.png" alt="gitlab-ce" /></p>

<p>Grafana에 Jenkins Dashboard ID를 반입합니다.<br />
<img src="/assets/images/jenkins/10-grafana-import-id.png" alt="gitlab-ce" /></p>

<p>Dashboard ID를 load합니다.<br />
<img src="/assets/images/jenkins/11-grafana-load.png" alt="gitlab-ce" /></p>

<p>Dashboard ID를 load합니다.<br />
<img src="/assets/images/jenkins/11-grafana-load.png" alt="gitlab-ce" /></p>

<p>Prometheus 항목에서 Prometheus-jenkins를 선택하고 import 버튼을 클릭합니다.<br />
<img src="/assets/images/jenkins/12-grafana-import-prometheus.png" alt="gitlab-ce" /></p>

<p>Jenkins Dashboard가 import 된 화면이 출력됩니다.<br />
<img src="/assets/images/jenkins/12-grafana-import-prometheus.png" alt="gitlab-ce" /></p>

<p>Jenkins Dashboard 첫 화면이 출력됩니다.<br />
<img src="/assets/images/jenkins/13-grafana-first-logon.png" alt="gitlab-ce" /></p>]]></content><author><name>Jaeguk Yun</name></author><category term="devops" /><category term="jenkins" /><category term="prometheus" /><category term="grafana" /><summary type="html"><![CDATA[Grafana 로그인 Grafana에 로그인하고, 비밀번호를 변경합니다.]]></summary></entry></feed>